{"meta":{"title":"Shymuel's Blog","subtitle":"","description":"Learn and Play","author":"Shymuel","url":"https://shymuel.top","root":"/"},"pages":[{"title":"","date":"2021-08-29T08:30:13.980Z","updated":"2021-06-26T12:07:06.000Z","comments":true,"path":"404.html","permalink":"https://shymuel.top/404.html","excerpt":"","text":""},{"title":"","date":"2021-06-26T12:04:55.000Z","updated":"2021-06-27T03:19:42.000Z","comments":true,"path":"about/index.html","permalink":"https://shymuel.top/about/index.html","excerpt":"","text":"只是一时兴起罢了。 E-mail: shymuel1998@163.com Brief：C++/Java，太弱小了，没有力量。 2021.06.26 如果不提高业务能力的话，就不得不昧着良心去做事情了。所以为了让自己心里好受一些，也要努力学习和进步。"},{"title":"所有分类","date":"2021-06-27T03:16:47.000Z","updated":"2021-06-27T03:18:24.000Z","comments":true,"path":"categories/index.html","permalink":"https://shymuel.top/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-06-27T03:19:59.000Z","updated":"2021-08-17T04:05:46.000Z","comments":true,"path":"friends/index.html","permalink":"https://shymuel.top/friends/index.html","excerpt":"目前只有一个友链的shymuel是屑。","text":"目前只有一个友链的shymuel是屑。 不会有人从这个渠道申请吧？不会吧不会吧？"},{"title":"img","date":"2021-06-26T12:06:11.000Z","updated":"2021-06-26T12:06:12.000Z","comments":true,"path":"img/index.html","permalink":"https://shymuel.top/img/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-29T09:19:25.116Z","updated":"2021-08-29T09:19:25.116Z","comments":true,"path":"tags/index.html","permalink":"https://shymuel.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【python】Collections","slug":"pythonCollections","date":"2022-05-01T14:22:23.000Z","updated":"2022-05-01T14:26:25.661Z","comments":true,"path":"1245507953.html","link":"","permalink":"https://shymuel.top/1245507953.html","excerpt":"","text":"这个库内含多种容器。 defaultdict 它解决的是我们使用dict当中最常见的问题，就是key为空的情况，访问一个dict中不存在的key会导致系统抛出异常。 dict当中为我们提供了带默认值的get方法。比如，可以写成： 1return dict.get(key, None) 这样，当key不在dict当中存在的时候，会自动返回设置的默认值。这省去了很多麻烦的判断，但是在一些特殊情况下仍然存在一点问题。比如当希望将key相同的value存进一个list当中而不是只保留一个，需要写成： 1234567data = [(1, 3), (2, 1), (1, 4), (2, 5), (3, 7)]d = &#123;&#125;for k, v in data: if k in d: d[k].append(v) else: d[k] = [v] 或者： 1234for k, v in data: cur = d.get(k, []) cur.append(v) d[k] = cur 为了完美解决这个问题，可以使用collections当中的defaultdict： 12345from collections import defaultdictd = defaultdict(list)for k, v in data: d[k].append(v) 使用defaultdict之后，如果key不存在，容器会自动返回预先设置的默认值。需要注意的是 defaultdict 传入的默认值可以是一个类型也可以是一个方法。如果传入int，默认值会被设置成int()的结果，也就是0。如果想要自定义或者修改，可以传入一个方法，比如： 1234d = defaultdict(lambda: 3)for k, v in data: d[k] += v Counter 对数据进行统计。只需要一行代码即可统计一个list中的内容： 1234567words = [&#x27;apple&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;watermelon&#x27;, &#x27;pear&#x27;, &#x27;peach&#x27;]from collections import Countercounter = Counter(words)&gt;&gt;&gt; print(counter)Counter(&#123;&#x27;apple&#x27;: 2, &#x27;pear&#x27;: 2, &#x27;watermelon&#x27;: 1, &#x27;peach&#x27;: 1&#125;) 上面的代码直接将一个list传入Counter中作为参数，它会自动给每个元素计数。 筛选topK也非常简单，Counter 提供了most_common()方法，只需要传入需求的K即可： 123counter.most_common(1)[(&#x27;apple&#x27;, 2)] 除此之外，Counter的构造函数还接收dict类型。可以直接通过一个value是int类型的dict来初始化一个Counter，比如： 12c = Counter(&#123;&#x27;apple&#x27;: 5, &#x27;pear&#x27;: 4&#125;)c = Counter(apple=4, pear=3) 并且，Counter还支持加减法的操作。两个Counter相加时会自动合并，即相同的key对应的value累加。相减也是同理，会将能对应的value做减法，被减的key中没有对应的会保留，而减数中没有对应的key则会被丢弃。并且需要注意，Counter支持value为负数。 deque queue是队列，deque是双端队列。deque的队首和队尾都支持元素的插入和弹出。 除了常用的clear、copy、count、extend等api之外，deque当中最常用也是最核心的api还有append、pop、appendleft和popleft。append和pop与list的append和pop一样是在队尾进行操作，而appendleft和popleft则是在队列左侧，也就是队首进行pop和append的操作。 真正用到双端队列的算法不太多，使用deque主要有两个原因。第一个原因是deque收到GIL的管理，它是线程安全的。而list则没有GIL锁，因此不是线程安全的。也就是说在并发场景下，list可能会导致一致性问题，而deque不会。另一个原因是deque支持固定长度，当长度满了之后继续append时，它会自动弹出最早插入的数据。 当拥有海量的数据，想要保留最后出现的指定数量的数据的时候，就可以使用deque： 12345from collections import dequedque = deque(maxlen=10)# 假设我们想要从文件当中获取最后10条数据for i in f.read(): dque.append(i) namedtuple namedtuple很特殊，涉及到元编程的概念。 常见的面向对象是定义类，然后通过类的构造函数来创建实例。元编程指的是定义元类，根据元类创建出一个类。如果用模具和成品来分别比喻类和实例的话，元类相当于是模具的模具。 namedtuple是一个非常简单的元类，通过它可以非常方便地定义想要的类。 比如如果我们想要定义一个学生类，这个类当中有name、score、age这三个字段，那么这个类会写成： 12345class Student: def __init__(self, name=None, score=None, age=None): self.name = name self.score = score self.age = age 这只是粗略的写法，如果考虑规范还需要定义property等注解，又需要很多代码。使用namedtuple可以简化这个工作： 1234567from collections import namedtuple# 这个是类，columns也可以写成&#x27;name score age&#x27;，即用空格分开Student = namedtuple(&#x27;Student&#x27;, [&#x27;name&#x27;, &#x27;score&#x27;, &#x27;age&#x27;])# 这个是实例student = Student(name=&#x27;xiaoming&#x27;, score=99, age=10)print(student.name) 通过使用namedtuple，只用一行就定义了一个类。还可以通过传入defaults参数来定义缺省值： 1Student = namedtuple(&#x27;Student&#x27;, [&#x27;name&#x27;, &#x27;score&#x27;, &#x27;age&#x27;], defaults=(0, 0)) 可以注意到，虽然定义了三个字段，但是只设置了两个缺失值。在这种情况下，namedtuple会自动将缺失值匹配上score和age两个字段。因为在Python的规范当中，必选参数一定在可选参数前面。所以nuamdtuple会自动右对齐。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://shymuel.top/tags/Python/"}]},{"title":"【C++】知识点","slug":"C-01","date":"2022-04-17T13:50:37.000Z","updated":"2022-05-01T14:24:02.158Z","comments":true,"path":"348283507.html","link":"","permalink":"https://shymuel.top/348283507.html","excerpt":"","text":"1 C++中的注释 单行注释： 1// 这是单行注释 多行注释： 12345/** 这是多行注释的第一行* 这是多行注释的第二行* &quot;*&quot;不是必须的，但加上会显得整齐些*/ 条件注释： 1234// 0为条件参数#if 0 code#endif 为代码撰写注释： 123456789101112131415161718/** 写在代码开头* 代码功能、版权、作者、编写日期等*/// 写在代码块前面的注释：内容为大段的解释信息/// 当使用visual的时候，可以在函数上方直接打三个斜杠，然后就会获得……/// &lt;summary&gt;/// 求a和b的和/// &lt;/summary&gt;/// &lt;param name=&quot;a&quot;&gt;被加数&lt;/param&gt;/// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;int sum(int a, int b) &#123; return a + b;&#125; 但是肉眼可见的，上面的注释风格实在是太丑了，这能忍？好消息是Visual Studio 2019给我们提供了注释风格的选项，路径为【工具 / 选项 / 文本编辑器 / C/C++ / 代码样式 / 常规】，在这里面可以选择注释风格，理论上来说\"///\"是最快捷的，但我还是觉得难看，选择了\"/**\"的注释风格： 123456789/** * @brief 求和 * @param a * @param b * @return */int sum(int a, int b) &#123; return a + b;&#125; 快速将一部分代码注释掉：选中代码，ctrl+k，ctrl+c，或者ctrl+k+c三个键一起按。 取消注释：选中代码，ctrl+k，ctrl+u，或者ctrl+k+u三个键一起按。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"https://shymuel.top/tags/C/"}]},{"title":"《うっせぇわ》歌词（中日语+假名对照版）","slug":"《烦死了》歌词","date":"2022-01-10T07:32:17.000Z","updated":"2022-01-10T09:05:07.097Z","comments":true,"path":"899839865.html","link":"","permalink":"https://shymuel.top/899839865.html","excerpt":"","text":"本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。 ただしさとは、おろかさとは 正 しさとは、愚 かさとは 什么叫正确？什么叫愚蠢？ それがなにかみせつけてやる それが何 か見せつけてやる 现在就让你们见识一下吧！ ちっちゃなころからゆうとうせい ちっちゃな頃 から優 等 生 从小便是优等生 きづいたらおとなになっていた 気づいたら大 人になっていた 回过神来便已成为了大人 ナイフのようなしこうかいろ ナイフの様 な思考 回 路 充满了刀锋般的思考方式 もちあわせるわけもなく 持ち合わせる訳 もなく 但也没必要和你一起比较吧 でもあそびたりない、なにかたりない でも遊 び足りない、何 か足りない 但是玩不够啊，还不够快乐啊 こまっちまうこれはだれかのせい 困 っちまうこれは誰 かのせい 左右为难又是谁的错啊 あてもなくただこんらんするエイデイ あてもなくただ混 乱 するエイデイ 也不过只是没有目的的日程渐渐变得混乱 それもそっか 那也是当然嘛 さいしんのりゅうこうはとうぜのはあく 最 新 の流 行 は当 然 の把握 最流行的东西，第一时间掌握 きゅうざいのどうこうはつうきんじチェック 経 済 の動 向 は通 勤 時チェック 经济的流向上班前查看 じゅんじょうなせいしんでにゅうしゃしワーク 純 情 な精 神 で入 社 しワーク 抱有热情的进公司工作 しゃかいじんじゃとうぜんのルールです 社 会 人 じゃ当 然 のルールです 这可是社会人的规则啊 はぁ？うっせぇうっせぇうっせぇわ 哈？啰嗦！烦人！吵死了！ あなたがおもうよりけんこうです あなたが思 うより健 康 です 我可比你想的要健康得多 いっさいがっさいぼんような 一 切 合 切 凡 庸 な 一切一切都平凡的你 あなたじゃわからないかもね あなたじゃ分からないかもね 你可能不明白吧 ああよくにあう 嗚呼よく似合う 啊，和你可真是般配啊 そのかもなくふかもないメロディー その可もなく不可もないメロディー 这没有存在必要的旋律 うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ あたまのできがちがうのでもんだいはナシ 頭 の出来が違 うので問 題 はナシ 我们头脑构造不一样，所以没什么问题！ つってもわたしもはんにんげん つっても私 模範 人 間 就算这样我也可是人之模范啊 なぐったりするのはノーセンキュー 殴 ったりするのはノーセンキュー 教训你一顿这种事也是不用谢我 だったらことばのじゅうこうを だったら言 葉の銃 口 を 既然这样就将枪口（话语） そのあたまにつきつけてうてば その頭 に突きつけて撃てば 对准脑门一通扫射吧！ マジヤバない？とまれやしない マジヤバない？止まれやしない 这样下去很糟糕吧？不试试放弃吗？ ふへいふまんだれてなれのはて 不平 不満 誰 て成れの果て 怨天尤人可不会有好下场的 サディスティックにへんぼうするせいしん サディスティックに変 貌 する精 神 变得施虐者一般的思想 クソだりぃな 真是渣滓 さけがあいたグラスあればすぐにつぎなさい 酒 が空いたグラスあれば直ぐに注ぎなさい 酒杯空了就立马装满 みんながつまみやすいようにくしがいしなさい 皆 がつまみ易い ように串 外 しなさい 为了大家吃东西更方便给我把菜从串上取下来 かいけいやちゅうもんはせんじんをきる 会 計 や注 文 は先 陣 を切る 结账和点菜搞快点 ふぶんりつさいていげんのマナーです 不文 律 最 低 限 のマナーです 这是最低限度的不成文规定吧 はぁ？うっせぇうっせぇうっせぇわ 哈？啰嗦！烦人！吵死了！ くせぇくちふさげやげんかいです くせぇ口 塞 げや限 界 です 也该闭上你这张臭嘴了吧我受够了 ぜったいぜったいげんだいのだいべんしゃはわたしやろがい 絶 対 絶 対 現 代 の代 弁 者 は私 やろがい 现代人的榜样绝对就是我了吧 もうみあきたわ もう見飽きたわ 已经见多了啊 にばんせんじいいかえのパロディ 二番 煎 じ言い換えのパロディ 换汤不换药只是换了个说法的模仿 うっせぇうっせぇうっせぇわ 啰嗦！吵死了！烦死了 まるまるとにくついたそのがんめんにバツ 丸 々 と肉 付いたその顔 面 にバツ 恨不得赏你这肥猪一拳 うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ わたしがぞくにいうてんさいです 私 が俗 に言う天 才 です 我可是你们所说的天才！ うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ あなたがおもうよりけんこうです あなたが思 うより健 康 です 我可比你想的要健康得多！ いっさいがっさいぼんような 一 切 合 切 凡 庸 な 一切一切都平凡的你 あなたじゃわからないかもね あなたじゃ分からないかもね 可能不明白吧 ああつまらねぇ 嗚呼つまらねぇ 啊，真无趣啊 なんかいきかせるんだそのメモリー 何 回 聞かせるんだそのメモリー 这样的回忆已经听了多少遍啊 うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ アタシもたいがい だけど アタシも大 概 だけど 我或许也差不多... どうだっていいぜもんだいはナシ どうだっていいぜ問 題 はナシ 不！怎么都好，我没有问题！","categories":[{"name":"日语学习","slug":"日语学习","permalink":"https://shymuel.top/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://shymuel.top/tags/%E6%97%A5%E8%AF%AD/"},{"name":"日文歌","slug":"日文歌","permalink":"https://shymuel.top/tags/%E6%97%A5%E6%96%87%E6%AD%8C/"}]},{"title":"Latex语法记录","slug":"Latex语法记录","date":"2021-12-15T02:30:35.000Z","updated":"2022-05-01T14:27:24.424Z","comments":true,"path":"2021361885.html","link":"","permalink":"https://shymuel.top/2021361885.html","excerpt":"","text":"Overleaf的LaTex教程 包含基本上所有Latex小语法的网站 在线Latex公式编辑器（界面比第二个网站更好看） 给字母加奇怪的东西 \\pmb{}，字母加粗 Text1\\pmb&#123;x&#125;, \\ \\pmb&#123;X&#125; \\(\\pmb{x}, \\ \\pmb{X}\\) \\hat{}，头顶加小尖角 Text1\\hat&#123;\\gamma&#125;_&#123;j k&#125;=\\frac&#123;\\alpha_&#123;k&#125; \\phi\\left(y_&#123;j&#125; \\mid \\theta_&#123;k&#125;\\right)&#125;&#123;\\sum_&#123;k=1&#125;^&#123;R&#125; \\alpha_&#123;k&#125; \\phi\\left(y_&#123;j&#125; \\mid \\theta_&#123;k&#125;\\right)&#125; \\(\\hat{\\gamma}_{j k}=\\frac{\\alpha_{k} \\phi\\left(y_{j} \\mid \\theta_{k}\\right)}{\\sum_{k=1}^{R} \\alpha_{k} \\phi\\left(y_{j} \\mid \\theta_{k}\\right)}\\) 各种括号和方框 \\begin{cases}，多种情况的表示 Text1\\gamma_&#123;j k&#125;= \\begin&#123;cases&#125;1, &amp; \\text &#123; 第 &#125; j \\text &#123; 个观测来自第 &#125; k \\text &#123; 个分模型 &#125; \\\\ 0, &amp; \\text &#123; 否则 &#125;\\end&#123;cases&#125; \\(\\gamma_{j k}= \\begin{cases}1, &amp; \\text { 第 } j \\text { 个观测来自第 } k \\text { 个分模型 } \\\\ 0, &amp; \\text { 否则 }\\end{cases}\\) \\begin{array}，方程组 Text1\\left\\&#123;\\begin&#123;array&#125;&#123;l&#125;\\mathrm&#123;e&#125;^&#123;-x_&#123;1&#125;&#125;+\\mathrm&#123;e&#125;^&#123;-2 x_&#123;2&#125;&#125;+x_&#123;3&#125;-2 x_&#123;4&#125;+t_&#123;k&#125; x_&#123;5&#125;-5.3=0 \\\\ \\mathrm&#123;e&#125;^&#123;-2 x_&#123;1&#125;&#125;+\\mathrm&#123;e&#125;^&#123;-x_&#123;2&#125;&#125;-2 x_&#123;3&#125;+t_&#123;k&#125; x_&#123;4&#125;-x_&#123;5&#125;+25.6=0 \\\\ t_&#123;k&#125; x_&#123;1&#125;+3 x_&#123;2&#125;+\\mathrm&#123;e&#125;^&#123;-x_&#123;3&#125;&#125;-3 x_&#123;5&#125;+37.8=0 \\\\ 2 x_&#123;1&#125;+t_&#123;k&#125; x_&#123;2&#125;+x_&#123;3&#125;-\\mathrm&#123;e&#125;^&#123;-x_&#123;4&#125;&#125;+2 \\mathrm&#123;e&#125;^&#123;-2 x_&#123;5&#125;&#125;-31.3=0 \\\\ x_&#123;1&#125;-2 x_&#123;2&#125;-3 t_&#123;k&#125; x_&#123;3&#125;+\\mathrm&#123;e&#125;^&#123;-2 x_&#123;4&#125;&#125;+3 \\mathrm&#123;e&#125;^&#123;-x_&#123;5&#125;&#125;+42.1=0\\end&#123;array&#125;\\right. \\(\\left\\{\\begin{array}{l}\\mathrm{e}^{-x_{1}}+\\mathrm{e}^{-2 x_{2}}+x_{3}-2 x_{4}+t_{k} x_{5}-5.3=0 \\\\ \\mathrm{e}^{-2 x_{1}}+\\mathrm{e}^{-x_{2}}-2 x_{3}+t_{k} x_{4}-x_{5}+25.6=0 \\\\ t_{k} x_{1}+3 x_{2}+\\mathrm{e}^{-x_{3}}-3 x_{5}+37.8=0 \\\\ 2 x_{1}+t_{k} x_{2}+x_{3}-\\mathrm{e}^{-x_{4}}+2 \\mathrm{e}^{-2 x_{5}}-31.3=0 \\\\ x_{1}-2 x_{2}-3 t_{k} x_{3}+\\mathrm{e}^{-2 x_{4}}+3 \\mathrm{e}^{-x_{5}}+42.1=0\\end{array}\\right.\\) 既可以用来表示矩阵，也可以用来表示方程…… 数学表达式 根式 Text1\\sqrt[]&#123;&#125; \\(\\sqrt[n]{x+1}\\) 集合相关 Text12345$\\exists$$\\forall$$\\neg$$\\wedge$$\\vee$ \\(\\exists,\\ \\forall, \\ \\neg, \\ \\wedge,\\ \\vee\\) LaTex中的数学字体 有些字体需要在序言中引入特定的包：\\usepackage&#123;amssymb&#125; 有些字体支持一部分字符： Text123456\\begin&#123;align*&#125;RQSZ \\\\\\mathcal&#123;RQSZ&#125; \\\\\\mathfrak&#123;RQSZ&#125; \\\\\\mathbb&#123;RQSZ&#125;\\end&#123;align*&#125; \\(\\begin{align*} RQSZ \\\\ \\mathcal{RQSZ} \\\\ \\mathfrak{RQSZ} \\\\ \\mathbb{RQSZ} \\end{align*}\\) 手写体，哥特黑体，黑板粗体。 也可以将整个数学表达式的字体更换为另外一种： Text12345678\\begin&#123;align*&#125;3x^2 \\in R \\subset Q \\\\\\mathrm&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathit&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathbf&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathsf&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathtt&#123;3x^2 \\in R \\subset Q&#125; \\end&#123;align*&#125; \\(\\begin{align*}3x^2 \\in R \\subset Q \\\\ \\mathrm{3x^2 \\in R \\subset Q} \\\\ \\mathit{3x^2 \\in R \\subset Q} \\\\ \\mathbf{3x^2 \\in R \\subset Q} \\\\ \\mathsf{3x^2 \\in R \\subset Q} \\\\ \\mathtt{3x^2 \\in R \\subset Q} \\end{align*}\\) \\mathnormal&#123;3x^2 \\in R \\subset Q&#125;理论上这也是一种字体，和默认字体一样的，但是hexo的渲染器会报错，就没有放上去了。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"论文编辑","slug":"论文编辑","permalink":"https://shymuel.top/tags/%E8%AE%BA%E6%96%87%E7%BC%96%E8%BE%91/"}]},{"title":"好用软件及网站分享","slug":"好用软件及网站分享","date":"2021-12-15T02:26:20.000Z","updated":"2022-05-01T14:23:47.845Z","comments":true,"path":"2675119176.html","link":"","permalink":"https://shymuel.top/2675119176.html","excerpt":"","text":"文档编辑 WPS，一直开会员，云文档功能yyds。 笔记软件 为知笔记。旧版和X版我都在用，笑死，已经变成为知笔记的形状了，一年60块买不了吃亏买不了上当。我现在写博客都是在为知笔记写完然后导出成Markdown。 论文阅读 单纯看PDF的话WPS也能满足需求，但WPS是不提供文献管理功能的，批注功能也弱了点。今天发现一个叫IvySci的软件，中文名青藤学术，竟然还是个国产软件……well，再用一段时间再来评价，目前用免费版，收费版也不贵，但收费之后的空间确实小了点，看得出小公司没那么有钱……目前最吸引我的功能是软件内用各种引擎查论文，以及一键把论文中的引用文献加入项目。但它现在有个问题是 论文搜索 之前一直用学校的网在SCI上查，最近觉得还是谷歌学术牛牛。但是懒得开科学上网的话，谷粉学术挺好用的，也可以去用镜像。 公式生成 Mathpix Snipping Tool，截图生成公式，中文也能识别。我自己用的时候哪怕是扫描版的书，基本上也能把公式识别出来。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"学习和工作","slug":"学习和工作","permalink":"https://shymuel.top/tags/%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%B7%A5%E4%BD%9C/"}]},{"title":"强化学习笔记（1） 强化学习概述","slug":"强化学习笔记（一）","date":"2021-09-03T13:37:20.000Z","updated":"2022-02-27T03:36:36.064Z","comments":true,"path":"4072327491.html","link":"","permalink":"https://shymuel.top/4072327491.html","excerpt":"","text":"本系列文章为笔者学习网络上的强化学习教程之后的笔记，在原文和自己理解的基础上重新写作而成，基本可以认为是原文的精简版，后续可能会在阅读其他教材之后在对应章节添加例子等。原教程地址 1.1 强化学习 强化学习解决的是一个智能体如何在一个复杂不确定的环境里极大化它能获得的奖励。 在环境 (environment) 中，智能体 (agent) 进行各种动作( action) 产生某种状态 (state)，据此环境给出奖励 (reward)。这里的奖励是延迟奖励，即行为的进行到奖励的求得之间往往又隔了一些动作。 强化学习的一些特征：有试错探索 (trial-and-error exploration)，探索环境来获取对环境的理解；从环境中得到延迟的奖励；每个动作在时间上是连续的；agent 的行为会影响之后的数据。 举一个雅达利 pong 游戏的例子：一块板子往上或者往下，把弹球弹到对面。整个游戏过程是预演 (rollout) 的，即从当前帧可以生成很多局游戏。agent 和环境交互会产生很多观测，每个观测是一个轨迹 (trajectory)。轨迹是当前帧以及他采取的策略，即状态和动作的一个序列：\\(\\tau =(s_0,a_0,s_1,a_1, \\dots)\\)。 一场游戏叫做一个回合 (episode) 或者试验 (trial)。 最近把强化学习和深度学习结合起来，成为深度强化学习。 1.2 序列决策过程 序列决策 (sequential decision making) 过程可以说是一般的单智能体 RL 的通用过程。 奖励是由环境给的一个标量的反馈信号 (scalar feedback signal)，这个信号显示了智能体在某一步采取某个策略的表现如何。强化学习训练的目的就是为了最大化智能体可以获得的奖励，智能体行动的目的就是为了极大化它的期望的累积奖励 (expected cumulative reward)。同时要进行近期奖励和远期奖励的一个平衡，最终一般希望获得更多的长期奖励。 历史是观测、行为、奖励的序列： \\(H_t =\\{O_1, R_1, A_1,\\dots, A_{t-1},\\dots\\}\\) agent 在采取动作的时候依赖于它的历史，可以把整个游戏的状态看成这个历史的函数：\\(S_t=f(H_t)\\)。 状态\\(S\\)是对世界的完整描述，deep RL 中一般用实值的向量、矩阵或张量来表示状态和观测。 agent 的状态和环境的状态等价说明环境完全可观测。这种问题称为 MDP 问题。在这个问题中，\\(O_t=S^e_t=S^a_t\\)。 否则就是部分可观测的。称为 POMDP，即部分可观测马尔科夫决策过程。POMDP 是一个马尔科夫决策过程的泛化，具有马尔科夫性质，但假设智能体无法感知环境的状态\\(S\\)，只知道部分观测值\\(O\\)。 用一个七元组描述马尔科夫过程：\\((S, A, T, R, Ω, O, γ)\\)。\\(S\\)是状态空间，隐变量；\\(A\\)是动作空间，\\(T\\)是状态转移概率，\\(R\\)是奖励函数；\\(Ω\\)是观测概率，\\(O\\)为观测空间，\\(\\gamma\\)为折扣系数。 1.3 动作空间 不同环境中可以进行的动作是不同的。在给定环境中，有效动作的集合被称为动作空间。离散动作空间中动作数量有限；连续动作空间中动作种类无限，此时动作是实值的向量。 1.4 强化学习智能体的组成和类型 策略函数 (policy function)：用这个函数来选取下一步的动作； 价值函数 (value function)：对当前状态估价； 模型 (model)：表示 agent 对这个环境的状态进行的理解，这一点决定训练如何进行。 1.4.1 策略 策略一般有两种：随机性策略 (stochastic policy) 和确定性策略 (deterministic policy)。 随机性策略中，每个行为的发生是有概率的，要进行采样然后再动作，也就是说概率再小的动作也可能被执行。而确定性策略则只采用最有可能的概率，即\\(a^*=\\arg \\max_a \\pi(a\\mid s)\\)。随机性策略：输入一个状态s，输出是一个概率。进一步对概率进行采样，可以得到一个action。 对于 Atari 游戏，策略函数的输入就是游戏的一帧，他的输出决定往左或者往右。通常采用随机性策略，因为其动作具有多样性。 1.4.2 价值函数 价值函数是对未来奖励的一个预测，用来评估状态的好坏。 价值函数里有一个折扣因子 (discount factor)。我们希望在尽可能短的时间里得到尽可能多的奖励。价值函数的定义其实是一个期望： \\(v_{\\pi}(s) \\doteq \\mathbb{E}_{\\pi}\\left[G_{t} \\mid S_{t}=s\\right]=\\mathbb{E}_{\\pi}\\left[\\sum_{k=0}^{\\infty} \\gamma^{k} R_{t+k+1} \\mid S_{t}=s\\right],\\ \\text{for all}\\ s \\in \\mathcal{S}\\) 上面的公式表明已知某一个策略函数的时候，到底可以得到多少奖励。 还有一种价值函数叫 Q 函数，包含两个变量状态和动作： \\(q_{\\pi}(s, a) \\doteq \\mathbb{E}_{\\pi}\\left[G_{t} \\mid S_{t}=s, A_{t}=a\\right]=\\mathbb{E}_{\\pi}\\left[\\sum_{k=0}^{\\infty} \\gamma^{k} R_{t+k+1} \\mid S_{t}=s, A_{t}=a\\right]\\) Q 函数表明，奖励的期望取决于当前的状态和智能体的行为。 这两种价值函数在之后都会有详细解释和应用。 1.4.3 模型 模型决定了下一个状态会是什么样的。它由两个部分组成： 概率，指状态之间如何转移；奖励函数，指在当前状态进行了某个行为后可以得到多大的奖励。 有了上述三个部分之后就得到了一个马尔科夫决策过程。 1.4.4 强化学习智能体的类型 1.4.4.1 基于价值的智能体与基于策略的智能体 基于价值的智能体 (value-based agent)：显式学习价值函数，隐式学习策略。 基于策略的智能体 (policy-based agent)：直接学习策略，没有学习价值函数。 二者结合得到演员-评论员智能体 (actor-critic agent)，策略函数和价值函数都学习，然后通过两者交互得到一个最佳行为。 基于策略迭代和基于价值迭代的强化学习方法有什么区别？ 对一个状态转移概率已知的马尔科夫决策过程，可以用动态规划算法求解。决策方式来看，可以分为基于策略迭代的方法和基于价值迭代的方法。决策方式是静态的，不随状态变化而变化。 基于策略迭代的强化学习中，智能体会制定一套动作策略以确定给定状态下采取何种动作，并根据这个策略操作。有策略梯度算法等。基于价值迭代的方法则维护一个价值表格或函数。只能应用在不连续、离散的环境下。基于价值迭代的有 Q-learning，Sarsa等。演员-评论员算法同时使用策略和价值评估来做出决策，智能体根据策略做出动作，而价值函数会对做出的动作给出价值，这样可以在原有的策略梯度算法的基础上加速学习过程，取得更好的效果。 1.4.4.2 有模型强化学习智能体与免模型强化学习智能体 针对是否需要对真实环境建模，强化学习可以分为有模型学习和免模型学习。有模型学习是指根据环境中的经验，构建一个虚拟世界，同时在真实环境和虚拟世界中学习；免模型学习是指不对环境进行建模，直接与真实环境进行交互来学习到最优策略。 有模型 (model-based) 强化学习智能体通过学习状态的转移来采取动作。免模型 (model-free) 强化学习智能体没有直接估计这个状态的转移，也没有得到环境的具体转移变量，通过学习价值函数和策略函数进行决策。免模型的模型里面没有一个环境转移的模型。 免模型学习通常属于数据驱动型方法，需要大量的采样来估计状态、动作及奖励函数，从而优化动作策略。 1.5 学习与规划 学习 (learning) 和规划 (planning) 是序列决策的两个基本问题。 简单来说，强化学习面对环境的未知部分要进行学习，对于环境的已知部分要进行规划。 1.6 探索和利用 探索是指怎么探索环境，即找到能获得最大奖励的策略。利用是指不尝试新的东西，仅靠已知的信息就可以得到很大奖励的行为。 与监督学习不同，强化学习任务的最终奖赏是在多步动作之后才能观察到，这里不妨先考虑比较简单的情形：最大化单步奖赏，即仅考虑一步操作。需注意的是，即便在这样的简化情形下，强化学习仍与监督学习有显著不同，因为机器需通过尝试来发现各个动作产生的结果，而没有训练数据告诉机器应当做哪个动作。 单步强化学习对应了 K-臂赌博机 (K-armed bandit) 的模型。赌徒投入一个硬币后可选择按下一个摇臂，每个摇臂以一定的概率吐出金币，但这个概率赌徒不知道。赌徒的目标是通过一定的策略最大化自己的奖赏。 若想获知每个摇臂的期望奖赏，则可采用仅探索法，将所有机会平均分配给每个摇臂，然后计算期望。 如果只想执行奖赏最大的动作，则可采用仅利用法，按下目前最优的摇臂。若有多个最优则随机选一个。 显然，在探索和利用之间，必须要达成一个较好的折中。 1.7 强化学习实验 cuhkrlcourse的RL代码； OpenAI 的 Gym 是一个很强的环境仿真库。离散控制场景（输出的动作是可数的，比如 Pong 游戏中输出的向上或向下动作）一般使用雅达利环境评估；连续控制场景（输出的动作是不可数的，比如机器人走路时不仅有方向，还要角度，角度就是不可数的，是一个连续的量）一般使用 mujoco 环境评估。Gym Retro 是对 Gym 环境的进一步扩展，包含了更多的一些游戏。 简书上的 Gym 环境总结。 Gym 的官方文档。 1.7.1 第一次使用 Gym text1pip install gym # 安装 Gym 12345678import gymenv = gym.make(&quot;Taxi-v3&quot;) # 出租车接乘客的游戏observation = env.reset()for step in range(100): action = env.action_space.sample() # 随机动作 observation, reward, done, info = env.step(action) print(observation) 1.7.2 CartPole 例子 CartPole 要求通过控制一个平板让木棍立起来。输入是向左或向右的一个力，\\(\\pm1\\)。失败条件是木棍角度过大或平板离轨道中心太远。 123456789import gym # 导入 Gym 的 Python 接口环境包env = gym.make(&#x27;CartPole-v0&#x27;) # 构建实验环境env.reset() # 重置一个 episodefor _ in range(1000): env.render() # 显示图形界面 action = env.action_space.sample() # 从动作空间中随机选取一个动作 env.step(action) # 用于提交动作，括号内是具体的动作env.close() # 关闭环境 执行这段代码时，机器人会无视该立起来的杆子，驾驶着小车朝某个方向一通跑，直到不见踪影，这是因为动作是随机选取的。打印 env.action_space.sample() 的返回值，会发现值是 0 或 1，一左一右。env.step() 一方面是执行动作，另一方面还有四个返回值，分别是 observation、reward、done、info。 observation 是状态信息，指游戏中观测到的屏幕像素值或者盘面状态描述信息。reward 是奖励值，即 action 提交以后能够获得的奖励值。这个奖励值因游戏的不同而不同，但总体原则是对完成游戏有帮助的动作会获得比较高的奖励值。done 表示游戏是否已经完成。如果完成了，就需要重置游戏并开始一个新的回合。info 是一些比较原始的用于诊断和调试的信息，或许对训练有帮助。不过 OpenAI 团队在评价用户提交的机器人时不允许使用这些信息。 玩游戏的时候可以输出一下 observation 观察游戏的状态是怎么定义的。env.step() 完成了一个完整的\\(S\\rightarrow A\\rightarrow R\\rightarrow S^′\\)过程。我们只要不断观测这样的过程，并让机器在其中用相应的算法完成训练，就能得到一个高质量的强化学习模型。 想要查看当前 Gym 库已经注册了哪些环境，可以使用以下代码： 1234from gym import envsenv_specs = envs.registry.all()envs_ids = [env_spec.id for env_spec in env_specs]print(envs_ids) 每个环境都定义了自己的观测空间和动作空间。环境 env 的观测空间用 env.observation_space 表示，动作空间用 env.action_space 表示。观测空间和动作空间既可以是离散空间，也可以是连续空间。在 Gym 库中，离散空间一般用 gym.spaces.Discrete 类表示，连续空间用 gym.spaces.Box 类表示。 1.7.3 MountainCar-v0 例子 小车上山例子。小车要跑到右边的山顶上碰到旗子，但小车的马力不够强。唯一的办法是让小车在两个坡上来回移动，借助从左边山上冲下来的速度冲上右边的山顶。 1.7.3.1 输出游戏的信息 1234567import gymenv = gym.make(&#x27;MountainCar-v0&#x27;)print(&#x27;观测空间 = &#123;&#125;&#x27;. format(env.observation_space))print(&#x27;动作空间 = &#123;&#125;&#x27;. format(env.action_space))print(&#x27;观测范围 = &#123;&#125; ~ &#123;&#125;&#x27;. format(env.observation_space.low,env.observation_space.high))print(&#x27;动作数 = &#123;&#125;&#x27;. format(env.action_space.n)) 由输出可知，观测空间是形状为 (2,) 的浮点型 np.array，动作空间是取 0,1,2 的 int 型数值。 1.7.3.2 实现一个智能体类 12345678910111213141516171819class BespokeAgent: def __init__(self, env): pass def decide(self, observation): # 决策 position, velocity = observation lb = min(-0.09 * (position + 0.25) ** 2 + 0.03, 0.3 * (position + 0.9) ** 4 - 0.008) ub = -0.07 * (position + 0.38) ** 2 + 0.07 if lb &lt; velocity &lt; ub: action = 2 else: action = 0 return action # 返回动作 def learn(self, *args): # 学习 passagent = BespokeAgent(env) 智能体的 decide() 方法实现了决策功能，而 learn() 方法实现了学习功能。BespokeAgent 类是一个比较简单的类，它只能根据给定的数学表达式进行决策，不能有效学习，只是用来演示。 1.7.3.3 智能体与环境交互 12345678910111213141516def play_montecarlo(env, agent, render=False, train=False): episode_reward = 0. # 记录回合总奖励，初始化为0 observation = env.reset() # 重置游戏环境，开始新回合 while True: # 不断循环，直到回合结束 if render: # 判断是否显示 env.render() # 显示图形界面，图形界面可以用 env.close() 语句关闭 action = agent.decide(observation) next_observation, reward, done, _ = env.step(action) # 执行动作 episode_reward += reward # 收集回合奖励 if train: # 判断是否训练智能体 agent.learn(observation, action, reward, done) # 学习 if done: # 回合结束，跳出循环 break observation = next_observation return episode_reward # 返回回合总奖励 play_montecarlo 函数可以让智能体和环境交互一个回合。这个函数有 4 个参数。env 是环境类，agent 是智能体类，render 是 bool 类型变量，指示在运行过程中是否要图形化显示。 如果函数参数 render 为 True，那么在交互过程中会调用 env.render() 以显示图形化界面，而这个界面可以通过调用 env.close() 关闭。train 是 bool 类型的变量，指示在运行过程中是否训练智能体。在训练过程中应当设置为 True 以调用 agent.learn() 函数；在测试过程中应当设置为 False，使得智能体不变。这个函数有一个返回值 episode_reward，是 float 类型的数值，表示智能体与环境交互一个回合的回合总奖励。 1.7.3.4 智能体与环境交互并显示 1234env.seed(0) # 设置随机数种子,只是为了让结果可以精确复现,一般情况下可删去episode_reward = play_montecarlo(env, agent, render=True)print(&#x27;回合奖励 = &#123;&#125;&#x27;. format(episode_reward))env.close() # 此语句可关闭图形界面 为了系统评估智能体的性能，下列代码求出了连续交互 100 回合的平均回合奖励。 1234import numpy as npepisode_rewards = [play_montecarlo(env, agent) for _ in range(100)]print(&#x27;平均回合奖励 = &#123;&#125;&#x27;. format(np.mean(episode_rewards))) 小车上山环境有一个参考的回合奖励值 -110，如果连续 100 个回合的平均回合奖励大于 -110，则认为这个任务被解决了。espokeAgent 类对应的策略的平均回合奖励大概就在 -105 左右。 测试智能体在 Gym 库中某个任务的性能时学术界一般最关心 100 个回合的平均回合奖励，选这个数字完全是习惯使然。对于有些环境会指定一个参考的回合奖励值，当连续 100 个回合的奖励大于指定的值时，就认为这个任务被解决了。但并不是所有的任务都指定了这样的值。 总结一下 Gym 的用法：使用 env=gym.make(环境名) 取出环境，使用 env.reset() 初始化环境，使用 env.step(动作) 执行一步环境，使用 env.render() 显示环境，使用 env.close() 关闭环境。 1.8 关键词 强化学习 (reinforcement learning, RL)：智能体与复杂且不确定的环境进行交互时，尝试使所获得的奖励最大化的计算算法。 动作 (action)：环境接收到的智能体当前状态的输出。 状态 (state)：智能体从环境中获取到的状态。 奖励 (reward)：智能体从环境中获取的反馈信号，这个信号代表智能体在某一步采取某个策略以后是否得到奖励以及奖励的大小。 探索 (exploration)：在当前的情况下，继续尝试新的动作。智能体有可能会得到更高的奖励，也有可能一无所获。 规划 (planning)：在当前的情况下，使用已知的可以获得最大奖励的动作。 深度强化学习 (deep reinforcement learning)：不需要手工设计特征，仅需要输入状态让系统直接输出动作的一个端到端 (end-to-end) 的强化学习方法。通常使用神经网络来拟合价值函数 (value function) 或者策略网络 (policy network)。 全部可观测 (full observability)、完全可观测 (fully observed) 和部分可观测 (partially observed)：当智能体的状态与环境的状态等价时，称环境是全部可观测的；当智能体能够观察到环境的所有状态时，称环境是完全可观测的。智能体不能观察到环境的所有状态时，称环境是部分可观测的。 部分可观测马尔可夫决策过程 (partially observable Markov decision process, POMDP)：即马尔可夫决策过程的泛化。部分可观测马尔可夫决策过程依然具有马尔可夫性质，但是其假设智能体无法感知环境的状态，只能知道部分观测值。 动作空间 (action space)、离散动作空间 (discrete action space)、连续动作空间 (continuous action space)：在给定的环境中，有效动作的集合被称为动作空间，智能体的动作数量是有限的动作空间为离散动作空间，反之，则被称为连续动作空间。 基于策略的 (policy-based)：智能体会制定一套动作策略，即确定在给定状态下需要采取何种动作，并根据这个策略进行操作。强化学习算法直接对策略进行优化，使制定的策略能够获得最大的奖励。 基于价值的 (valued-based)：智能体不需要制定显式的策略，它维护一个价值表格或者价值函数，并通过这个价值表格或价值函数来选取价值最大的动作。 有模型结构 (model-based)：智能体通过学习状态的转移来采取措施。 免模型结构 (model-free)：智能体没有直接估计状态的转移，也没有得到环境的具体转移变量。它通过学习价值函数 (value function) 或者策略网络 (policy network) 进行决策。","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"算法学习","slug":"算法学习","permalink":"https://shymuel.top/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}]},{"title":"HEXO建站（二）","slug":"HEXO建站（二）","date":"2021-08-29T08:32:00.000Z","updated":"2022-05-01T14:26:51.961Z","comments":true,"path":"200109796.html","link":"","permalink":"https://shymuel.top/200109796.html","excerpt":"","text":"将网站迁移到新电脑 安装nodejs和git for windows，npm中安装hexo：npm install -g hexo-cli。之后把博客文件夹从旧电脑复制过来即可。 为了上传，还要配置一下新电脑和github仓库之间的联系。这里还是放一个比较好的教程。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://shymuel.top/tags/HEXO/"},{"name":"个人网站","slug":"个人网站","permalink":"https://shymuel.top/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}]},{"title":"WPS使用技巧记录","slug":"WPS使用","date":"2021-08-14T10:43:49.000Z","updated":"2022-05-01T14:28:21.834Z","comments":true,"path":"3253309366.html","link":"","permalink":"https://shymuel.top/3253309366.html","excerpt":"","text":"公式中插入超过\\(3*3\\)的矩阵 ​ 恕我直言，WPS最新版这个公式属实邪门。用起来没有更方便，甚至都不能自己手动把界面下拉让用户能看到更多的选项…… ​ 今天遇到的问题是WPS自带的公式功能最大插入\\(3*3\\)矩阵，但我需要用到\\(1*7\\)的矩阵。方法是首先插入一个\\(1*3\\)​​的矩阵，然后选中整个矩阵（不包括括号），然后右键——插入——在此前插入列（或者在此后插入列），这样就可以突破原本的\\(3*3\\)的限制了……","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}]},{"title":"游戏王《Overlap》歌词（中日语+假名对照版）","slug":"游戏王-Overlap","date":"2021-08-03T07:52:32.000Z","updated":"2022-01-10T08:11:07.750Z","comments":true,"path":"abac2baf.html","link":"","permalink":"https://shymuel.top/abac2baf.html","excerpt":"","text":"本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。 かくせないほどまばゆいひかり せいじゃくやぶりこのよによみがえる 隠 せないほど眩 い光 静 寂 破 りこの世に甦 る 难以隐藏的炫目光芒 划破沉寂 在这世上苏醒 はげしいくゆらぐかわいただいち いのちをかけてひばなぶすけあう はげしいく揺らぐ渇 いた大 地 命 をかけて火花 ぶすけ合う 与剧烈震荡的干涸大地 不惜生命般摩擦出火花 もういちどだけでいい きせきおきてよ もう一 度だけでいい 奇跡 起きてよ 再一次就好 发生奇迹吧 かこになくしたきおくのページをとりもどすちからを 過去になくした記憶 のページを取り戻どすpower を 请给我能夺回过往失去的记忆书页的力量 やみをつらぬくしんじるこころたましいねむるばしょさがして 闇 を贯 ぬく信 じる心 魂 眠る 場所 探がして 坚信能冲破黑暗的心 寻找灵魂长眠之处 まばたきできない するどいがんこうをもやす 瞬 きできない 鋭 い眼 光 を燃やす 眼中燃起让人难以眨眼的锐利光芒 ひかりとかげのふたつのこころ くりすたるにうつるみらいへ 光 と影 の二 つの心 クリスタルに映 る未来 へ 光与暗的两颗心 一同前往水晶中映照的未来 いまうごきだす あかくみなぎるEYES 今 動き 出す 紅 く漲 るEYES 此刻开始行动 那涨红的双眼 たがいのきずをなめあうひびに おわりをつげて しずかにたちあがる 互 いの傷 を舐め合う日々に 终わりを告 て 静 かに立ち上がる 对互相舔舐伤口的时光 宣告终结 静静站起身来 ちいさなあかりともしたよるの きみとかわしたやくそくまもりぬく 小 さな明かり灯した 夜 の 君 と交 した約 束 守 り抜く 那微灯映照之夜 与你结下的约定 我会坚守到底 かすむしんきろうがきみをみせるよ 霞 む蜃 気楼 が君 を见せるよ 模糊的幻象之中 看见了你的身影 すすんださきになにがおきてもまけわしないかくごで 進 んだ先 に何 が掟 も負けわしない覚 悟で 无论前路上发生什么 我都会有绝不认输的觉悟 きせきはおこるしんじるこころ むかえにきたしょうりのめがみが 奇跡 は起こる信 じる心 迎 えに来た勝 利の女神 が 坚信能引发奇迹的心 胜利女神将迎接它的到来 すべてをたおすどんなかべにもひるまない 全 てを倒 すどんな壁 にも怯 まない 打倒一切敌人 不畏惧任何困难 まよいつづけるふたつのこころ いろあせることないせかいへ 迷 い続 ける二 つの心 色 褪せることない世界 へ 仍在迷惘的两颗心 一同前往永不黯淡的世界 いまかがやくよ かさなりあったEYES 今 輝 くよ 重 なりあったEYES 此刻绽放光芒 那重合的双眼 しずむたいようにつきがとけるよ 沈 む太 陽 に月 が溶けるよ 月亮融化在西沉的落日之中 かこになくしたきおくのページをとりもどすちからを 過去になくした記憶 のページを取り戻どすpower を 请给我能夺回过往失去的记忆书页的力量 やみをつらぬくしんじるこころたましいねむるばしょさがして 闇 を贯 ぬく信 じる心 魂 眠る 場所 探がして 坚信能冲破黑暗的心 寻找灵魂长眠之处 まばたきできない するどいがんこうをもやす 瞬 きできない 鋭 い眼 光 を燃やす 眼中燃起让人难以眨眼的锐利光芒 ひかりとかげのふたつのこころ くりすたるにうつるみらいへ 光 と影 の二 つの心 クリスタルに映 る未来 へ 光与暗的两颗心 一同前往水晶中映照的未来 いまうごきだす あかくみなぎるEYES 今 動き 出す 紅 く漲 るEYES 此刻开始行动 那涨红的双眼 かさなりあうEYES 重 なり合うEYES 那重合的双眼","categories":[{"name":"日语学习","slug":"日语学习","permalink":"https://shymuel.top/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://shymuel.top/tags/%E6%97%A5%E8%AF%AD/"},{"name":"日文歌","slug":"日文歌","permalink":"https://shymuel.top/tags/%E6%97%A5%E6%96%87%E6%AD%8C/"}]},{"title":"Java基础知识点总结","slug":"Java基础知识点总结","date":"2021-07-11T07:19:34.000Z","updated":"2022-05-01T14:24:08.428Z","comments":true,"path":"79803d5e.html","link":"","permalink":"https://shymuel.top/79803d5e.html","excerpt":"","text":"本文内容均来源于网络，如尚硅谷的免费视频课程、菜鸟教程和优质博客等；本文仅供学习交流使用。 初识Java Java发行版有多个后缀名，通常Java SE 开发桌面级应用；Java EE 开发web应用；Java ME运行在移动端； Java的应用：企业级应用；Android平台开发；大数据平台开发；移动领域应用； Java的特点： 一：面向对象。类，对象；封装，继承，多态； 二：健壮性；三：跨平台性，通过JVM虚拟机实现； 两个核心机制：虚拟机和垃圾回收机制； JDK：Java开发工具包，其中包含了JRE。其中有编译工具javac.exe和打包工具jar.exe。 JRE：Java运行环境，包括虚拟机和Java程序所需核心类库等。想运行一个开发好的Java程序，只安装JRE即可。 JDK的目录：bin，基本程序；db，数据库；include，头文件；lib，jar包；src，常用的类库和源码； 程序员编写.java 源文件，用javac.exe编译为.class 字节码文件，再用Java.exe运行； 编译运行java源文件： 12javac helloworld.java (加后缀)java helloworld （不加后缀） Java严格区分大小写，但是Windows路径不区分大小写； 注释分为单行注释、多行注释和文档注释；文档注释可被编译器编译，生成网页形式的说明文档； 12345/**@author 指定作者@version 指定源文件版本*/javadoc -d myHello -author -version HelloJava.java 一个源文件中可以写多个类，但最多只能有一个类声明为public，并且这个类得和.java文件同名。 编译时每个类单独生成一个class文件。 不知道学了多少遍的基础知识 变量相关 Java中有关键字和保留字。保留字现在还不是关键字但以后可能会是。 自己起的变量名叫标识符，注意不能用数字开头； 命名规范：包名全小写；类名接口名所有单词首字母大写；变量和方法名第一个单词首字母小写，后面开始大写；常量名全大写，单词之间用_连接；变量必须定义在作用域（{}）中； 声明long型变量以l或者L结尾； char中只能有一个字符，可以是转义字符； Unicode底层字符，可以是如同'123'的字符；保存文件的时候用ANSI编码时，cmd可以输出中文； 类型之间的关系 byte、char、short同级，运算之后必须赋值给int类型的变量；强制类型转换时截断或者变成最小值； byte b+1编译不通过，因为默认常数是int型，小数是double型； string可以和boolean类型做运算，结果为后面连接一个true或者false； 进行赋值时，八进制用0开头，二进制0b开头，十六进制0x开头； 运算符 运算符分为算术、赋值、比较、逻辑、位运算、三元运算符； 取余运算的结果符号与被模数的符号相同。 自增1不会改变本身数据的类型（针对int，byte等类型）；Java支持连续赋值； +=不会改变变量本身的数据类型。 12345short s1 = 10;s1 += 2; // 可通过编译；int n = 10;n += (n++) + (++n); // 32 比较运算符结果都是Boolean型； instanceof()：检查是否是类的对象； &amp;&amp; 短路与；|| 短路或；^ 逻辑异或。短路运算符按顺序运行，如果左侧的表达式已知其值是true或者false，则右侧的表达式不会进行计算； 逻辑运算符只能适用于布尔类型变量； 位运算：直接对整数的二进制进行运算。&gt;&gt;&gt; 无符号右移（不管被移动数字是正还是负，最高位都用0补齐）；~取反运算； 使用位运算符交换两个变量的值： 123num1 = num1 ^ num2;num2 = num1 ^ num2;num1 = num1 ^ num2; 单目运算符、三元运算符、赋值运算符都是从右向左计算；这导致a?b:c?d:e 等价于 a?b:(c?d:e) 而不是 (a?b:c)?d:e Java程序在控制台进行交互 从键盘获取不同类型变量：使用Scanner类； 1234567import java.util.Scanner;Scanner scan = new Scanner(System.in);int num = scan.nextInt();string: scan.next();scan.nextDouble();scan.nextBoolean(); char型没有单独的输入方式，可以用读取字符串的方式读入，再从中取出某一位： 1234567Math.sqrt(i);String s = readKeyBoard(i); // 从键盘读入一个长度i的字符串s.tpUpperCase(); // 变成大写s.charAt(i); // 可以取出某个位置的字符(int)(Math.random()*90+10); // random产生0到1的随机数 switch后面的表达式类型可以是：byte，short，char，int，枚举类型，string 123456int[] x，y[]; // x是一维数组，y是二维数组；// 此时x代表一个对象（Java和C不同）y[0] = x; // yesarray2 = array1; // 即可完成数组的复制，注意这个时候array2和array1指向同一个位置，改array2，array1也会改变// 正确的数组复制需要new一个数组，逐个赋值 Java的string可以很长。 数组 数组的元素可以是基本或者引用数据类型；数组长度定好之后不能修改！ 123456//静态初始化int[] ids;ids = new in[]&#123;1,2,3&#125;;ids = &#123;1,2,3&#125;;//动态初始化String[] names = new String[4]; 数组元素是引用数据类型则默认值是null； arrays工具类的使用： 12345boolean equals(int[] a, int[] b); //判断两个数组是否相等String toString(int[] a); //输出数组信息void fill(int[] a, int val); //指定值填充到数组中void sort(int[] a); //排序int binarySearch(int[] a, int key); //对排序后的数组进行二分法检索指定的值 数组如果没有赋值会报空指针错误，null； 新建变量的存储位置 栈中：存放局部变量；堆中：new出来的对象和数组； string：常量池中；static类型的变量：保存在静态域中； 12String[][] arr2 = new String[3][2];String[][] arr3 = new String[3][]; Java面向对象 Java类及类的成员包含的“内容”：属性，方法，构造器； 其中有些特殊的成员：代码块，内部类 面向对象的三大特性：封装，继承，多态。有些人还命名的其他特性如抽象性。 类和对象 类的成员：属性（成员变量），行为（方法函数）。 属性直接定义在类的{}里，局部变量在方法等的内部； 局部变量不能加修饰符（除了final）。非static属性是类的每个对象都有一套。 小tips：alt+左箭头可以快速到函数定义位置或返回 如果要使用对象的方法，哪怕是在对象内部使用也要new一个对象； 四舍五入取整：Math.round(double d)；非对象语言和Java交互的时候依然表现为对象； 引用数据类型在使用的时候其变量名都是代表地址值； 匿名对象的使用（每次都重新创建一个对象）： 12new phone().sendEmail();mall.show(mew phone()); 函数的值传递机制： 参数是基本数据类型，实参赋给形参的是他储存的真实数据值； 参数是引用数据类型，形参得到的是变量所保存的数据的地址值。 1println(char[] x); //直接输出了char数组 重载 重载两同一不同：同一个类，相同方法名；参数列表不同：参数个数或者类型不同； 返回值相同或者不同都可以构成重载； 可变个数形参的方法：public void show(String ... strs)；即“数据类型 ... 数据名”的形式；参数数量可以是0个。 需要注意可变个数形参的方法与把数组作为参数的方法不构成重载； 可变个数形参必须放在最后；重载的函数中最多声明一个可变个数形参； 类的封装和隐藏 把类的属性声明成private，则类外不能直接调用属性；只能通过方法如setlegs，getlegs. 封装性的体现需要权限修饰符来配合：private，缺省，protected，public（从小到大）。 属性体现封装性，类也可以体现封装性； 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes default yes yes protected yes yes yes public yes yes yes yes 有四种权限修饰符可以修饰类和类的内部结构。class的权限只可以用public和default； 不同的包可以定义重名类。 构造器：功能是创建对象，实际使用中和类同名。不显式定义则默认提供一个空参的构造器。构造器严格来说不是方法，可以重载。 属性赋值的先后顺序：默认，显式初始化，构造器中赋值，调用属性进行赋值。 Javabean：特殊的java类。类是公共的，有一个无参的公共的构造器，有属性，有对应的get，set方法；可重用组件。 默认构造器的权限和其所在的类相同。 在开发过程中，为了清晰的显示类和类之间的关系，可以使用UML类图。 this和import的使用 方法内部用，则表示对该方法对象的引用；构造器内部使用，表示构造器正在初始化的对象； this表示当前对象，可以修饰方法，属性； 类的方法中可以使用this.属性或this.方法，构造器中也可以this修饰方法和属性； this调用构造器：this(args)，主要是为了减少构造器中的冗余代码；自始至终对象只有一个；this(args)必须声明在当前构造器首行，构造器内部最多只能调用一个其他构造器； ALT+SHITF+S 调出代码生成器 package：更好的管理类，声明类或者接口属于的包，放在首行； MVC设计模式：M模型处理数据，V视图显示数据，C控制处理业务逻辑； import：在源文件中使用import导入指定包下的类和接口；声明在包和类的声明之间；import xxx.*导入其下所有内容，但是不包含其中的子包； import static：导入类或接口中的静态结构，同时import static的结尾一定是.* 持续更新ing","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://shymuel.top/tags/Java/"},{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"HEXO和GitHub建站（一）","slug":"HEXO建站（一）","date":"2021-07-11T04:56:11.000Z","updated":"2022-05-01T14:26:57.749Z","comments":true,"path":"b077d8cb.html","link":"","permalink":"https://shymuel.top/b077d8cb.html","excerpt":"","text":"环境搭建 首先安装node.js，直接官网下载安装。接着安装git for windows，直接官网安装（访问官网及后续安装搞个梯子会方便很多）。安装之后用下述语句查看版本以确认安装成功。 123git versionnode -vnpm -v 新建一个文件夹用于存放博客相关的环境和内容配置，例如\"blog\"。在该文件夹中右击，选择\"Git bash here\"。安装HEXO： 123npm install hexo -g #安装Hexonpm update hexo -g #升级，可不进行hexo init #初始化博客 HEXO的常用指令如下（这些指令均要在上面创建的blog文件夹路径下运行）： 1234567891011hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章hexo g == hexo generate # 生成hexo s == hexo server # 启动服务预览（安装hexo之后直接就可以进行）hexo d == hexo deploy # 部署到GitHub（需要预先与GitHub进行连接）# 上面的几条语句，使用的时候输入&quot;==&quot;前面的部分就可以了。hexo server # Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s # 静态模式hexo server -p 5000 # 更改端口hexo server -i 192.168.1.1 # 自定义 IPhexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令 这样就可以在本地预览网站效果。为了能在其他设备上访问自己的网站，我选择GitHub托管自己的数据。 具体的操作是在GitHub上建立仓库，然后配置权限让自己可以把blog的内容直接部署到GitHub上。上传成功之后就可以用仓库的名称来访问博客，如我的是\"shymuel.github.io\"。但github的后缀容易被墙，我的解决方法是自己购买一个域名。国内域名需要实名审核但比较保险，大家可以自行选择合适的域名商。 Volantis主题使用 HEXO使用量最大的主题大概就是NexT了，它的功能十分强大，看起来也比较简洁。 我为了看起来更加的二次元而选择了Volantis主题，主要是为了使用它的定时换背景功能（因为我有太多壁纸想放上去了）。图片目前我还是放在本地，采用相对路径。后面抽空研究一下如何使用CDN实现图片读取。 Volantis自带文章目录功能，可根据md文件中的标题在网页一侧生成目录。 配置背景图、头像之类的需要在blog文件夹下新建名为\"_config.volantis.yml\"的文件进行配置。建议按照主题文档进行。 对于字数统计和阅读时长显示，先要安装wordcount插件： 1npm i --save hexo-wordcount 之后可以通过主题配置文件里的 word_count 关键字来选择是否开启此功能，默认false。在配置文件的enable后面加上true。 Twikoo评论插件 根据官方文档进行配置。我选择的是Vercel部署方式。原开发者做了非常非常详细的视频教程。我把_config.volantis.yml中关于评论的设置改成了如下的样子： 1234567891011121314151617twikoo: js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本 path: # 全局评论地址 # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项 envId: https://twikoo-dusky.vercel.app/ # vercel id appId: # your appId appKey: # your appKey meta: [nick,mail,link] # valine comment header info requiredFields: [nick,mail] enableQQ: true # Unstable avatar link recordIP: false # Record commenter IP avatar: img/avatar.jpg # gravatar style https://valine.js.org/avatar pageSize: 10 # comment list page size lang: zh-cn highlight: true mathJax: false 部署之后还可以根据自己的需求，下载密钥设置管理员密码来对评论系统进行管理和定制。 暗黑模式 按照_config.volantis.yml中的描述，修改navbar目录，在menu子目录中添加： 123- name: 暗黑模式 # 可自定义 icon: fas fa-moon # 可自定义 toggle: darkmode 自动生成文章的唯一永久链接 使用abbrlink生成。首先下载abbrlink。 1npm install hexo-abbrlink --save 之后修改根目录站点配置文件config.yml，改为： 1234url: https://自己的网址名/permalink: :abbrlink.htmlabbrlink: alg: crc32 #算法： crc16(default) and crc32 之后hexo三连即可。 插入LateX公式 更换渲染工具为 hexo-renderer-pandoc： 123npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-pandoc --save 安装 hexo-math 插件以支持 latex 公式： 1npm install hexo-math --save volantis主题的话，在_config.volantis.yml中把mathjax后面改成true即可。注意要clean之后重新生成，latax公式才能正常显示。 记得要在有公式的博客开头加上： 1mathjax: true","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://shymuel.top/tags/HEXO/"},{"name":"个人网站","slug":"个人网站","permalink":"https://shymuel.top/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}]},{"title":"新的开始","slug":"新的开始","date":"2021-06-26T12:44:43.000Z","updated":"2021-08-03T10:37:16.000Z","comments":true,"path":"b585e161.html","link":"","permalink":"https://shymuel.top/b585e161.html","excerpt":"","text":"最后还是回来写代码了……感觉传统工科的老师都在搞机器学习，那我也没有办法，只能重新回来刷题。 这个博客上的内容可能会写的支离破碎一些，毕竟现在都在做各种项目，也不可能把全部的代码放上来，大概只是记录一下自己能做到什么功能吧，核心代码也会放一些。","categories":[{"name":"日志","slug":"日志","permalink":"https://shymuel.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://shymuel.top/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"日语学习","slug":"日语学习","permalink":"https://shymuel.top/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"日志","slug":"日志","permalink":"https://shymuel.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://shymuel.top/tags/Python/"},{"name":"C++","slug":"C","permalink":"https://shymuel.top/tags/C/"},{"name":"日语","slug":"日语","permalink":"https://shymuel.top/tags/%E6%97%A5%E8%AF%AD/"},{"name":"日文歌","slug":"日文歌","permalink":"https://shymuel.top/tags/%E6%97%A5%E6%96%87%E6%AD%8C/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"论文编辑","slug":"论文编辑","permalink":"https://shymuel.top/tags/%E8%AE%BA%E6%96%87%E7%BC%96%E8%BE%91/"},{"name":"学习和工作","slug":"学习和工作","permalink":"https://shymuel.top/tags/%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%B7%A5%E4%BD%9C/"},{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"算法学习","slug":"算法学习","permalink":"https://shymuel.top/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"HEXO","slug":"HEXO","permalink":"https://shymuel.top/tags/HEXO/"},{"name":"个人网站","slug":"个人网站","permalink":"https://shymuel.top/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"name":"Java","slug":"Java","permalink":"https://shymuel.top/tags/Java/"},{"name":"随笔","slug":"随笔","permalink":"https://shymuel.top/tags/%E9%9A%8F%E7%AC%94/"}]}