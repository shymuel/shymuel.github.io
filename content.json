{"meta":{"title":"Shymuel's Blog","subtitle":"","description":"Learn and Play","author":"Shymuel","url":"https://shymuel.top","root":"/"},"pages":[{"title":"","date":"2021-08-29T08:30:13.980Z","updated":"2021-06-26T12:07:06.000Z","comments":true,"path":"404.html","permalink":"https://shymuel.top/404.html","excerpt":"","text":""},{"title":"","date":"2021-06-26T12:04:55.000Z","updated":"2021-06-27T03:19:42.000Z","comments":true,"path":"about/index.html","permalink":"https://shymuel.top/about/index.html","excerpt":"","text":"只是一时兴起罢了。 E-mail: shymuel1998@163.com Brief：C++/Java，太弱小了，没有力量。 2021.06.26 如果不提高业务能力的话，就不得不昧着良心去做事情了。所以为了让自己心里好受一些，也要努力学习和进步。"},{"title":"所有分类","date":"2021-06-27T03:16:47.000Z","updated":"2021-06-27T03:18:24.000Z","comments":true,"path":"categories/index.html","permalink":"https://shymuel.top/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-06-27T03:19:59.000Z","updated":"2021-08-17T04:05:46.000Z","comments":true,"path":"friends/index.html","permalink":"https://shymuel.top/friends/index.html","excerpt":"目前只有一个友链的shymuel是屑。","text":"目前只有一个友链的shymuel是屑。 不会有人从这个渠道申请吧？不会吧不会吧？"},{"title":"img","date":"2021-06-26T12:06:11.000Z","updated":"2021-06-26T12:06:12.000Z","comments":true,"path":"img/index.html","permalink":"https://shymuel.top/img/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-29T09:19:25.116Z","updated":"2021-08-29T09:19:25.116Z","comments":true,"path":"tags/index.html","permalink":"https://shymuel.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【AnalogueElectronics2】课程笔记","slug":"【AnalogueElectronics2】课程笔记","date":"2022-08-21T02:24:08.000Z","updated":"2022-08-21T02:42:41.425Z","comments":true,"path":"2119635949.html","link":"","permalink":"https://shymuel.top/2119635949.html","excerpt":"","text":"0 Online Syllabus Block 1: block models of analogue; op-amps（运放）. Block 2: Diodes. Block 3: Transistors Bipolar and field effect transistor; Transistor biasing circuits; Analysis of small-signal AC circuits. 这篇博文只是我的课程笔记，所以不可能达到课件那种精细程度，还请读者海涵。 1 Block 1 1.1 Amplifiers Amplifiers from system prospective; Bode Plot; Decibels and how we can understand them. Matching conditions：放大器输入电阻远大于电源电阻，放大器输出电阻远小于负载电阻。 Amplifier Classifications Type Input Output Gain Matching Conditions Voltage V V \\(K_v=\\frac{V_{out}}{V_{in}}\\) \\(R_{in}\\gg R_s(\\infty)\\) \\(R_{O}\\gg R_L(0)\\) Current I I \\(K_I=\\frac{I_{out}}{I_{in}}\\) \\(R_{in}\\ll R_s(0)\\) \\(R_{O}\\gg R_L(\\infty)\\) Transresistance I V \\(R_m=\\frac{V_{out}}{I_{in}}\\) \\(R_{in}\\ll R_s(0)\\) \\(R_{O}\\ll R_L(0)\\) Transconductance V I \\(G_m=\\frac{I_{out}}{V_{in}}\\) \\(R_{in}\\gg R_s(\\infty)\\) \\(R_{O}\\gg R_L(\\infty)\\) Efficiency: 功率，用\\(\\eta\\)表示。 \\(P_{in}+P_{DC}=P_L+P_{diss}\\)；\\(\\eta=\\frac{P_L}{P_{DC}}\\times 100\\%\\). 单端or多端输入输出。 波特图：展示放大器的频率响应。Gain用分贝表示，横轴是log10为底的频率。 典型的放大器： 通频带，放大倍数和频率无关； 上限截止频率和下限截止频率，增益比中频段少3分贝。 分贝：dB，放大器增益的单位。电学中的分贝定义的是信号放大倍数的对数，对电压（电流）与功率放大倍数的定义是不同的。 电压（电流）放大倍数分贝数定义：\\(K=20\\log\\left|\\frac{V_O}{V_I}\\right|\\)； 功率放大倍数分贝数定义：\\(K=10\\log\\left|\\frac{P_O}{P_I}\\right|\\)。 \\(K&lt;0\\)，信号被衰减；\\(K&gt;0\\)，信号被放大。 Negative gain indicates a phase change of \\(180^o\\) between input and output signals. 截止频率是-3dB的情形，相当于输出功率变为输入功率的一半，输出电压或电流变为输入的0.707倍。 dBm是分贝毫瓦，代指功率的绝对值。\\(0\\operatorname{dBm}=1\\operatorname{mW}\\)。 放大器系统的频率响应： 完美耦合情况下的信号增益； 造成信号损失的因素，可能是因为不完美耦合或故意造成衰减。 要得到总的频率响应，只需将波特图叠加到一起。 例题：介绍了串级系统如何计算增益，以及如何设计得到所需增益的电路。 1.2 Operational Amplifiers 运算放大器：接近理想的直流放大器。用来信号整理，滤波和数学运算。运算有加减，积分和微分。 理想运算放大器的三个特性： infinite gain; infinite input impedance; zero output impedance. \\(V_O=A_{OL}*(V_1-V_2)\\) \\(A_{OL}\\)：开环增益；\\(Z_{in}\\)：输入电阻；\\(Z_{out}\\)：输出电阻；Bandwidth：通频带；Offset Voltage：漂移电压；Common mode rejection ratio：共模抑制比，差模电压放大倍数/共模电压放大倍数。 current rule：虚断；voltage rule：虚短，同相输入端和反向输入端之间电压差为0； GBP：指定频率出的带宽和增益的乘积。GBP是一个定值，故可以反过来用GBP求特定增益对应的频率。 Inverting amplifiers：反相放大器。 运算放大器的关键指标；GBP，如果运放开环增益始终满足-20dB/10倍频，也就是频率提高10倍，开环增益变为0.1倍，那么它们的乘积将是一个常数。\\(GBP=BW\\times A\\)。BW和A都不用分贝表示。 放大器电路的输入电阻的计算； 正增益电路 负增益电路 1.3 Differential Amplifiers 差分放大电路 用叠加原理，依次将V1、V2置为0，观察其对Vout的影响。 \\(Gain=\\frac{V_{out}}{V_2-V_1}\\)； 但是，差分放大电路有个问题，即输入电阻较小。输入电阻看定义谁是Ui，然后看一下输入电流是多少。解决输入电阻小的问题，可以利用电压跟随器。 Instrumentation Amplifier 测量放大器 测量放大器 1.4 Filters 电容电感电路的阻抗 Ideal Low Pass Filter, Ideal High Pass Filter, Band Pass Filter. Active LPF: Provides Gain, Op-Amps or Transistors; Passive LPF: No Gain, R or C or L. 这里要开始求频率响应。 \\(f=\\frac{1}{T}=\\frac{\\omega}{2\\pi}\\)； 引入运放构成滤波器：电压关系用阻抗来计算。 电容加在R2是低通，加在R1是高通。R1R2都加电容就有了带通滤波器。中间还有相位差是0对应的频率。 \\(1F=10^{3}mF=10^{6}\\mu F=10^{9}nF=10^{12}pF\\) 画波特图。感觉是和自控里面一样的。 Schmitt Triger：将周期信号变成方波。 Astable Multivibrator based Schmitt Triger. 求振荡器的充放电时间。 Astable Relaxation Oscillator: 这一节考察充放电时间。 多谐振荡器充放电示意图 Op-amp Monostable Pulse Generator 单稳态触发器。 It has one stable and one quasi-stable state. Output voltage will remain at that stable state unless an external triggering pulse causes a transmission to quasi-stable state. After certain time T, output will return to its stable state. It got its name from the fact that only one of its output states is stable. It is also known as a 'one-shot'. 这个超级有意思，15-(-15)变成30V，然后Vx本来是0，要瞬间加上一个30V的大电压。如果从+15变成-15，Vx要瞬间减少30V。 2 Block 2 二极管电压计算公式： \\(\\begin{aligned} I_{D} &amp;=I_{O}\\left[\\exp \\left(\\frac{V_{D}}{V_{T}}\\right)-1\\right] \\\\ I_{D} &amp;=I_{O}\\left[\\exp \\left(\\frac{V_{D}}{V_{T}}\\right)\\right] \\\\ \\ln \\left(I_{D}\\right) &amp;=\\ln \\left[I_{O}\\left[\\exp \\left(\\frac{V_{D}}{V_{T}}\\right)\\right]\\right] \\\\ &amp;=\\ln I_{O}+\\left[\\left(\\frac{V_{D}}{V_{T}}\\right)\\right] \\end{aligned}\\) 二极管建模：理想二极管+常值电压+串联电阻。 三种等效模型：理想二极管，理想二极管+常值电压，理想二极管+常值电压+串联电阻。 二极管的教学视频 二极管将正弦整流成DC。这个DC为啥除以π，没看懂。 全波整流桥式电路：直流电压是0.637Vmax。 https://www.electronics-tutorials.ws/diode/diode_6.html voltage doubler circuit：电压翻倍电路。钳位电路+半波整流电路。 倍压整流电路。 3 Block 3 双极型晶体管：NPN, PNP；场效应管：N沟道，P沟道。 场效应管：源极（source, S），栅极（gate, G），漏极（drain, D）。MOSFET的控制端称为栅极，源极和漏极是对称的，命名来自于电流方向。电流从漏极流向源极，即电压高的一端为漏极。 场效应管的S模型 \\(V_{GS}\\)高于阈值电压VT时，元件导通，否则关断。N沟道MOSFET的典型VT是0.7V。iG永远为0。 如果\\(v_{\\mathrm{DS}}&lt;v_{\\mathrm{GS}}-V_{\\mathrm{T}}\\)，则工作在数电状态，称为三极管区域，这时可以将场效应管视为SR模型，电流随Vd线性增加。 \\(v_{\\mathrm{DS}}\\geq v_{\\mathrm{GS}}-V_{\\mathrm{T}}\\)的区域称为饱和区域，电流曲线会变得扁平。 双极型晶体管：两种管的图像。Vbe=0.6V。截止区，放大区，饱和区。 Active Region, Saturation, Cut-off. 理想情况下集电极电流和Vc无关，实际上是有依赖的。装置的电导有限。 双极型晶体管和场效应管的对比： 双极型晶体管同时利用电子和空穴，是双极型管。 场效应管只用电子或空穴，是单极性的。 电流控制电流的器件。 电压控制电流的器件。 输入基于b和e，像一个前向PN结，输入电阻小。 g和s之间像电容，输入电阻大。 双极型二极管作为放大器：Uc&gt;Ub&gt;Ue b极增加正弦信号，ib变化会引起ic变化，然后引起Uce反向变化。 放大器分析的要点： 静态工作点选好，让晶体管工作在放大区； 输入一个小信号。 因为放大倍数β是一个难以控制的量，所以应该选择Ic而不是Ib。电路也变化了： 计算电路中各个值 计算电路中各个值 电阻系列的变化方式：E12，E6，E24。 现在开始学双极型晶体管放大电路的交流通路……注意，电容在交流电的时候相当于短路。 基于场效应管的放大电路，输出电压从源极引出。 4 常用名词对照表 Operational Amplifiers 运算放大器 Systems Perspective 系统视角 overall gain 总增益 frequency response 频率响应 passband 通频带 Bode Plots 波特图 milliWatt(dBm) 毫瓦特 decibels(dB) 分贝 Cascaded Systems 串级系统 cut-off 截止 Inverting 反向放大电路 Non-Inverting 正向放大电路 Differential Amplifier 差分放大电路 Instrumentation Amplifier 测量放大器 Low Pass Filter 低通滤波器 High Pass Filter 高通滤波器 Band Pass Filter 带通滤波器 Schmitt Triger 施密特触发器 Astable Multivibrator 不稳多谐振荡器 Op-amp Monostable Pulse Generator 单稳态脉冲触发器 Diodes 二极管 Transistors 晶体管 Bipolar Transistors 双极型晶体管 Field Effect Transistors 场效应管","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://shymuel.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"模电","slug":"模电","permalink":"https://shymuel.top/tags/%E6%A8%A1%E7%94%B5/"}]},{"title":"【Git使用】入门知识","slug":"【Git使用】入门知识","date":"2022-07-22T16:55:46.000Z","updated":"2022-08-21T02:46:15.091Z","comments":true,"path":"3586729497.html","link":"","permalink":"https://shymuel.top/3586729497.html","excerpt":"","text":"软件准备：下载Git Bash并注册Git账号。 在某个位置，右键单击空白处，点击Git Bash Here，配置用户名和邮箱： Text123456git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx&quot;# 如果不放心可以输入以下命令检查自己的用户名和邮箱git config user.namegit config user.email 0 上传项目到Gitee 参考资料：Git入门使用。 上传项目可以分成3步：在Gitee网页中创建远程仓库，将本地代码上传到本地仓库，将本地代码上传到远程仓库。 首先在Gitee上创建该项目的远程仓库，此处不讲。 接着进行本地项目上传到本地仓库的这一步。在项目文件夹中右键单击空白处，点击Git Bash Here。逐条输入以下命令： Text123git init # 初始化本地仓库git add . # 注意这里有个点git commit -m &#x27;本次提交的说明&#x27; # 说明信息为必填项，信息最好有意义，便于后期理解 要将本地仓库上传到远程仓库，首先要将本地仓库与远程仓库相连接。 在远程仓库复制http链接，然后输入下列命令（xxx为刚才复制的链接）： Text123git remote add origin xxx # 远程链接仓库git pull --rebase origin master # 强制更新远程仓库git push -u origin master # 将本地仓库中的文件推送到远程仓库 最后回到Gitee网页，刷新一下即可！ 下面开始是黑马程序员的教程。因为原教程很多内容用不到，故只看完了P1-P10。 1 Git 基础 Git是目前世界上最先进的分布式版本控制系统。 Git下载和安装： 下载地址； 使用默认值安装； 资源管理器内单击鼠标右键选择Git Bash Here ； 输入git --version 检查是否安装成功。 2 Git基本工作流程及命令 2.1 Git中的文件位置 文件的位置改变：工作区→暂存区→本地仓库→远程仓库。 工作区：本地电脑存放项目文件的地方，比如learnGitProject文件夹。添加、编辑、修改文件等动作。 暂存区(Index/Stage)：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。.git文件夹中包含了两个部分，一个是暂存区(Index 或者 Stage)，顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里。 本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中。 远程仓库：项目代码在远程git服务器上的位置。比如项目在github上就是放在一个远程仓库中，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可。 日常开发时代码放置在工作区中，也就是本地的XXX.java这些文件，通过add等这些命令将文件提交给暂存区(Index/Stage)，也就意味着代码全权交给了git进行管理，之后通过commit等命令将暂存区提交给master分支上，也就是打了一个版本，也可以说代码提交到了本地仓库中。另外，团队协作过程中自然而然还涉及到与远程仓库的交互。 因此，经过这样的分析，git命令可以分为这样的逻辑进行理解和记忆： git管理配置的命令； 工作区与暂存区的交互； 暂存区与本地仓库（分支）上的交互； 本地仓库与远程仓库的交互。 工作目录 暂存区 git仓库 远程仓库 被 Git 管理的项目 临时存放被修改的文件 目录用于存放提交记录 远程代码仓库 git init git add git commit git push 2.2 Git使用前的配置命令 在使用前告诉git你是谁： 第一次使用git，配置用户信息： 配置用户名：git config --global user.name \"用户名\"； 配置用户邮箱：git config --global user.email \"邮箱地址\"。 查询配置信息： 查询用户名（查询邮箱同理）：git config --global user.name； 列出当前配置：git config --list； 列出repository配置：git config --local --list； 列出全局配置：git config --global --list； 列出系统配置：git config --system --list。 其他配置： 配置解决冲突时使用哪种差异分析工具，比如要使用vimdiff：git config --global merge.tool vimdiff； 配置git命令输出为彩色的：git config --global color.ui auto； 配置git使用的文本编辑器：git config --global core.editor vi。 注：也可直接修改：C:\\Users\\用户\\.gitconfig 。 2.3 工作区上的操作命令 新建仓库： 将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：git init； 从远程git仓库复制项目：git clone 远程仓库地址 ； 克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名，如：git clone git://github.com/wasd/example.git NewName； 查看文件状态：git status。 查新信息： 查询当前工作区所有文件的状态：git status; 比较工作区中文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff； 提交文件到暂存区：git add 文件/文件列表 。 提交文件到暂存区： 提交当前目录所有文件到暂存区：git add .； 提交当前目录指定文件到暂存区：git add 文件名1 文件名2 文件名3； 提交当前目录某个文件夹中所有文件到暂存区：git add [dir]； 提交文件到仓库（或者叫版本库）： 将暂存区中的文件提交到本地仓库中，即打上新版本：git commit -m \"commit_info\"； 将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程：git commit -a -m \"commit_info\"； 提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：git commit --amend； 查看版本差异和回退历史记录： 比较暂存区与上一版本的差异：git diff --cached; 指定文件在暂存区和本地仓库的不同：git diff --cached 文件1; 查看提交历史：git log或git log --pertty=oneline。推荐用第二个命令，显示结果更简洁。可以用参数-p规定显示多少次提交的内容差异，比如-2表示显示最近的两次更新，如git log -p -2。 回退到某个版本（覆盖暂存区和工作目录）：git reset --hard 提交编号。 注意：回退到过去版本之后，要想回到之前最新的版本，需要使用指令git reflog去查看历史操作，以得到最新的commit_id，此时的commit_id没有显示全，但是仍然可以用，至少要前4位。 删除和修改文件： 用暂存区中的文件覆盖工作目录中的文件：git checkout -- 文件名 。不加 -- 文件名则覆盖全部文件。 将文件从暂存区中删除，但是工作区还有该文件：git rm --cached 文件名 。 删除工作区文件，并且也从暂存区删除对应文件的记录：git rm 文件名 。 取消暂存区已经暂存的文件：git reset HEAD ...。 撤销操作： 如果想保留上一次的修改以备以后继续工作，可以使用储藏(stashing)和分支来处理。其中储藏可以理解为在不commit的情况下保存自己的工作，之后可以切换分支。储藏的具体讲解可以看博客1和博客2。 将当前代码储藏，以便能够切换分支：git stash。 查看当前所有的储藏：git stash list。 应用最新的储藏：git stash apply。如果想应用某个特定版本的储藏：git stash apply stash@&#123;2&#125;。其中stash@&#123;2&#125; 是储藏编号。apply命令只是应用储藏，而储藏的内容仍然还在栈上。 删除指定的储藏：git stash drop stash&#123;0&#125;。 删除所有的储藏：git stash clear。 如果想在恢复内容的同时将储藏从栈中删除，可以使用pop：git stash pop。 在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于stash unapply的命令，但是可以通过取消该储藏的补丁达到同样的效果：git stash show -p stash@&#123;0&#125; | git apply -R。 如果你沒有指定具体的某个储藏，Git会取消最近的储藏：git stash show -p | git apply -R。 更新文件： 重命名文件，并将已改名文件提交到暂存区：git mv [file-original] [file-renamed]; 3 Git进阶 3.1 分支 生成副本，避免影响开发主线。 分支的类别： 主分支(master)：第一次向git仓库提交更新记录时自动产生的一个分支。 开发分支(develop)：作为开发的分支，基于master分支创建。 功能分支(feature)：作为开发具体功能的分支基于开发分支创建。 注意修改某分支文件后要commit后再切换分支，否则某分支的文件会出现在其他分支里。 3.2 分支命令 查看本地仓库的所有分支：git branch。 创建分支：git branch 分支名称。新建并切换到新建分支上：git checkout -b 分支名词 。 切换分支：git checkout 分支名称。 合并分支：git merge 来源分支。 删除分支（分支合并后才允许被删除，但可以用-D强制删除）：git branch -d 分支名称。 git push origin :branch-name : 远程仓库同步删除分支 查看各个分支最后一个提交对象的信息：git branch -v; 查看哪些分支已经合并到当前分支：git branch --merged; 查看当前哪些分支还没有合并到当前分支：git branch --no-merged; 把远程分支合并到当前分支：git merge /，如git merge origin/serverfix；如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进(Fast forward)，而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交。 4 Github 注册Github账号：略。 多人协作开发流程： A在自己的计算机中创建本地仓库； A在GitHub中创建远程仓库； A将本地仓库推送到远程仓库； B克隆远程仓库到本地进行开发； B将本地仓库开发内容推送到远程仓库； A将远程仓库中的最新内容拉去本地。 Github中创建远程仓库：略。 4.1 推送代码 前面已经说过，从远程仓库拷贝代码是用git clone命令。 推送代码到远程仓库： Text123456git push 远程仓库地址 分支名称git push 远程仓库地址别名 分支名称git push -u 远程仓库地址别名 分支名称 # -u表示记住推送地址和分支，下次只需要输入git pushgit remote add 远程仓库地址别名 远程仓库地址 删除别名：git remote remove 远程仓库地址别名 。 第一次提交需要用户名和密码，电脑会记住密码在凭据管理器，第二次就不用了。 本地仓库上的操作： 查看本地仓库关联的远程仓库：git remote；在克隆完每个远程仓库后，远程仓库默认为origin；加上-v的参数后，会显示远程仓库的url地址； 添加远程仓库，一般会取一个简短的别名：git remote add [remote-name] [url]，比如：git remote add example git://github.com/example/example.git; 从远程仓库中抓取本地仓库中没有的更新：git fetch [remote-name]，如git fetch origin；使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，需要人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用git pull来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支； 将本地仓库某分支推送到远程仓库上：git push [remote-name] [branch-name]，如git push origin master；如果想将本地分支推送到远程仓库的不同名分支：git push :，如git push origin serverfix:awesomebranch;如果想删除远程分支：git push [romote-name] :，如git push origin :serverfix。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。 查看远程仓库的详细信息：git remote show origin； 修改某个远程仓库在本地的简称：git remote rename [old-name] [new-name]，如git remote rename origin org； 移除远程仓库：git remote rm [remote-name]； 4.2 拉取远程仓库中的代码 克隆远程仓库到本地：git clone 仓库地址 。 拉取远程仓库最新版本到本地：git pull 远程仓库地址 分支名称 。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"代码管理","slug":"代码管理","permalink":"https://shymuel.top/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"}]},{"title":"【Python】Collections","slug":"【Python】Collections","date":"2022-05-01T14:22:23.000Z","updated":"2022-08-21T02:48:26.926Z","comments":true,"path":"1245507953.html","link":"","permalink":"https://shymuel.top/1245507953.html","excerpt":"","text":"这个库内含多种容器。 1 defaultdict 它解决的是我们使用dict当中最常见的问题，就是key为空的情况，访问一个dict中不存在的key会导致系统抛出异常。 dict当中为我们提供了带默认值的get方法。比如，可以写成： 1return dict.get(key, None) 这样，当key不在dict当中存在的时候，会自动返回设置的默认值。这省去了很多麻烦的判断，但是在一些特殊情况下仍然存在一点问题。比如当希望将key相同的value存进一个list当中而不是只保留一个，需要写成： 1234567data = [(1, 3), (2, 1), (1, 4), (2, 5), (3, 7)]d = &#123;&#125;for k, v in data: if k in d: d[k].append(v) else: d[k] = [v] 或者： 1234for k, v in data: cur = d.get(k, []) cur.append(v) d[k] = cur 为了完美解决这个问题，可以使用collections当中的defaultdict： 12345from collections import defaultdictd = defaultdict(list)for k, v in data: d[k].append(v) 使用defaultdict之后，如果key不存在，容器会自动返回预先设置的默认值。需要注意的是 defaultdict 传入的默认值可以是一个类型也可以是一个方法。如果传入int，默认值会被设置成int()的结果，也就是0。如果想要自定义或者修改，可以传入一个方法，比如： 1234d = defaultdict(lambda: 3)for k, v in data: d[k] += v 2 Counter 对数据进行统计。只需要一行代码即可统计一个list中的内容： 1234567words = [&#x27;apple&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;watermelon&#x27;, &#x27;pear&#x27;, &#x27;peach&#x27;]from collections import Countercounter = Counter(words)&gt;&gt;&gt; print(counter)Counter(&#123;&#x27;apple&#x27;: 2, &#x27;pear&#x27;: 2, &#x27;watermelon&#x27;: 1, &#x27;peach&#x27;: 1&#125;) 上面的代码直接将一个list传入Counter中作为参数，它会自动给每个元素计数。 筛选topK也非常简单，Counter 提供了most_common()方法，只需要传入需求的K即可： 123counter.most_common(1)[(&#x27;apple&#x27;, 2)] 除此之外，Counter的构造函数还接收dict类型。可以直接通过一个value是int类型的dict来初始化一个Counter，比如： 12c = Counter(&#123;&#x27;apple&#x27;: 5, &#x27;pear&#x27;: 4&#125;)c = Counter(apple=4, pear=3) 并且，Counter还支持加减法的操作。两个Counter相加时会自动合并，即相同的key对应的value累加。相减也是同理，会将能对应的value做减法，被减的key中没有对应的会保留，而减数中没有对应的key则会被丢弃。并且需要注意，Counter支持value为负数。 3 deque queue是队列，deque是双端队列。deque的队首和队尾都支持元素的插入和弹出。 除了常用的clear、copy、count、extend等api之外，deque当中最常用也是最核心的api还有append、pop、appendleft和popleft。append和pop与list的append和pop一样是在队尾进行操作，而appendleft和popleft则是在队列左侧，也就是队首进行pop和append的操作。 真正用到双端队列的算法不太多，使用deque主要有两个原因。第一个原因是deque收到GIL的管理，它是线程安全的。而list则没有GIL锁，因此不是线程安全的。也就是说在并发场景下，list可能会导致一致性问题，而deque不会。另一个原因是deque支持固定长度，当长度满了之后继续append时，它会自动弹出最早插入的数据。 当拥有海量的数据，想要保留最后出现的指定数量的数据的时候，就可以使用deque： 12345from collections import dequedque = deque(maxlen=10)# 假设我们想要从文件当中获取最后10条数据for i in f.read(): dque.append(i) 4 namedtuple namedtuple很特殊，涉及到元编程的概念。 常见的面向对象是定义类，然后通过类的构造函数来创建实例。元编程指的是定义元类，根据元类创建出一个类。如果用模具和成品来分别比喻类和实例的话，元类相当于是模具的模具。 namedtuple是一个非常简单的元类，通过它可以非常方便地定义想要的类。 比如如果我们想要定义一个学生类，这个类当中有name、score、age这三个字段，那么这个类会写成： 12345class Student: def __init__(self, name=None, score=None, age=None): self.name = name self.score = score self.age = age 这只是粗略的写法，如果考虑规范还需要定义property等注解，又需要很多代码。使用namedtuple可以简化这个工作： 1234567from collections import namedtuple# 这个是类，columns也可以写成&#x27;name score age&#x27;，即用空格分开Student = namedtuple(&#x27;Student&#x27;, [&#x27;name&#x27;, &#x27;score&#x27;, &#x27;age&#x27;])# 这个是实例student = Student(name=&#x27;xiaoming&#x27;, score=99, age=10)print(student.name) 通过使用namedtuple，只用一行就定义了一个类。还可以通过传入defaults参数来定义缺省值： 1Student = namedtuple(&#x27;Student&#x27;, [&#x27;name&#x27;, &#x27;score&#x27;, &#x27;age&#x27;], defaults=(0, 0)) 可以注意到，虽然定义了三个字段，但是只设置了两个缺失值。在这种情况下，namedtuple会自动将缺失值匹配上score和age两个字段。因为在Python的规范当中，必选参数一定在可选参数前面。所以nuamdtuple会自动右对齐。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://shymuel.top/tags/Python/"}]},{"title":"【C++】零散知识点","slug":"【C++】零散知识点","date":"2022-04-17T13:50:37.000Z","updated":"2022-08-21T02:45:02.226Z","comments":true,"path":"348283507.html","link":"","permalink":"https://shymuel.top/348283507.html","excerpt":"","text":"1 C++中的注释 单行注释： 1// 这是单行注释 多行注释： 12345/** 这是多行注释的第一行* 这是多行注释的第二行* &quot;*&quot;不是必须的，但加上会显得整齐些*/ 条件注释： 1234// 0为条件参数#if 0 code#endif 为代码撰写注释： 123456789101112131415161718/** 写在代码开头* 代码功能、版权、作者、编写日期等*/// 写在代码块前面的注释：内容为大段的解释信息/// 当使用visual的时候，可以在函数上方直接打三个斜杠，然后就会获得……/// &lt;summary&gt;/// 求a和b的和/// &lt;/summary&gt;/// &lt;param name=&quot;a&quot;&gt;被加数&lt;/param&gt;/// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;int sum(int a, int b) &#123; return a + b;&#125; 但是肉眼可见的，上面的注释风格实在是太丑了，这能忍？好消息是Visual Studio 2019给我们提供了注释风格的选项，路径为【工具 / 选项 / 文本编辑器 / C/C++ / 代码样式 / 常规】，在这里面可以选择注释风格，理论上来说\"///\"是最快捷的，但我还是觉得难看，选择了\"/**\"的注释风格： 123456789/** * @brief 求和 * @param a * @param b * @return */int sum(int a, int b) &#123; return a + b;&#125; 快速将一部分代码注释掉：选中代码，ctrl+k，ctrl+c，或者ctrl+k+c三个键一起按。 取消注释：选中代码，ctrl+k，ctrl+u，或者ctrl+k+u三个键一起按。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"https://shymuel.top/tags/C/"}]},{"title":"【Python】面向对象","slug":"【Python】面向对象","date":"2022-04-08T03:41:06.000Z","updated":"2022-08-21T02:50:20.790Z","comments":true,"path":"3267076484.html","link":"","permalink":"https://shymuel.top/3267076484.html","excerpt":"","text":"0 面向对象相关概念 面向对象(Object Oriented)：软件开发方法，一种编程范式。 类(Class)：具有相同的属性和方法的对象的集合，它的定义中包含该集合中每个对象所共有的属性和方法。对象是指类的实例。 类变量：类变量定义在类中且在函数体之外，通常不作为实例变量使用。该变量的值由该类的所有对象共享。 数据成员：类变量或者实例变量，用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖(override)，也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类(derived class)继承基类(base class)的变量和方法，Python也允许把一个派生类的对象作为一个基类对象对待。 实例化：创建一个类的实例，即创建类的一个具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括数据成员（类变量和实例变量）和方法。 1 类的基础 1.1 定义类 Python中使用class语句来定义一个新类，class之后为类的名称并以冒号结尾: 123class ClassName: &#x27;类的帮助信息&#x27; # 类文档字符串 class_suite # 类体 类的帮助信息可以通过ClassName.__doc__查看，class_suite由类成员，方法，数据属性组成。 一个简单的Python类的例子： 1234567891011121314class Employee: &#x27;所有员工的基类&#x27; empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(&quot;Total Employee %d&quot; % Employee.empCount) def displayEmployee(self): print(&quot;Name : &quot;, self.name, &quot;, Salary: &quot;, self.salary) empCount是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类中使用Employee.empCount访问。 第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，每次创建该类的一个实例时就会调用该方法。 方法中的变量self代表类的实例，self在定义类的方法时是必须有的，但是在调用时不必传入相应的参数。 self详解：self代表类的实例而非类。类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，按照惯例它的名称是self。 1234567class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 以上实例执行结果为： Text12&lt;__main__.Test object at 0x0000013CE6C87610&gt;&lt;class &#x27;__main__.Test&#x27;&gt; 从执行结果可以很明显的看出，self代表的是类的实例，代表当前对象的地址，而self.__class__则指向类。self不是Python的关键字，把它换成其他名称也是可以正常执行的。__main__.Test是类的全名。 1.2 类的实例对象 其他编程语言中一般用关键字new实例化一个对象，但是Python中并没有这个关键字，类的实例化类似函数调用方式。 以下使用类的名称Employee来实例化，并通过__init__方法接收参数。 1234&quot;&quot;&quot;创建 Employee 类的第一个对象&quot;&quot;&quot;emp1 = Employee(&quot;Zara&quot;, 2000)&quot;&quot;&quot;创建 Employee 类的第二个对象&quot;&quot;&quot;emp2 = Employee(&quot;Manni&quot;, 5000) 1.2.1 访问类的属性 使用点号\".\"来访问对象的属性（变量或方法）： 123emp1.displayEmployee()emp2.displayEmployee()print(&quot;Total Employee %d&quot; % Employee.empCount) 完整实例： 12345678910111213141516171819202122class Employee: &#x27;所有员工的基类&#x27; empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(&quot;Total Employee %d&quot; % Employee.empCount) def displayEmployee(self): print(&quot;Name : &quot;, self.name, &quot;, Salary: &quot;, self.salary) &quot;创建 Employee 类的第一个对象&quot;emp1 = Employee(&quot;Zara&quot;, 2000)&quot;创建 Employee 类的第二个对象&quot;emp2 = Employee(&quot;Manni&quot;, 5000)emp1.displayEmployee()emp2.displayEmployee()print(&quot;Total Employee %d&quot; % Employee.empCount) 执行以上代码输出结果如下： Text123Name : Zara , Salary: 2000Name : Manni , Salary: 5000Total Employee 2 添加，删除，修改类的属性，如下所示： 123emp1.age = 7 # 添加一个 &#x27;age&#x27; 属性emp1.age = 8 # 修改 &#x27;age&#x27; 属性del emp1.age # 删除 &#x27;age&#x27; 属性 Python有个非常有趣的特性，即支持给已创建的对象增加属性！这在Java中是做不到的，C++大概也不能。 从面向对象的角度来说，不推荐直接用\".\"来访问属性，推荐使用set()和get()方法来进行属性值的设定和获取，这两类方法称为setter、getter方法。Python提供了以下函数来访问属性： getattr(obj, name[, default])：访问对象的属性； hasattr(obj,name)：检查是否存在一个属性； setattr(obj,name,value)：设置一个属性。如果属性不存在，会创建一个新属性； delattr(obj, name)：删除属性。 1234getattr(emp1, &#x27;age&#x27;) # 返回 &#x27;age&#x27; 属性的值hasattr(emp1, &#x27;age&#x27;) # 如果存在 &#x27;age&#x27; 属性返回 True。setattr(emp1, &#x27;age&#x27;, 8) # 添加属性 &#x27;age&#x27; 值为 8delattr(emp1, &#x27;age&#x27;) # 删除属性 &#x27;age&#x27; 1.2.2 Python内置类属性 __dict__：类的属性，是一个由类的数据属性组成的字典； __doc__：类的文档字符串； __name__：类名； __module__：类定义所在的模块，类的全名是__main__.className，如果类位于一个导入模块mymod中，那么className.__module__等于mymod； __bases__：类的所有父类，是一个由所有父类组成的元组。 Python内置类属性调用实例如下： 1234567891011121314151617181920class Employee: &#x27;所有员工的基类&#x27; empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(&quot;Total Employee %d&quot; % Employee.empCount) def displayEmployee(self): print(&quot;Name : &quot;, self.name, &quot;, Salary: &quot;, self.salary) print(&quot;Employee.__doc__:&quot;, Employee.__doc__)print(&quot;Employee.__name__:&quot;, Employee.__name__)print(&quot;Employee.__module__:&quot;, Employee.__module__)print(&quot;Employee.__bases__:&quot;, Employee.__bases__)print(&quot;Employee.__dict__:&quot;, Employee.__dict__) 执行以上代码输出结果如下： Text12345Employee.__doc__: 所有员工的基类Employee.__name__: EmployeeEmployee.__module__: __main__Employee.__bases__: (&lt;class &#x27;object&#x27;&gt;,)Employee.__dict__: &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: &#x27;所有员工的基类&#x27;, &#x27;empCount&#x27;: 0, &#x27;__init__&#x27;: &lt;function Employee.__init__ at 0x00000250D7A3C1F0&gt;, &#x27;displayCount&#x27;: &lt;function Employee.displayCount at 0x00000250D7A3C160&gt;, &#x27;displayEmployee&#x27;: &lt;function Employee.displayEmployee at 0x00000250D7A3C280&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Employee&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Employee&#x27; objects&gt;&#125; 1.2.3 Python对象销毁（垃圾回收） Python使用了引用计数这一简单技术来跟踪和回收垃圾。 在Python内部用内部跟踪变量记录着所有使用中的对象各有多少引用，称为引用计数器。 对象被创建时就创建了一个引用计数。当不再需要某对象，即该对象的引用计数变为0时它被垃圾回收。但是回收不是“立即”的，由解释器在适当的时机将垃圾对象占用的内存空间回收。 1234567a = 40 # 创建对象 &lt;40&gt;b = a # 增加引用， &lt;40&gt; 的计数c = [b] # 增加引用. &lt;40&gt; 的计数del a # 减少引用 &lt;40&gt; 的计数b = 100 # 减少引用 &lt;40&gt; 的计数c[0] = -1 # 减少引用 &lt;40&gt; 的计数 垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下仅使用引用计数是不够的。Python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充，垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。在这种情况下解释器会暂停下来，试图清理所有未被引用的循环。 为了研究垃圾回收机制，使用析构函数__del__。__del__在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行： 123456789101112131415class Point: def __init__( self, x=0, y=0): self.x = x self.y = y def __del__(self): class_name = self.__class__.__name__ print(class_name, &quot;销毁&quot;) pt1 = Point()pt2 = pt1pt3 = pt1print(id(pt1), id(pt2), id(pt3)) # 打印对象的iddel pt1del pt2del pt3 以上实例运行结果如下： Text122012588891008 2012588891008 2012588891008Point 销毁 注意：通常需要在单独的文件中定义一个类， 1.3 类的继承 面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 继承语法： 12class 派生类名(基类名) ... 在Python中继承的一些特点： 如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： python 子类继承父类构造函数说明。 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别在于类中调用普通函数时并不需要带上self参数 Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。即先在本类中查找调用的方法，找不到才去基类中找。 如果在继承元组中列了一个以上的类，那么它就被称作\"多重继承\" ，继承的积累在括号中列出： Text12class SubClassName(ParentClass1, ParentClass2, ...):...... 派生类的实例： 1234567891011121314151617181920212223242526class Parent: # 定义父类 parentAttr = 100 def __init__(self): print(&quot;调用父类构造函数&quot;) def parentMethod(self): print(&#x27;调用父类方法&#x27;) def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print(&quot;父类属性 :&quot;, Parent.parentAttr) class Child(Parent): # 定义子类 def __init__(self): print(&quot;调用子类构造方法&quot;) def childMethod(self): print(&#x27;调用子类方法&#x27;) c = Child() # 实例化子类c.childMethod() # 调用子类的方法c.parentMethod() # 调用父类方法c.setAttr(200) # 再次调用父类的方法 - 设置属性值c.getAttr() # 再次调用父类的方法 - 获取属性值 以上代码执行结果如下： Text1234调用子类构造方法调用子类方法调用父类方法父类属性 : 200 继承多个类的案例： 123456class A: # 定义类 A.....class B: # 定义类 B.....class C(A, B): # 继承类 A 和 B..... 判断某个类是不是子类可以使用issubclass()或者isinstance()方法： issubclass(Class1, Class2)：布尔函数，Class1是Class2的子类或者子孙类则返回true。 isinstance(obj, Class)：布尔函数，如果obj是Class类的实例对象或者是Class子类的一个实例对象则返回true。 2 类方法的重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写（又叫重载）你父类的方法： 12345678910class Parent: # 定义父类 def myMethod(self): print &#x27;调用父类方法&#x27; class Child(Parent): # 定义子类 def myMethod(self): print &#x27;调用子类方法&#x27; c = Child() # 子类实例c.myMethod() # 子类调用重写方法 执行以上代码输出结果如下： Text1调用子类方法 2.1 基础重载方法 序号 方法, 描述 &amp; 简单的调用 1 __init__(self, args...)：构造函数。简单的调用方法：obj = className(args) 2 __del__(self)：析构方法, 删除一个对象。简单的调用方法：del obj 3 __repr__(self)：转化为供解释器读取的形式。简单的调用方法：repr(obj) 4 __str__(self)：用于将值转化为适于人阅读的形式。简单的调用方法：str(obj) 5 __cmp__ ( self, x )：对象比较。简单的调用方法：cmp(obj, x) 2.2 运算符重载 Python同样支持运算符重载： 1234567891011121314151617class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): # __str__在print被调用，目的是输出类的内容 return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b) def __add__(self, other): return Vector(self.a + other.a, self.b + other.b)v1 = Vector(2, 10)v2 = Vector(5, -2)print(v1)print(v1 + v2)print(v1.__str__()) 以上代码执行结果如下所示: Text123Vector (2, 10)Vector (7, 8)Vector (2, 10) 3 类的属性与方法 3.1 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时写作self.__private_attrs。 3.2 类的方法 在类的内部，使用def关键字可以为类定义一个方法。与一般函数定义不同，类方法必须包含参数self作为第一个参数。 3.3 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用时写作self.__private_methods。 私有属性的实例（私有方法类似）： 1234567891011121314class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print(self.__secretCount) counter = JustCounter()counter.count()counter.count()print(counter.publicCount)print(counter.__secretCount) # 报错，实例不能访问私有变量 Python 通过改变名称来包含类名: Text1234567122Traceback (most recent call last): File &quot;C:\\Users\\jh108\\PycharmProjects\\PythonLearningCodes\\OOP.py&quot;, line 21, in &lt;module&gt; print(counter.__secretCount) # 报错，实例不能访问私有变量AttributeError: &#x27;JustCounter&#x27; object has no attribute &#x27;__secretCount&#x27; Python不允许实例化的类访问私有数据，但你可以使用object._className__attrName（对象名._类名__私有属性名）访问属性，参考以下实例： 123456class Runoob: __site = &quot;www.runoob.com&quot;runoob = Runoob()print(runoob._Runoob__site) 执行以上代码，执行结果如下： Text1www.runoob.com 3.4 单下划线、双下划线、头尾双下划线说明 __foo__: 两边都有双下划线的是特殊方法，一般是系统定义名字，类似__init__()之类的。 _foo: 以单下划线开头的是protected类型的变量，即保护类型。只能允许其本身与子类进行访问，不能用于from module import *。 __foo: 双下划线的表示的是私有类型(private)的变量，只能允许这个类本身进行访问。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://shymuel.top/tags/Python/"}]},{"title":"【日文歌词】《うっせぇわ》歌词（中日语+假名对照版）","slug":"【日文歌词】《うっせぇわ》歌词（中日语+假名对照版）","date":"2022-01-10T07:32:17.000Z","updated":"2022-07-22T17:14:36.140Z","comments":true,"path":"899839865.html","link":"","permalink":"https://shymuel.top/899839865.html","excerpt":"","text":"本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。 ただしさとは、おろかさとは 正 しさとは、愚 かさとは 什么叫正确？什么叫愚蠢？ それがなにかみせつけてやる それが何 か見せつけてやる 现在就让你们见识一下吧！ ちっちゃなころからゆうとうせい ちっちゃな頃 から優 等 生 从小便是优等生 きづいたらおとなになっていた 気づいたら大 人になっていた 回过神来便已成为了大人 ナイフのようなしこうかいろ ナイフの様 な思考 回 路 充满了刀锋般的思考方式 もちあわせるわけもなく 持ち合わせる訳 もなく 但也没必要和你一起比较吧 でもあそびたりない、なにかたりない でも遊 び足りない、何 か足りない 但是玩不够啊，还不够快乐啊 こまっちまうこれはだれかのせい 困 っちまうこれは誰 かのせい 左右为难又是谁的错啊 あてもなくただこんらんするエイデイ あてもなくただ混 乱 するエイデイ 也不过只是没有目的的日程渐渐变得混乱 それもそっか 那也是当然嘛 さいしんのりゅうこうはとうぜのはあく 最 新 の流 行 は当 然 の把握 最流行的东西，第一时间掌握 きゅうざいのどうこうはつうきんじチェック 経 済 の動 向 は通 勤 時チェック 经济的流向上班前查看 じゅんじょうなせいしんでにゅうしゃしワーク 純 情 な精 神 で入 社 しワーク 抱有热情的进公司工作 しゃかいじんじゃとうぜんのルールです 社 会 人 じゃ当 然 のルールです 这可是社会人的规则啊 はぁ？うっせぇうっせぇうっせぇわ 哈？啰嗦！烦人！吵死了！ あなたがおもうよりけんこうです あなたが思 うより健 康 です 我可比你想的要健康得多 いっさいがっさいぼんような 一 切 合 切 凡 庸 な 一切一切都平凡的你 あなたじゃわからないかもね あなたじゃ分からないかもね 你可能不明白吧 ああよくにあう 嗚呼よく似合う 啊，和你可真是般配啊 そのかもなくふかもないメロディー その可もなく不可もないメロディー 这没有存在必要的旋律 うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ あたまのできがちがうのでもんだいはナシ 頭 の出来が違 うので問 題 はナシ 我们头脑构造不一样，所以没什么问题！ つってもわたしもはんにんげん つっても私 模範 人 間 就算这样我也可是人之模范啊 なぐったりするのはノーセンキュー 殴 ったりするのはノーセンキュー 教训你一顿这种事也是不用谢我 だったらことばのじゅうこうを だったら言 葉の銃 口 を 既然这样就将枪口（话语） そのあたまにつきつけてうてば その頭 に突きつけて撃てば 对准脑门一通扫射吧！ マジヤバない？とまれやしない マジヤバない？止まれやしない 这样下去很糟糕吧？不试试放弃吗？ ふへいふまんだれてなれのはて 不平 不満 誰 て成れの果て 怨天尤人可不会有好下场的 サディスティックにへんぼうするせいしん サディスティックに変 貌 する精 神 变得施虐者一般的思想 クソだりぃな 真是渣滓 さけがあいたグラスあればすぐにつぎなさい 酒 が空いたグラスあれば直ぐに注ぎなさい 酒杯空了就立马装满 みんながつまみやすいようにくしがいしなさい 皆 がつまみ易い ように串 外 しなさい 为了大家吃东西更方便给我把菜从串上取下来 かいけいやちゅうもんはせんじんをきる 会 計 や注 文 は先 陣 を切る 结账和点菜搞快点 ふぶんりつさいていげんのマナーです 不文 律 最 低 限 のマナーです 这是最低限度的不成文规定吧 はぁ？うっせぇうっせぇうっせぇわ 哈？啰嗦！烦人！吵死了！ くせぇくちふさげやげんかいです くせぇ口 塞 げや限 界 です 也该闭上你这张臭嘴了吧我受够了 ぜったいぜったいげんだいのだいべんしゃはわたしやろがい 絶 対 絶 対 現 代 の代 弁 者 は私 やろがい 现代人的榜样绝对就是我了吧 もうみあきたわ もう見飽きたわ 已经见多了啊 にばんせんじいいかえのパロディ 二番 煎 じ言い換えのパロディ 换汤不换药只是换了个说法的模仿 うっせぇうっせぇうっせぇわ 啰嗦！吵死了！烦死了 まるまるとにくついたそのがんめんにバツ 丸 々 と肉 付いたその顔 面 にバツ 恨不得赏你这肥猪一拳 うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ わたしがぞくにいうてんさいです 私 が俗 に言う天 才 です 我可是你们所说的天才！ うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ あなたがおもうよりけんこうです あなたが思 うより健 康 です 我可比你想的要健康得多！ いっさいがっさいぼんような 一 切 合 切 凡 庸 な 一切一切都平凡的你 あなたじゃわからないかもね あなたじゃ分からないかもね 可能不明白吧 ああつまらねぇ 嗚呼つまらねぇ 啊，真无趣啊 なんかいきかせるんだそのメモリー 何 回 聞かせるんだそのメモリー 这样的回忆已经听了多少遍啊 うっせぇうっせぇうっせぇわ 啰嗦！烦人！吵死了！ アタシもたいがい だけど アタシも大 概 だけど 我或许也差不多... どうだっていいぜもんだいはナシ どうだっていいぜ問 題 はナシ 不！怎么都好，我没有问题！","categories":[{"name":"日语学习","slug":"日语学习","permalink":"https://shymuel.top/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://shymuel.top/tags/%E6%97%A5%E8%AF%AD/"},{"name":"日文歌","slug":"日文歌","permalink":"https://shymuel.top/tags/%E6%97%A5%E6%96%87%E6%AD%8C/"}]},{"title":"【Latax】语法记录","slug":"【Latax】语法记录","date":"2021-12-15T02:30:35.000Z","updated":"2022-07-22T17:23:10.553Z","comments":true,"path":"2021361885.html","link":"","permalink":"https://shymuel.top/2021361885.html","excerpt":"","text":"Overleaf的LaTex教程 包含基本上所有Latex小语法的网站 在线Latex公式编辑器（界面比第二个网站更好看） 给字母加奇怪的东西 \\pmb{}，字母加粗 Text1\\pmb&#123;x&#125;, \\ \\pmb&#123;X&#125; \\(\\pmb{x}, \\ \\pmb{X}\\) \\hat{}，头顶加小尖角 Text1\\hat&#123;\\gamma&#125;_&#123;j k&#125;=\\frac&#123;\\alpha_&#123;k&#125; \\phi\\left(y_&#123;j&#125; \\mid \\theta_&#123;k&#125;\\right)&#125;&#123;\\sum_&#123;k=1&#125;^&#123;R&#125; \\alpha_&#123;k&#125; \\phi\\left(y_&#123;j&#125; \\mid \\theta_&#123;k&#125;\\right)&#125; \\(\\hat{\\gamma}_{j k}=\\frac{\\alpha_{k} \\phi\\left(y_{j} \\mid \\theta_{k}\\right)}{\\sum_{k=1}^{R} \\alpha_{k} \\phi\\left(y_{j} \\mid \\theta_{k}\\right)}\\) 各种括号和方框 \\begin{cases}，多种情况的表示 Text1\\gamma_&#123;j k&#125;= \\begin&#123;cases&#125;1, &amp; \\text &#123; 第 &#125; j \\text &#123; 个观测来自第 &#125; k \\text &#123; 个分模型 &#125; \\\\ 0, &amp; \\text &#123; 否则 &#125;\\end&#123;cases&#125; \\(\\gamma_{j k}= \\begin{cases}1, &amp; \\text { 第 } j \\text { 个观测来自第 } k \\text { 个分模型 } \\\\ 0, &amp; \\text { 否则 }\\end{cases}\\) \\begin{array}，方程组 Text1\\left\\&#123;\\begin&#123;array&#125;&#123;l&#125;\\mathrm&#123;e&#125;^&#123;-x_&#123;1&#125;&#125;+\\mathrm&#123;e&#125;^&#123;-2 x_&#123;2&#125;&#125;+x_&#123;3&#125;-2 x_&#123;4&#125;+t_&#123;k&#125; x_&#123;5&#125;-5.3=0 \\\\ \\mathrm&#123;e&#125;^&#123;-2 x_&#123;1&#125;&#125;+\\mathrm&#123;e&#125;^&#123;-x_&#123;2&#125;&#125;-2 x_&#123;3&#125;+t_&#123;k&#125; x_&#123;4&#125;-x_&#123;5&#125;+25.6=0 \\\\ t_&#123;k&#125; x_&#123;1&#125;+3 x_&#123;2&#125;+\\mathrm&#123;e&#125;^&#123;-x_&#123;3&#125;&#125;-3 x_&#123;5&#125;+37.8=0 \\\\ 2 x_&#123;1&#125;+t_&#123;k&#125; x_&#123;2&#125;+x_&#123;3&#125;-\\mathrm&#123;e&#125;^&#123;-x_&#123;4&#125;&#125;+2 \\mathrm&#123;e&#125;^&#123;-2 x_&#123;5&#125;&#125;-31.3=0 \\\\ x_&#123;1&#125;-2 x_&#123;2&#125;-3 t_&#123;k&#125; x_&#123;3&#125;+\\mathrm&#123;e&#125;^&#123;-2 x_&#123;4&#125;&#125;+3 \\mathrm&#123;e&#125;^&#123;-x_&#123;5&#125;&#125;+42.1=0\\end&#123;array&#125;\\right. \\(\\left\\{\\begin{array}{l}\\mathrm{e}^{-x_{1}}+\\mathrm{e}^{-2 x_{2}}+x_{3}-2 x_{4}+t_{k} x_{5}-5.3=0 \\\\ \\mathrm{e}^{-2 x_{1}}+\\mathrm{e}^{-x_{2}}-2 x_{3}+t_{k} x_{4}-x_{5}+25.6=0 \\\\ t_{k} x_{1}+3 x_{2}+\\mathrm{e}^{-x_{3}}-3 x_{5}+37.8=0 \\\\ 2 x_{1}+t_{k} x_{2}+x_{3}-\\mathrm{e}^{-x_{4}}+2 \\mathrm{e}^{-2 x_{5}}-31.3=0 \\\\ x_{1}-2 x_{2}-3 t_{k} x_{3}+\\mathrm{e}^{-2 x_{4}}+3 \\mathrm{e}^{-x_{5}}+42.1=0\\end{array}\\right.\\) 既可以用来表示矩阵，也可以用来表示方程…… 数学表达式 根式 Text1\\sqrt[]&#123;&#125; \\(\\sqrt[n]{x+1}\\) 集合相关 Text12345$\\exists$$\\forall$$\\neg$$\\wedge$$\\vee$ \\(\\exists,\\ \\forall, \\ \\neg, \\ \\wedge,\\ \\vee\\) LaTex中的数学字体 有些字体需要在序言中引入特定的包：\\usepackage&#123;amssymb&#125; 有些字体支持一部分字符： Text123456\\begin&#123;align*&#125;RQSZ \\\\\\mathcal&#123;RQSZ&#125; \\\\\\mathfrak&#123;RQSZ&#125; \\\\\\mathbb&#123;RQSZ&#125;\\end&#123;align*&#125; \\(\\begin{align*} RQSZ \\\\ \\mathcal{RQSZ} \\\\ \\mathfrak{RQSZ} \\\\ \\mathbb{RQSZ} \\end{align*}\\) 手写体，哥特黑体，黑板粗体。 也可以将整个数学表达式的字体更换为另外一种： Text12345678\\begin&#123;align*&#125;3x^2 \\in R \\subset Q \\\\\\mathrm&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathit&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathbf&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathsf&#123;3x^2 \\in R \\subset Q&#125; \\\\\\mathtt&#123;3x^2 \\in R \\subset Q&#125; \\end&#123;align*&#125; \\(\\begin{align*}3x^2 \\in R \\subset Q \\\\ \\mathrm{3x^2 \\in R \\subset Q} \\\\ \\mathit{3x^2 \\in R \\subset Q} \\\\ \\mathbf{3x^2 \\in R \\subset Q} \\\\ \\mathsf{3x^2 \\in R \\subset Q} \\\\ \\mathtt{3x^2 \\in R \\subset Q} \\end{align*}\\) \\mathnormal&#123;3x^2 \\in R \\subset Q&#125;理论上这也是一种字体，和默认字体一样的，但是hexo的渲染器会报错，就没有放上去了。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"文档编辑","slug":"文档编辑","permalink":"https://shymuel.top/tags/%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91/"}]},{"title":"【安利】好用软件及网站分享","slug":"【安利】好用软件及网站分享","date":"2021-12-15T02:26:20.000Z","updated":"2022-08-21T02:52:03.190Z","comments":true,"path":"2675119176.html","link":"","permalink":"https://shymuel.top/2675119176.html","excerpt":"","text":"1 优秀软件 1.1 文档编辑 WPS，一直开会员，云文档功能yyds。 1.2 笔记软件 为知笔记。旧版和X版我都在用，笑死，已经变成为知笔记的形状了，一年60块买不了吃亏买不了上当。我现在写博客都是在为知笔记写完然后导出成Markdown。 1.3 论文阅读和管理 单纯看PDF的话WPS也能满足需求，但WPS是不提供文献管理功能的，批注功能也弱了点。今天发现一个叫IvySci的软件，中文名青藤学术，竟然还是个国产软件……well，再用一段时间再来评价，目前用免费版，收费版也不贵，但收费之后的空间确实小了点，看得出小公司没那么有钱……目前最吸引我的功能是软件内用各种引擎查论文，以及一键把论文中的引用文献加入项目。改版之后翻译功能强大了太多了，强烈推荐！！！ 论文管理也推荐EndNote，除了能方便的在word中插入文献，还可以为导入后的文献在SCI中搜索并下载论文本体，可以说非常方便了。 1.4 对文献进行引文分析 HistCist Pro。具体用法可以参考我《文献管理与信息分析》那篇博客。 2 优秀网站 2.1 论文搜索 之前一直用学校的网在SCI上查，最近觉得还是谷歌学术牛牛。但是懒得开科学上网的话，谷粉学术挺好用的，也可以去用镜像。 sci-hub当然也是非常好的选择。 2.2 电子书 Z-图书馆。免费下载大量电子书，配合Koodo简直无敌！！！ 2.3 论坛 分享资源的论坛： 电力电子技术与新能源。找《华为C++技术规范》的时候发现了这个论坛，C++和电力电子技术或许有些不搭，但这个网站上还有《华为-模拟电路讲义》，这么一来违和感就少了很多……？ 2.4 科研网站 Arxiv。已知论文编号，可以输入：https://arxiv.org/pdf/number.pdf。例如：https://arxiv.org/pdf/1702.04595.pdf。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"安利","slug":"安利","permalink":"https://shymuel.top/tags/%E5%AE%89%E5%88%A9/"},{"name":"优秀网站","slug":"优秀网站","permalink":"https://shymuel.top/tags/%E4%BC%98%E7%A7%80%E7%BD%91%E7%AB%99/"}]},{"title":"【强化学习入门】1 强化学习概述","slug":"【强化学习入门】1 强化学习概述","date":"2021-09-03T13:37:20.000Z","updated":"2022-08-21T02:53:15.652Z","comments":true,"path":"4072327491.html","link":"","permalink":"https://shymuel.top/4072327491.html","excerpt":"","text":"本系列文章为笔者学习网络上的强化学习教程之后的笔记，在原文和自己理解的基础上重新写作而成，基本可以认为是原文的精简版，后续可能会在阅读其他教材之后在对应章节添加例子等。原教程地址 1.1 强化学习 强化学习解决的是一个智能体如何在一个复杂不确定的环境里极大化它能获得的奖励。 在环境 (environment) 中，智能体 (agent) 进行各种动作( action) 产生某种状态 (state)，据此环境给出奖励 (reward)。这里的奖励是延迟奖励，即行为的进行到奖励的求得之间往往又隔了一些动作。 强化学习的一些特征：有试错探索 (trial-and-error exploration)，探索环境来获取对环境的理解；从环境中得到延迟的奖励；每个动作在时间上是连续的；agent 的行为会影响之后的数据。 举一个雅达利 pong 游戏的例子：一块板子往上或者往下，把弹球弹到对面。整个游戏过程是预演 (rollout) 的，即从当前帧可以生成很多局游戏。agent 和环境交互会产生很多观测，每个观测是一个轨迹 (trajectory)。轨迹是当前帧以及他采取的策略，即状态和动作的一个序列：\\(\\tau =(s_0,a_0,s_1,a_1, \\dots)\\)。 一场游戏叫做一个回合 (episode) 或者试验 (trial)。 最近把强化学习和深度学习结合起来，成为深度强化学习。 1.2 序列决策过程 序列决策 (sequential decision making) 过程可以说是一般的单智能体 RL 的通用过程。 奖励是由环境给的一个标量的反馈信号 (scalar feedback signal)，这个信号显示了智能体在某一步采取某个策略的表现如何。强化学习训练的目的就是为了最大化智能体可以获得的奖励，智能体行动的目的就是为了极大化它的期望的累积奖励 (expected cumulative reward)。同时要进行近期奖励和远期奖励的一个平衡，最终一般希望获得更多的长期奖励。 历史是观测、行为、奖励的序列： \\(H_t =\\{O_1, R_1, A_1,\\dots, A_{t-1},\\dots\\}\\) agent 在采取动作的时候依赖于它的历史，可以把整个游戏的状态看成这个历史的函数：\\(S_t=f(H_t)\\)。 状态\\(S\\)是对世界的完整描述，deep RL 中一般用实值的向量、矩阵或张量来表示状态和观测。 agent 的状态和环境的状态等价说明环境完全可观测。这种问题称为 MDP 问题。在这个问题中，\\(O_t=S^e_t=S^a_t\\)。 否则就是部分可观测的。称为 POMDP，即部分可观测马尔科夫决策过程。POMDP 是一个马尔科夫决策过程的泛化，具有马尔科夫性质，但假设智能体无法感知环境的状态\\(S\\)，只知道部分观测值\\(O\\)。 用一个七元组描述马尔科夫过程：\\((S, A, T, R, Ω, O, γ)\\)。\\(S\\)是状态空间，隐变量；\\(A\\)是动作空间，\\(T\\)是状态转移概率，\\(R\\)是奖励函数；\\(Ω\\)是观测概率，\\(O\\)为观测空间，\\(\\gamma\\)为折扣系数。 1.3 动作空间 不同环境中可以进行的动作是不同的。在给定环境中，有效动作的集合被称为动作空间。离散动作空间中动作数量有限；连续动作空间中动作种类无限，此时动作是实值的向量。 1.4 强化学习智能体的组成和类型 策略函数 (policy function)：用这个函数来选取下一步的动作； 价值函数 (value function)：对当前状态估价； 模型 (model)：表示 agent 对这个环境的状态进行的理解，这一点决定训练如何进行。 1.4.1 策略 策略一般有两种：随机性策略 (stochastic policy) 和确定性策略 (deterministic policy)。 随机性策略中，每个行为的发生是有概率的，要进行采样然后再动作，也就是说概率再小的动作也可能被执行。而确定性策略则只采用最有可能的概率，即\\(a^*=\\arg \\max_a \\pi(a\\mid s)\\)。随机性策略：输入一个状态s，输出是一个概率。进一步对概率进行采样，可以得到一个action。 对于 Atari 游戏，策略函数的输入就是游戏的一帧，他的输出决定往左或者往右。通常采用随机性策略，因为其动作具有多样性。 1.4.2 价值函数 价值函数是对未来奖励的一个预测，用来评估状态的好坏。 价值函数里有一个折扣因子 (discount factor)。我们希望在尽可能短的时间里得到尽可能多的奖励。价值函数的定义其实是一个期望： \\(v_{\\pi}(s) \\doteq \\mathbb{E}_{\\pi}\\left[G_{t} \\mid S_{t}=s\\right]=\\mathbb{E}_{\\pi}\\left[\\sum_{k=0}^{\\infty} \\gamma^{k} R_{t+k+1} \\mid S_{t}=s\\right],\\ \\text{for all}\\ s \\in \\mathcal{S}\\) 上面的公式表明已知某一个策略函数的时候，到底可以得到多少奖励。 还有一种价值函数叫 Q 函数，包含两个变量状态和动作： \\(q_{\\pi}(s, a) \\doteq \\mathbb{E}_{\\pi}\\left[G_{t} \\mid S_{t}=s, A_{t}=a\\right]=\\mathbb{E}_{\\pi}\\left[\\sum_{k=0}^{\\infty} \\gamma^{k} R_{t+k+1} \\mid S_{t}=s, A_{t}=a\\right]\\) Q 函数表明，奖励的期望取决于当前的状态和智能体的行为。 这两种价值函数在之后都会有详细解释和应用。 1.4.3 模型 模型决定了下一个状态会是什么样的。它由两个部分组成： 概率，指状态之间如何转移；奖励函数，指在当前状态进行了某个行为后可以得到多大的奖励。 有了上述三个部分之后就得到了一个马尔科夫决策过程。 1.4.4 强化学习智能体的类型 1.4.4.1 基于价值的智能体与基于策略的智能体 基于价值的智能体 (value-based agent)：显式学习价值函数，隐式学习策略。 基于策略的智能体 (policy-based agent)：直接学习策略，没有学习价值函数。 二者结合得到演员-评论员智能体 (actor-critic agent)，策略函数和价值函数都学习，然后通过两者交互得到一个最佳行为。 基于策略迭代和基于价值迭代的强化学习方法有什么区别？ 对一个状态转移概率已知的马尔科夫决策过程，可以用动态规划算法求解。决策方式来看，可以分为基于策略迭代的方法和基于价值迭代的方法。决策方式是静态的，不随状态变化而变化。 基于策略迭代的强化学习中，智能体会制定一套动作策略以确定给定状态下采取何种动作，并根据这个策略操作。有策略梯度算法等。基于价值迭代的方法则维护一个价值表格或函数。只能应用在不连续、离散的环境下。基于价值迭代的有 Q-learning，Sarsa等。演员-评论员算法同时使用策略和价值评估来做出决策，智能体根据策略做出动作，而价值函数会对做出的动作给出价值，这样可以在原有的策略梯度算法的基础上加速学习过程，取得更好的效果。 1.4.4.2 有模型强化学习智能体与免模型强化学习智能体 针对是否需要对真实环境建模，强化学习可以分为有模型学习和免模型学习。有模型学习是指根据环境中的经验，构建一个虚拟世界，同时在真实环境和虚拟世界中学习；免模型学习是指不对环境进行建模，直接与真实环境进行交互来学习到最优策略。 有模型 (model-based) 强化学习智能体通过学习状态的转移来采取动作。免模型 (model-free) 强化学习智能体没有直接估计这个状态的转移，也没有得到环境的具体转移变量，通过学习价值函数和策略函数进行决策。免模型的模型里面没有一个环境转移的模型。 免模型学习通常属于数据驱动型方法，需要大量的采样来估计状态、动作及奖励函数，从而优化动作策略。 1.5 学习与规划 学习 (learning) 和规划 (planning) 是序列决策的两个基本问题。 简单来说，强化学习面对环境的未知部分要进行学习，对于环境的已知部分要进行规划。 1.6 探索和利用 探索是指怎么探索环境，即找到能获得最大奖励的策略。利用是指不尝试新的东西，仅靠已知的信息就可以得到很大奖励的行为。 与监督学习不同，强化学习任务的最终奖赏是在多步动作之后才能观察到，这里不妨先考虑比较简单的情形：最大化单步奖赏，即仅考虑一步操作。需注意的是，即便在这样的简化情形下，强化学习仍与监督学习有显著不同，因为机器需通过尝试来发现各个动作产生的结果，而没有训练数据告诉机器应当做哪个动作。 单步强化学习对应了 K-臂赌博机 (K-armed bandit) 的模型。赌徒投入一个硬币后可选择按下一个摇臂，每个摇臂以一定的概率吐出金币，但这个概率赌徒不知道。赌徒的目标是通过一定的策略最大化自己的奖赏。 若想获知每个摇臂的期望奖赏，则可采用仅探索法，将所有机会平均分配给每个摇臂，然后计算期望。 如果只想执行奖赏最大的动作，则可采用仅利用法，按下目前最优的摇臂。若有多个最优则随机选一个。 显然，在探索和利用之间，必须要达成一个较好的折中。 1.7 强化学习实验 cuhkrlcourse的RL代码； OpenAI 的 Gym 是一个很强的环境仿真库。离散控制场景（输出的动作是可数的，比如 Pong 游戏中输出的向上或向下动作）一般使用雅达利环境评估；连续控制场景（输出的动作是不可数的，比如机器人走路时不仅有方向，还要角度，角度就是不可数的，是一个连续的量）一般使用 mujoco 环境评估。Gym Retro 是对 Gym 环境的进一步扩展，包含了更多的一些游戏。 简书上的 Gym 环境总结。 Gym 的官方文档。 1.7.1 第一次使用 Gym text1pip install gym # 安装 Gym 12345678import gymenv = gym.make(&quot;Taxi-v3&quot;) # 出租车接乘客的游戏observation = env.reset()for step in range(100): action = env.action_space.sample() # 随机动作 observation, reward, done, info = env.step(action) print(observation) 1.7.2 CartPole 例子 CartPole 要求通过控制一个平板让木棍立起来。输入是向左或向右的一个力，\\(\\pm1\\)。失败条件是木棍角度过大或平板离轨道中心太远。 123456789import gym # 导入 Gym 的 Python 接口环境包env = gym.make(&#x27;CartPole-v0&#x27;) # 构建实验环境env.reset() # 重置一个 episodefor _ in range(1000): env.render() # 显示图形界面 action = env.action_space.sample() # 从动作空间中随机选取一个动作 env.step(action) # 用于提交动作，括号内是具体的动作env.close() # 关闭环境 执行这段代码时，机器人会无视该立起来的杆子，驾驶着小车朝某个方向一通跑，直到不见踪影，这是因为动作是随机选取的。打印 env.action_space.sample() 的返回值，会发现值是 0 或 1，一左一右。env.step() 一方面是执行动作，另一方面还有四个返回值，分别是 observation、reward、done、info。 observation 是状态信息，指游戏中观测到的屏幕像素值或者盘面状态描述信息。reward 是奖励值，即 action 提交以后能够获得的奖励值。这个奖励值因游戏的不同而不同，但总体原则是对完成游戏有帮助的动作会获得比较高的奖励值。done 表示游戏是否已经完成。如果完成了，就需要重置游戏并开始一个新的回合。info 是一些比较原始的用于诊断和调试的信息，或许对训练有帮助。不过 OpenAI 团队在评价用户提交的机器人时不允许使用这些信息。 玩游戏的时候可以输出一下 observation 观察游戏的状态是怎么定义的。env.step() 完成了一个完整的\\(S\\rightarrow A\\rightarrow R\\rightarrow S^′\\)过程。我们只要不断观测这样的过程，并让机器在其中用相应的算法完成训练，就能得到一个高质量的强化学习模型。 想要查看当前 Gym 库已经注册了哪些环境，可以使用以下代码： 1234from gym import envsenv_specs = envs.registry.all()envs_ids = [env_spec.id for env_spec in env_specs]print(envs_ids) 每个环境都定义了自己的观测空间和动作空间。环境 env 的观测空间用 env.observation_space 表示，动作空间用 env.action_space 表示。观测空间和动作空间既可以是离散空间，也可以是连续空间。在 Gym 库中，离散空间一般用 gym.spaces.Discrete 类表示，连续空间用 gym.spaces.Box 类表示。 1.7.3 MountainCar-v0 例子 小车上山例子。小车要跑到右边的山顶上碰到旗子，但小车的马力不够强。唯一的办法是让小车在两个坡上来回移动，借助从左边山上冲下来的速度冲上右边的山顶。 1.7.3.1 输出游戏的信息 1234567import gymenv = gym.make(&#x27;MountainCar-v0&#x27;)print(&#x27;观测空间 = &#123;&#125;&#x27;. format(env.observation_space))print(&#x27;动作空间 = &#123;&#125;&#x27;. format(env.action_space))print(&#x27;观测范围 = &#123;&#125; ~ &#123;&#125;&#x27;. format(env.observation_space.low,env.observation_space.high))print(&#x27;动作数 = &#123;&#125;&#x27;. format(env.action_space.n)) 由输出可知，观测空间是形状为 (2,) 的浮点型 np.array，动作空间是取 0,1,2 的 int 型数值。 1.7.3.2 实现一个智能体类 12345678910111213141516171819class BespokeAgent: def __init__(self, env): pass def decide(self, observation): # 决策 position, velocity = observation lb = min(-0.09 * (position + 0.25) ** 2 + 0.03, 0.3 * (position + 0.9) ** 4 - 0.008) ub = -0.07 * (position + 0.38) ** 2 + 0.07 if lb &lt; velocity &lt; ub: action = 2 else: action = 0 return action # 返回动作 def learn(self, *args): # 学习 passagent = BespokeAgent(env) 智能体的 decide() 方法实现了决策功能，而 learn() 方法实现了学习功能。BespokeAgent 类是一个比较简单的类，它只能根据给定的数学表达式进行决策，不能有效学习，只是用来演示。 1.7.3.3 智能体与环境交互 12345678910111213141516def play_montecarlo(env, agent, render=False, train=False): episode_reward = 0. # 记录回合总奖励，初始化为0 observation = env.reset() # 重置游戏环境，开始新回合 while True: # 不断循环，直到回合结束 if render: # 判断是否显示 env.render() # 显示图形界面，图形界面可以用 env.close() 语句关闭 action = agent.decide(observation) next_observation, reward, done, _ = env.step(action) # 执行动作 episode_reward += reward # 收集回合奖励 if train: # 判断是否训练智能体 agent.learn(observation, action, reward, done) # 学习 if done: # 回合结束，跳出循环 break observation = next_observation return episode_reward # 返回回合总奖励 play_montecarlo 函数可以让智能体和环境交互一个回合。这个函数有 4 个参数。env 是环境类，agent 是智能体类，render 是 bool 类型变量，指示在运行过程中是否要图形化显示。 如果函数参数 render 为 True，那么在交互过程中会调用 env.render() 以显示图形化界面，而这个界面可以通过调用 env.close() 关闭。train 是 bool 类型的变量，指示在运行过程中是否训练智能体。在训练过程中应当设置为 True 以调用 agent.learn() 函数；在测试过程中应当设置为 False，使得智能体不变。这个函数有一个返回值 episode_reward，是 float 类型的数值，表示智能体与环境交互一个回合的回合总奖励。 1.7.3.4 智能体与环境交互并显示 1234env.seed(0) # 设置随机数种子,只是为了让结果可以精确复现,一般情况下可删去episode_reward = play_montecarlo(env, agent, render=True)print(&#x27;回合奖励 = &#123;&#125;&#x27;. format(episode_reward))env.close() # 此语句可关闭图形界面 为了系统评估智能体的性能，下列代码求出了连续交互 100 回合的平均回合奖励。 1234import numpy as npepisode_rewards = [play_montecarlo(env, agent) for _ in range(100)]print(&#x27;平均回合奖励 = &#123;&#125;&#x27;. format(np.mean(episode_rewards))) 小车上山环境有一个参考的回合奖励值 -110，如果连续 100 个回合的平均回合奖励大于 -110，则认为这个任务被解决了。espokeAgent 类对应的策略的平均回合奖励大概就在 -105 左右。 测试智能体在 Gym 库中某个任务的性能时学术界一般最关心 100 个回合的平均回合奖励，选这个数字完全是习惯使然。对于有些环境会指定一个参考的回合奖励值，当连续 100 个回合的奖励大于指定的值时，就认为这个任务被解决了。但并不是所有的任务都指定了这样的值。 总结一下 Gym 的用法：使用 env=gym.make(环境名) 取出环境，使用 env.reset() 初始化环境，使用 env.step(动作) 执行一步环境，使用 env.render() 显示环境，使用 env.close() 关闭环境。 1.8 关键词 强化学习 (reinforcement learning, RL)：智能体与复杂且不确定的环境进行交互时，尝试使所获得的奖励最大化的计算算法。 动作 (action)：环境接收到的智能体当前状态的输出。 状态 (state)：智能体从环境中获取到的状态。 奖励 (reward)：智能体从环境中获取的反馈信号，这个信号代表智能体在某一步采取某个策略以后是否得到奖励以及奖励的大小。 探索 (exploration)：在当前的情况下，继续尝试新的动作。智能体有可能会得到更高的奖励，也有可能一无所获。 规划 (planning)：在当前的情况下，使用已知的可以获得最大奖励的动作。 深度强化学习 (deep reinforcement learning)：不需要手工设计特征，仅需要输入状态让系统直接输出动作的一个端到端 (end-to-end) 的强化学习方法。通常使用神经网络来拟合价值函数 (value function) 或者策略网络 (policy network)。 全部可观测 (full observability)、完全可观测 (fully observed) 和部分可观测 (partially observed)：当智能体的状态与环境的状态等价时，称环境是全部可观测的；当智能体能够观察到环境的所有状态时，称环境是完全可观测的。智能体不能观察到环境的所有状态时，称环境是部分可观测的。 部分可观测马尔可夫决策过程 (partially observable Markov decision process, POMDP)：即马尔可夫决策过程的泛化。部分可观测马尔可夫决策过程依然具有马尔可夫性质，但是其假设智能体无法感知环境的状态，只能知道部分观测值。 动作空间 (action space)、离散动作空间 (discrete action space)、连续动作空间 (continuous action space)：在给定的环境中，有效动作的集合被称为动作空间，智能体的动作数量是有限的动作空间为离散动作空间，反之，则被称为连续动作空间。 基于策略的 (policy-based)：智能体会制定一套动作策略，即确定在给定状态下需要采取何种动作，并根据这个策略进行操作。强化学习算法直接对策略进行优化，使制定的策略能够获得最大的奖励。 基于价值的 (valued-based)：智能体不需要制定显式的策略，它维护一个价值表格或者价值函数，并通过这个价值表格或价值函数来选取价值最大的动作。 有模型结构 (model-based)：智能体通过学习状态的转移来采取措施。 免模型结构 (model-free)：智能体没有直接估计状态的转移，也没有得到环境的具体转移变量。它通过学习价值函数 (value function) 或者策略网络 (policy network) 进行决策。","categories":[{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"https://shymuel.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"【HEXO搭建个人网站】2 网站迁移到新电脑","slug":"【HEXO搭建个人网站】2 网站迁移到新电脑","date":"2021-08-29T08:32:00.000Z","updated":"2022-07-22T17:21:14.628Z","comments":true,"path":"200109796.html","link":"","permalink":"https://shymuel.top/200109796.html","excerpt":"","text":"将网站迁移到新电脑 安装nodejs和git for windows，npm中安装hexo：npm install -g hexo-cli。之后把博客文件夹从旧电脑复制过来即可。 为了上传，还要配置一下新电脑和github仓库之间的联系。这里还是放一个比较好的教程。","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://shymuel.top/tags/HEXO/"},{"name":"个人网站","slug":"个人网站","permalink":"https://shymuel.top/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}]},{"title":"【WPS】使用技巧","slug":"【WPS】使用技巧","date":"2021-08-14T10:43:49.000Z","updated":"2022-08-21T02:51:17.692Z","comments":true,"path":"3253309366.html","link":"","permalink":"https://shymuel.top/3253309366.html","excerpt":"","text":"1 公式中插入超过\\(3*3\\)的矩阵 ​ 恕我直言，WPS最新版这个公式属实邪门。用起来没有更方便，甚至都不能自己手动把界面下拉让用户能看到更多的选项…… ​ 今天遇到的问题是WPS自带的公式功能最大插入\\(3*3\\)矩阵，但我需要用到\\(1*7\\)的矩阵。方法是首先插入一个\\(1*3\\)​​的矩阵，然后选中整个矩阵（不包括括号），然后右键——插入——在此前插入列（或者在此后插入列），这样就可以突破原本的\\(3*3\\)的限制了……","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"文档编辑","slug":"文档编辑","permalink":"https://shymuel.top/tags/%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91/"}]},{"title":"【日文歌词】游戏王《Overlap》歌词（中日语+假名对照版）","slug":"【日文歌词】游戏王《Overlap》歌词（中日语+假名对照版）","date":"2021-08-03T07:52:32.000Z","updated":"2022-07-22T17:18:20.061Z","comments":true,"path":"abac2baf.html","link":"","permalink":"https://shymuel.top/abac2baf.html","excerpt":"","text":"本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。 かくせないほどまばゆいひかり せいじゃくやぶりこのよによみがえる 隠 せないほど眩 い光 静 寂 破 りこの世に甦 る 难以隐藏的炫目光芒 划破沉寂 在这世上苏醒 はげしいくゆらぐかわいただいち いのちをかけてひばなぶすけあう はげしいく揺らぐ渇 いた大 地 命 をかけて火花 ぶすけ合う 与剧烈震荡的干涸大地 不惜生命般摩擦出火花 もういちどだけでいい きせきおきてよ もう一 度だけでいい 奇跡 起きてよ 再一次就好 发生奇迹吧 かこになくしたきおくのページをとりもどすちからを 過去になくした記憶 のページを取り戻どすpower を 请给我能夺回过往失去的记忆书页的力量 やみをつらぬくしんじるこころたましいねむるばしょさがして 闇 を贯 ぬく信 じる心 魂 眠る 場所 探がして 坚信能冲破黑暗的心 寻找灵魂长眠之处 まばたきできない するどいがんこうをもやす 瞬 きできない 鋭 い眼 光 を燃やす 眼中燃起让人难以眨眼的锐利光芒 ひかりとかげのふたつのこころ くりすたるにうつるみらいへ 光 と影 の二 つの心 クリスタルに映 る未来 へ 光与暗的两颗心 一同前往水晶中映照的未来 いまうごきだす あかくみなぎるEYES 今 動き 出す 紅 く漲 るEYES 此刻开始行动 那涨红的双眼 たがいのきずをなめあうひびに おわりをつげて しずかにたちあがる 互 いの傷 を舐め合う日々に 终わりを告 て 静 かに立ち上がる 对互相舔舐伤口的时光 宣告终结 静静站起身来 ちいさなあかりともしたよるの きみとかわしたやくそくまもりぬく 小 さな明かり灯した 夜 の 君 と交 した約 束 守 り抜く 那微灯映照之夜 与你结下的约定 我会坚守到底 かすむしんきろうがきみをみせるよ 霞 む蜃 気楼 が君 を见せるよ 模糊的幻象之中 看见了你的身影 すすんださきになにがおきてもまけわしないかくごで 進 んだ先 に何 が掟 も負けわしない覚 悟で 无论前路上发生什么 我都会有绝不认输的觉悟 きせきはおこるしんじるこころ むかえにきたしょうりのめがみが 奇跡 は起こる信 じる心 迎 えに来た勝 利の女神 が 坚信能引发奇迹的心 胜利女神将迎接它的到来 すべてをたおすどんなかべにもひるまない 全 てを倒 すどんな壁 にも怯 まない 打倒一切敌人 不畏惧任何困难 まよいつづけるふたつのこころ いろあせることないせかいへ 迷 い続 ける二 つの心 色 褪せることない世界 へ 仍在迷惘的两颗心 一同前往永不黯淡的世界 いまかがやくよ かさなりあったEYES 今 輝 くよ 重 なりあったEYES 此刻绽放光芒 那重合的双眼 しずむたいようにつきがとけるよ 沈 む太 陽 に月 が溶けるよ 月亮融化在西沉的落日之中 かこになくしたきおくのページをとりもどすちからを 過去になくした記憶 のページを取り戻どすpower を 请给我能夺回过往失去的记忆书页的力量 やみをつらぬくしんじるこころたましいねむるばしょさがして 闇 を贯 ぬく信 じる心 魂 眠る 場所 探がして 坚信能冲破黑暗的心 寻找灵魂长眠之处 まばたきできない するどいがんこうをもやす 瞬 きできない 鋭 い眼 光 を燃やす 眼中燃起让人难以眨眼的锐利光芒 ひかりとかげのふたつのこころ くりすたるにうつるみらいへ 光 と影 の二 つの心 クリスタルに映 る未来 へ 光与暗的两颗心 一同前往水晶中映照的未来 いまうごきだす あかくみなぎるEYES 今 動き 出す 紅 く漲 るEYES 此刻开始行动 那涨红的双眼 かさなりあうEYES 重 なり合うEYES 那重合的双眼","categories":[{"name":"日语学习","slug":"日语学习","permalink":"https://shymuel.top/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://shymuel.top/tags/%E6%97%A5%E8%AF%AD/"},{"name":"日文歌","slug":"日文歌","permalink":"https://shymuel.top/tags/%E6%97%A5%E6%96%87%E6%AD%8C/"}]},{"title":"【Java】基础知识点总结","slug":"【Java】基础知识点总结","date":"2021-07-11T07:19:34.000Z","updated":"2022-07-22T17:22:55.588Z","comments":true,"path":"79803d5e.html","link":"","permalink":"https://shymuel.top/79803d5e.html","excerpt":"","text":"本文内容均来源于网络，如尚硅谷的免费视频课程、菜鸟教程和优质博客等；本文仅供学习交流使用。 初识Java Java发行版有多个后缀名，通常Java SE 开发桌面级应用；Java EE 开发web应用；Java ME运行在移动端； Java的应用：企业级应用；Android平台开发；大数据平台开发；移动领域应用； Java的特点： 一：面向对象。类，对象；封装，继承，多态； 二：健壮性；三：跨平台性，通过JVM虚拟机实现； 两个核心机制：虚拟机和垃圾回收机制； JDK：Java开发工具包，其中包含了JRE。其中有编译工具javac.exe和打包工具jar.exe。 JRE：Java运行环境，包括虚拟机和Java程序所需核心类库等。想运行一个开发好的Java程序，只安装JRE即可。 JDK的目录：bin，基本程序；db，数据库；include，头文件；lib，jar包；src，常用的类库和源码； 程序员编写.java 源文件，用javac.exe编译为.class 字节码文件，再用Java.exe运行； 编译运行java源文件： 12javac helloworld.java (加后缀)java helloworld （不加后缀） Java严格区分大小写，但是Windows路径不区分大小写； 注释分为单行注释、多行注释和文档注释；文档注释可被编译器编译，生成网页形式的说明文档； 12345/**@author 指定作者@version 指定源文件版本*/javadoc -d myHello -author -version HelloJava.java 一个源文件中可以写多个类，但最多只能有一个类声明为public，并且这个类得和.java文件同名。 编译时每个类单独生成一个class文件。 不知道学了多少遍的基础知识 变量相关 Java中有关键字和保留字。保留字现在还不是关键字但以后可能会是。 自己起的变量名叫标识符，注意不能用数字开头； 命名规范：包名全小写；类名接口名所有单词首字母大写；变量和方法名第一个单词首字母小写，后面开始大写；常量名全大写，单词之间用_连接；变量必须定义在作用域（{}）中； 声明long型变量以l或者L结尾； char中只能有一个字符，可以是转义字符； Unicode底层字符，可以是如同'123'的字符；保存文件的时候用ANSI编码时，cmd可以输出中文； 类型之间的关系 byte、char、short同级，运算之后必须赋值给int类型的变量；强制类型转换时截断或者变成最小值； byte b+1编译不通过，因为默认常数是int型，小数是double型； string可以和boolean类型做运算，结果为后面连接一个true或者false； 进行赋值时，八进制用0开头，二进制0b开头，十六进制0x开头； 运算符 运算符分为算术、赋值、比较、逻辑、位运算、三元运算符； 取余运算的结果符号与被模数的符号相同。 自增1不会改变本身数据的类型（针对int，byte等类型）；Java支持连续赋值； +=不会改变变量本身的数据类型。 12345short s1 = 10;s1 += 2; // 可通过编译；int n = 10;n += (n++) + (++n); // 32 比较运算符结果都是Boolean型； instanceof()：检查是否是类的对象； &amp;&amp; 短路与；|| 短路或；^ 逻辑异或。短路运算符按顺序运行，如果左侧的表达式已知其值是true或者false，则右侧的表达式不会进行计算； 逻辑运算符只能适用于布尔类型变量； 位运算：直接对整数的二进制进行运算。&gt;&gt;&gt; 无符号右移（不管被移动数字是正还是负，最高位都用0补齐）；~取反运算； 使用位运算符交换两个变量的值： 123num1 = num1 ^ num2;num2 = num1 ^ num2;num1 = num1 ^ num2; 单目运算符、三元运算符、赋值运算符都是从右向左计算；这导致a?b:c?d:e 等价于 a?b:(c?d:e) 而不是 (a?b:c)?d:e Java程序在控制台进行交互 从键盘获取不同类型变量：使用Scanner类； 1234567import java.util.Scanner;Scanner scan = new Scanner(System.in);int num = scan.nextInt();string: scan.next();scan.nextDouble();scan.nextBoolean(); char型没有单独的输入方式，可以用读取字符串的方式读入，再从中取出某一位： 1234567Math.sqrt(i);String s = readKeyBoard(i); // 从键盘读入一个长度i的字符串s.tpUpperCase(); // 变成大写s.charAt(i); // 可以取出某个位置的字符(int)(Math.random()*90+10); // random产生0到1的随机数 switch后面的表达式类型可以是：byte，short，char，int，枚举类型，string 123456int[] x，y[]; // x是一维数组，y是二维数组；// 此时x代表一个对象（Java和C不同）y[0] = x; // yesarray2 = array1; // 即可完成数组的复制，注意这个时候array2和array1指向同一个位置，改array2，array1也会改变// 正确的数组复制需要new一个数组，逐个赋值 Java的string可以很长。 数组 数组的元素可以是基本或者引用数据类型；数组长度定好之后不能修改！ 123456//静态初始化int[] ids;ids = new in[]&#123;1,2,3&#125;;ids = &#123;1,2,3&#125;;//动态初始化String[] names = new String[4]; 数组元素是引用数据类型则默认值是null； arrays工具类的使用： 12345boolean equals(int[] a, int[] b); //判断两个数组是否相等String toString(int[] a); //输出数组信息void fill(int[] a, int val); //指定值填充到数组中void sort(int[] a); //排序int binarySearch(int[] a, int key); //对排序后的数组进行二分法检索指定的值 数组如果没有赋值会报空指针错误，null； 新建变量的存储位置 栈中：存放局部变量；堆中：new出来的对象和数组； string：常量池中；static类型的变量：保存在静态域中； 12String[][] arr2 = new String[3][2];String[][] arr3 = new String[3][]; Java面向对象 Java类及类的成员包含的“内容”：属性，方法，构造器； 其中有些特殊的成员：代码块，内部类 面向对象的三大特性：封装，继承，多态。有些人还命名的其他特性如抽象性。 类和对象 类的成员：属性（成员变量），行为（方法函数）。 属性直接定义在类的{}里，局部变量在方法等的内部； 局部变量不能加修饰符（除了final）。非static属性是类的每个对象都有一套。 小tips：alt+左箭头可以快速到函数定义位置或返回 如果要使用对象的方法，哪怕是在对象内部使用也要new一个对象； 四舍五入取整：Math.round(double d)；非对象语言和Java交互的时候依然表现为对象； 引用数据类型在使用的时候其变量名都是代表地址值； 匿名对象的使用（每次都重新创建一个对象）： 12new phone().sendEmail();mall.show(mew phone()); 函数的值传递机制： 参数是基本数据类型，实参赋给形参的是他储存的真实数据值； 参数是引用数据类型，形参得到的是变量所保存的数据的地址值。 1println(char[] x); //直接输出了char数组 重载 重载两同一不同：同一个类，相同方法名；参数列表不同：参数个数或者类型不同； 返回值相同或者不同都可以构成重载； 可变个数形参的方法：public void show(String ... strs)；即“数据类型 ... 数据名”的形式；参数数量可以是0个。 需要注意可变个数形参的方法与把数组作为参数的方法不构成重载； 可变个数形参必须放在最后；重载的函数中最多声明一个可变个数形参； 类的封装和隐藏 把类的属性声明成private，则类外不能直接调用属性；只能通过方法如setlegs，getlegs. 封装性的体现需要权限修饰符来配合：private，缺省，protected，public（从小到大）。 属性体现封装性，类也可以体现封装性； 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes default yes yes protected yes yes yes public yes yes yes yes 有四种权限修饰符可以修饰类和类的内部结构。class的权限只可以用public和default； 不同的包可以定义重名类。 构造器：功能是创建对象，实际使用中和类同名。不显式定义则默认提供一个空参的构造器。构造器严格来说不是方法，可以重载。 属性赋值的先后顺序：默认，显式初始化，构造器中赋值，调用属性进行赋值。 Javabean：特殊的java类。类是公共的，有一个无参的公共的构造器，有属性，有对应的get，set方法；可重用组件。 默认构造器的权限和其所在的类相同。 在开发过程中，为了清晰的显示类和类之间的关系，可以使用UML类图。 this和import的使用 方法内部用，则表示对该方法对象的引用；构造器内部使用，表示构造器正在初始化的对象； this表示当前对象，可以修饰方法，属性； 类的方法中可以使用this.属性或this.方法，构造器中也可以this修饰方法和属性； this调用构造器：this(args)，主要是为了减少构造器中的冗余代码；自始至终对象只有一个；this(args)必须声明在当前构造器首行，构造器内部最多只能调用一个其他构造器； ALT+SHITF+S 调出代码生成器 package：更好的管理类，声明类或者接口属于的包，放在首行； MVC设计模式：M模型处理数据，V视图显示数据，C控制处理业务逻辑； import：在源文件中使用import导入指定包下的类和接口；声明在包和类的声明之间；import xxx.*导入其下所有内容，但是不包含其中的子包； import static：导入类或接口中的静态结构，同时import static的结尾一定是.* 持续更新ing","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://shymuel.top/tags/Java/"},{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"【HEXO搭建个人网站】1 基础知识","slug":"【HEXO搭建个人网站】1 基础知识","date":"2021-07-11T04:56:11.000Z","updated":"2022-07-22T17:22:03.701Z","comments":true,"path":"b077d8cb.html","link":"","permalink":"https://shymuel.top/b077d8cb.html","excerpt":"","text":"环境搭建 首先安装node.js，直接官网下载安装。接着安装git for windows，直接官网安装（访问官网及后续安装搞个梯子会方便很多）。安装之后用下述语句查看版本以确认安装成功。 123git versionnode -vnpm -v 新建一个文件夹用于存放博客相关的环境和内容配置，例如\"blog\"。在该文件夹中右击，选择\"Git bash here\"。安装HEXO： 123npm install hexo -g #安装Hexonpm update hexo -g #升级，可不进行hexo init #初始化博客 HEXO的常用指令如下（这些指令均要在上面创建的blog文件夹路径下运行）： 1234567891011hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章hexo g == hexo generate # 生成hexo s == hexo server # 启动服务预览（安装hexo之后直接就可以进行）hexo d == hexo deploy # 部署到GitHub（需要预先与GitHub进行连接）# 上面的几条语句，使用的时候输入&quot;==&quot;前面的部分就可以了。hexo server # Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s # 静态模式hexo server -p 5000 # 更改端口hexo server -i 192.168.1.1 # 自定义 IPhexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令 这样就可以在本地预览网站效果。为了能在其他设备上访问自己的网站，我选择GitHub托管自己的数据。 具体的操作是在GitHub上建立仓库，然后配置权限让自己可以把blog的内容直接部署到GitHub上。上传成功之后就可以用仓库的名称来访问博客，如我的是\"shymuel.github.io\"。但github的后缀容易被墙，我的解决方法是自己购买一个域名。国内域名需要实名审核但比较保险，大家可以自行选择合适的域名商。 Volantis主题使用 HEXO使用量最大的主题大概就是NexT了，它的功能十分强大，看起来也比较简洁。 我为了看起来更加的二次元而选择了Volantis主题，主要是为了使用它的定时换背景功能（因为我有太多壁纸想放上去了）。图片目前我还是放在本地，采用相对路径。后面抽空研究一下如何使用CDN实现图片读取。 Volantis自带文章目录功能，可根据md文件中的标题在网页一侧生成目录。 配置背景图、头像之类的需要在blog文件夹下新建名为\"_config.volantis.yml\"的文件进行配置。建议按照主题文档进行。 对于字数统计和阅读时长显示，先要安装wordcount插件： 1npm i --save hexo-wordcount 之后可以通过主题配置文件里的 word_count 关键字来选择是否开启此功能，默认false。在配置文件的enable后面加上true。 Twikoo评论插件 根据官方文档进行配置。我选择的是Vercel部署方式。原开发者做了非常非常详细的视频教程。我把_config.volantis.yml中关于评论的设置改成了如下的样子： 1234567891011121314151617twikoo: js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本 path: # 全局评论地址 # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项 envId: https://twikoo-dusky.vercel.app/ # vercel id appId: # your appId appKey: # your appKey meta: [nick,mail,link] # valine comment header info requiredFields: [nick,mail] enableQQ: true # Unstable avatar link recordIP: false # Record commenter IP avatar: img/avatar.jpg # gravatar style https://valine.js.org/avatar pageSize: 10 # comment list page size lang: zh-cn highlight: true mathJax: false 部署之后还可以根据自己的需求，下载密钥设置管理员密码来对评论系统进行管理和定制。 暗黑模式 按照_config.volantis.yml中的描述，修改navbar目录，在menu子目录中添加： 123- name: 暗黑模式 # 可自定义 icon: fas fa-moon # 可自定义 toggle: darkmode 自动生成文章的唯一永久链接 使用abbrlink生成。首先下载abbrlink。 1npm install hexo-abbrlink --save 之后修改根目录站点配置文件config.yml，改为： 1234url: https://自己的网址名/permalink: :abbrlink.htmlabbrlink: alg: crc32 #算法： crc16(default) and crc32 之后hexo三连即可。 插入LateX公式 更换渲染工具为 hexo-renderer-pandoc： 123npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-pandoc --save 安装 hexo-math 插件以支持 latex 公式： 1npm install hexo-math --save volantis主题的话，在_config.volantis.yml中把mathjax后面改成true即可。注意要clean之后重新生成，latax公式才能正常显示。 记得要在有公式的博客开头加上： 1mathjax: true","categories":[{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://shymuel.top/tags/HEXO/"},{"name":"个人网站","slug":"个人网站","permalink":"https://shymuel.top/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"}]},{"title":"新的开始","slug":"新的开始","date":"2021-06-26T12:44:43.000Z","updated":"2021-08-03T10:37:16.000Z","comments":true,"path":"b585e161.html","link":"","permalink":"https://shymuel.top/b585e161.html","excerpt":"","text":"最后还是回来写代码了……感觉传统工科的老师都在搞机器学习，那我也没有办法，只能重新回来刷题。 这个博客上的内容可能会写的支离破碎一些，毕竟现在都在做各种项目，也不可能把全部的代码放上来，大概只是记录一下自己能做到什么功能吧，核心代码也会放一些。","categories":[{"name":"日志","slug":"日志","permalink":"https://shymuel.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://shymuel.top/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://shymuel.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"日语学习","slug":"日语学习","permalink":"https://shymuel.top/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"日志","slug":"日志","permalink":"https://shymuel.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"模电","slug":"模电","permalink":"https://shymuel.top/tags/%E6%A8%A1%E7%94%B5/"},{"name":"软件使用","slug":"软件使用","permalink":"https://shymuel.top/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"代码管理","slug":"代码管理","permalink":"https://shymuel.top/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"},{"name":"编程语言","slug":"编程语言","permalink":"https://shymuel.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://shymuel.top/tags/Python/"},{"name":"C++","slug":"C","permalink":"https://shymuel.top/tags/C/"},{"name":"日语","slug":"日语","permalink":"https://shymuel.top/tags/%E6%97%A5%E8%AF%AD/"},{"name":"日文歌","slug":"日文歌","permalink":"https://shymuel.top/tags/%E6%97%A5%E6%96%87%E6%AD%8C/"},{"name":"文档编辑","slug":"文档编辑","permalink":"https://shymuel.top/tags/%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91/"},{"name":"安利","slug":"安利","permalink":"https://shymuel.top/tags/%E5%AE%89%E5%88%A9/"},{"name":"优秀网站","slug":"优秀网站","permalink":"https://shymuel.top/tags/%E4%BC%98%E7%A7%80%E7%BD%91%E7%AB%99/"},{"name":"强化学习","slug":"强化学习","permalink":"https://shymuel.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"https://shymuel.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"HEXO","slug":"HEXO","permalink":"https://shymuel.top/tags/HEXO/"},{"name":"个人网站","slug":"个人网站","permalink":"https://shymuel.top/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"name":"Java","slug":"Java","permalink":"https://shymuel.top/tags/Java/"},{"name":"随笔","slug":"随笔","permalink":"https://shymuel.top/tags/%E9%9A%8F%E7%AC%94/"}]}