<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Latex语法记录</title>
      <link href="/2021361885.html"/>
      <url>/2021361885.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.overleaf.com/learn/latex/Creating_a_document_in_LaTeX">Overleaf的LaTex教程</a></p><p><a href="https://latex.codecogs.com/eqneditor/editor.php">包含基本上所有Latex小语法的网站</a></p><p><a href="https://www.latexlive.com/">在线Latex公式编辑器（界面比第二个网站更好看）</a></p><h2 id="给字母加奇怪的东西">给字母加奇怪的东西</h2><h3 id="pmb字母加粗">\pmb{}，字母加粗</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\pmb&#123;x&#125;, \ \pmb&#123;X&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\pmb{x}, \ \pmb{X}\)</span></p><h3 id="hat头顶加小尖角">\hat{}，头顶加小尖角</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hat&#123;\gamma&#125;_&#123;j k&#125;=\frac&#123;\alpha_&#123;k&#125; \phi\left(y_&#123;j&#125; \mid \theta_&#123;k&#125;\right)&#125;&#123;\sum_&#123;k=1&#125;^&#123;R&#125; \alpha_&#123;k&#125; \phi\left(y_&#123;j&#125; \mid \theta_&#123;k&#125;\right)&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\hat{\gamma}_{j k}=\frac{\alpha_{k} \phi\left(y_{j} \mid \theta_{k}\right)}{\sum_{k=1}^{R} \alpha_{k} \phi\left(y_{j} \mid \theta_{k}\right)}\)</span></p><h2 id="各种括号和方框">各种括号和方框</h2><h3 id="begincases多种情况的表示">\begin{cases}，多种情况的表示</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\gamma_&#123;j k&#125;= \begin&#123;cases&#125;1, &amp; \text &#123; 第 &#125; j \text &#123; 个观测来自第 &#125; k \text &#123; 个分模型 &#125; \\ 0, &amp; \text &#123; 否则 &#125;\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\gamma_{j k}= \begin{cases}1, &amp; \text { 第 } j \text { 个观测来自第 } k \text { 个分模型 } \\ 0, &amp; \text { 否则 }\end{cases}\)</span></p><h3 id="beginarray方程组">\begin{array}，方程组</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left\&#123;\begin&#123;array&#125;&#123;l&#125;\mathrm&#123;e&#125;^&#123;-x_&#123;1&#125;&#125;+\mathrm&#123;e&#125;^&#123;-2 x_&#123;2&#125;&#125;+x_&#123;3&#125;-2 x_&#123;4&#125;+t_&#123;k&#125; x_&#123;5&#125;-5.3=0 \\ \mathrm&#123;e&#125;^&#123;-2 x_&#123;1&#125;&#125;+\mathrm&#123;e&#125;^&#123;-x_&#123;2&#125;&#125;-2 x_&#123;3&#125;+t_&#123;k&#125; x_&#123;4&#125;-x_&#123;5&#125;+25.6=0 \\ t_&#123;k&#125; x_&#123;1&#125;+3 x_&#123;2&#125;+\mathrm&#123;e&#125;^&#123;-x_&#123;3&#125;&#125;-3 x_&#123;5&#125;+37.8=0 \\ 2 x_&#123;1&#125;+t_&#123;k&#125; x_&#123;2&#125;+x_&#123;3&#125;-\mathrm&#123;e&#125;^&#123;-x_&#123;4&#125;&#125;+2 \mathrm&#123;e&#125;^&#123;-2 x_&#123;5&#125;&#125;-31.3=0 \\ x_&#123;1&#125;-2 x_&#123;2&#125;-3 t_&#123;k&#125; x_&#123;3&#125;+\mathrm&#123;e&#125;^&#123;-2 x_&#123;4&#125;&#125;+3 \mathrm&#123;e&#125;^&#123;-x_&#123;5&#125;&#125;+42.1=0\end&#123;array&#125;\right.</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\left\{\begin{array}{l}\mathrm{e}^{-x_{1}}+\mathrm{e}^{-2 x_{2}}+x_{3}-2 x_{4}+t_{k} x_{5}-5.3=0 \\ \mathrm{e}^{-2 x_{1}}+\mathrm{e}^{-x_{2}}-2 x_{3}+t_{k} x_{4}-x_{5}+25.6=0 \\ t_{k} x_{1}+3 x_{2}+\mathrm{e}^{-x_{3}}-3 x_{5}+37.8=0 \\ 2 x_{1}+t_{k} x_{2}+x_{3}-\mathrm{e}^{-x_{4}}+2 \mathrm{e}^{-2 x_{5}}-31.3=0 \\ x_{1}-2 x_{2}-3 t_{k} x_{3}+\mathrm{e}^{-2 x_{4}}+3 \mathrm{e}^{-x_{5}}+42.1=0\end{array}\right.\)</span></p><p>既可以用来表示矩阵，也可以用来表示方程……</p><h2 id="数学表达式">数学表达式</h2><h3 id="根式">根式</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sqrt[]&#123;&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\sqrt[n]{x+1}\)</span></p><h3 id="集合相关">集合相关</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$\exists$</span><br><span class="line">$\forall$</span><br><span class="line">$\neg$</span><br><span class="line">$\wedge$</span><br><span class="line">$\vee$ </span><br></pre></td></tr></table></figure><p><span class="math inline">\(\exists,\ \forall, \ \neg, \ \wedge,\  \vee\)</span></p><h2 id="latex中的数学字体">LaTex中的数学字体</h2><p>有些字体需要在序言中引入特定的包：<code>\usepackage&#123;amssymb&#125;</code></p><p>有些字体支持一部分字符：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">RQSZ \\</span><br><span class="line">\mathcal&#123;RQSZ&#125; \\</span><br><span class="line">\mathfrak&#123;RQSZ&#125; \\</span><br><span class="line">\mathbb&#123;RQSZ&#125;</span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\begin{align*} RQSZ \\ \mathcal{RQSZ} \\ \mathfrak{RQSZ} \\ \mathbb{RQSZ} \end{align*}\)</span></p><p>手写体，哥特黑体，黑板粗体。</p><p>也可以将整个数学表达式的字体更换为另外一种：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">3x^2 \in R \subset Q \\</span><br><span class="line">\mathrm&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathit&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathbf&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathsf&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathtt&#123;3x^2 \in R \subset Q&#125; </span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\begin{align*}3x^2 \in R \subset Q \\ \mathrm{3x^2 \in R \subset Q} \\ \mathit{3x^2 \in R \subset Q} \\ \mathbf{3x^2 \in R \subset Q} \\ \mathsf{3x^2 \in R \subset Q} \\ \mathtt{3x^2 \in R \subset Q} \end{align*}\)</span></p><p><code>\mathnormal&#123;3x^2 \in R \subset Q&#125;</code>理论上这也是一种字体，和默认字体一样的，但是hexo的渲染器会报错，就没有放上去了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文编辑 </tag>
            
            <tag> 学习和工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用软件及网站分享</title>
      <link href="/2675119176.html"/>
      <url>/2675119176.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档编辑">文档编辑</h2><p>WPS，一直开会员，云文档功能yyds。</p><h2 id="笔记软件">笔记软件</h2><p>为知笔记。旧版和X版我都在用，笑死，已经变成为知笔记的形状了，一年60块买不了吃亏买不了上当。我现在写博客都是在为知笔记写完然后导出成Markdown。</p><h2 id="论文阅读">论文阅读</h2><p>单纯看PDF的话WPS也能满足需求，但WPS是不提供文献管理功能的，批注功能也弱了点。今天发现一个叫IvySci的软件，中文名青藤学术，竟然还是个国产软件……well，再用一段时间再来评价，目前用免费版，收费版也不贵，但收费之后的空间确实小了点，看得出小公司没那么有钱……目前最吸引我的功能是软件内用各种引擎查论文，以及一键把论文中的引用文献加入项目。但它现在有个问题是</p><h2 id="论文搜索">论文搜索</h2><p>之前一直用学校的网在SCI上查，最近觉得还是谷歌学术牛牛。但是懒得开科学上网的话，<a href="https://gfsoso.99lb.net/">谷粉学术</a>挺好用的，也可以去用<a href="https://ac.scmor.com/">镜像</a>。</p><h2 id="公式生成">公式生成</h2><p>Mathpix Snipping Tool，截图生成公式，中文也能识别。我自己用的时候哪怕是扫描版的书，基本上也能把公式识别出来。</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
            <tag> 学习和工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习笔记（一） 强化学习概述</title>
      <link href="/4072327491.html"/>
      <url>/4072327491.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章为笔者学习网络上的强化学习教程之后的笔记，在原文和自己理解的基础上重新写作而成，基本可以认为是原文的精简版，后续可能会在阅读其他教材之后在对应章节添加例子等。<a href="https://github.com/datawhalechina/easy-rl">原教程地址</a></p></blockquote><p><a href="https://datawhalechina.github.io/easy-rl/#/chapter1/chapter1">第一章原文链接</a></p><p>强化学习解决的是一个智能体如何在一个复杂不确定的环境里极大化它能获得的奖励。</p><p>在环境（environment）中，智能体（agent）进行各种动作（action）产生某种状态（state），据此环境给出奖励（reward）。这里的奖励是延迟奖励，即行为的进行到奖励的求得之间往往又隔了一些动作。</p><p>强化学习的一些特征：有试错探索（trial-and-error exlporation），探索环境来获取对环境的理解；从环境中得到延迟的奖励；每个动作在时间上是连续的；agent的行为会影响之后的数据。</p><p>举一个雅达利pong游戏的例子：一块板子往上或者往下，把弹球弹到对面。整个游戏过程是rollout的，即从当前帧可以生成很多局游戏。agent和环境交互会产生很多观测，每个观测是一个轨迹（trajectory）。轨迹是当前帧以及他采取的策略，即状态和动作的一个序列：<span class="math inline">\(\tau =(s_0,a_0,s_1,a_1, \dots )\)</span></p><p>一场游戏叫做一个episode或者trial。</p><p>最近把强化学习和深度学习结合起来，成为深度强化学习。</p><p>几个小项目吧，学走路，穿衣服。一般先在虚拟环境取得不错的效果，然后再上机械臂。</p><h2 id="序列决策过程">序列决策过程</h2><p>agent的目的是从观测之中学到能极大化奖励的策略。要进行近期奖励和远期奖励的一个平衡，最终一般希望获得更多的长期奖励。</p><p>历史是观测、行为、奖励的序列： Ht = O1, R1, A1,..., At-1,...</p><p>agent在采取动作的时候依赖于它的历史，可以把整个游戏的状态看成这个历史的函数：St=f(Ht)</p><p>状态S是对世界的完整描述，不隐藏信息；观测O是部分描述。deep RL中一般用实值的向量、矩阵或张量来表示状态和观测。</p><p>agent的状态和环境的状态等价：完全可观测；MDP问题。在这个问题中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O_t=S^e_t=S^a_t</span><br></pre></td></tr></table></figure><p>否则就是部分可观测的。这是POMDP问题。部分可观测马尔科夫决策过程。POMDP是一个马尔科夫决策过程的繁华，具有马尔科夫性质，但假设智能体无法感知环境的状态S，只知道部分观测值O。</p><p>用一个七元组描述：(S, A, T, R, Ω, O, γ). S是状态空间，隐变量；A是动作空间，T是状态转移概率，R是奖励函数；Ω是观测概率，O为观测空间，γ为折扣系数。</p><h4 id="动作空间">动作空间</h4><p>有效动作的集合被称为动作空间。离散动作空间，动作数量有限；连续动作空间，动作种类无限，此时动作是实值的向量。</p><h2 id="强化学习agent的组成">强化学习agent的组成</h2><p>策略函数policy func：用这个函数来选取下一步的动作；</p><p>价值函数value func：对当前状态估价；</p><p>model：表示agent对这个环境的状态进行的理解，这一点决定这个世界如何运行。</p><h4 id="policy">Policy</h4><p>stochastic policy随机性策略：输入一个状态s，输出是一个概率。进一步对概率进行采样，可以得到一个action。</p><p>deterministic policy确定性策略：进行一个极大化处理，只进行概率最大的action。</p><p>对于Atari游戏，策略函数的输入就是游戏的一帧，他的输出决定往左或者往右。通常采用随机性策略，因为其动作具有多样性。</p><h4 id="value-function-价值函数">Value Function 价值函数</h4><p>未来奖励的一个预测，用来评估状态的好坏。</p><p>价值函数里有一个discount factor折扣因子。我们希望在尽可能短的时间里得到尽可能多的奖励。价值函数的定义其实是一个期望，Eπ，这个函数表明我们已知某一个策略函数的时候，到底可以得到多少奖励。</p><p>还有一种价值函数叫Q函数，包含两个变量状态和动作。</p><h4 id="模型">模型</h4><p>模型决定了下一个状态会是什么样的。它由两个部分你组成： 概率：状态之间如何转移；奖励函数：当在当前状态进行了某个行为，可以得到多大的奖励。</p><p>有了上述三个部分之后，就得到了一个马尔科夫决策过程。这个过程可视化了状态之间的转移以及行为。</p><h4 id="例子-走迷宫">例子-走迷宫</h4><p>要求agent从start开始，走到goal的位置，每走一步会得到-1的奖励。可以采取的动作是往上下左右走。</p><p>可以采用不同的强化学习算法来解题： 基于策略的RL，学习完环境之后，每个状态都会得到一个最佳的行为。 基于价值的RL，用价值函数作为导向，可以得到另外一种表征。</p><h2 id="types-of-rl-agents">types of RL agents</h2><p>基于价值的agent：显式学习价值函数，隐式学习策略。 基于策略的agent：直接学习策略，没有学习价值函数。</p><p>二者结合得到actor-critic agent，策略函数和价值函数都学习，然后通过两者交互得到一个最佳行为。</p><p>基于策略迭代和基于价值迭代的强化学习方法有什么区别？ 对一个状态转移概率已知的马尔科夫决策过程，可以用动态规划算法求解。决策方式来看，可以分为基于策略迭代的方法和基于价值迭代的方法。决策方式是静态的，不随状态变化而变化。</p><p>基于策略迭代的强化学习中，智能体会制定一套动作策略以确定给定状态下采取何种动作，并根据这个策略操作。有策略梯度算法等。</p><p>基于价值迭代的方法则维护一个价值表格或函数。只能应用在不连续、离散的环境下。基于价值迭代的有Q-learning，Sarsa等。</p><h4 id="根据有没有学习环境模型分类">根据有没有学习环境模型分类</h4><p>model-based有模型：通过学习状态的转移采取动作； model-free无模型：不直接估计状态的转移，也没得到环境的具体转移变量，学习价值和策略函数进行决策。</p><p>智能体知道状态转移函数和奖励函数后，智能体就不需要在真实环境中采取动作，直接在虚拟环境下学习即可，这种事有模型学习。无模型就是用实物参与训练的意思。</p><h2 id="learning-and-planning">Learning and Planning</h2><p>强化学习中，环境初始时是未知的，agent不知道环境如何工作，不断交互后改进策略。</p><p>planning是进行学习前对环境的建模。常用的强化学习解决问题思路是：先学习环境如何工作，得到一个模型，然后利用这个模型进行规划。（数学建模的感觉……）</p><h2 id="探索和利用">探索和利用</h2><p>探索是说怎么探索环境，即找到能获得最大奖励的策略。利用是说不去尝试新的东西，仅靠已知就可以得到很大奖励的行为。</p><h2 id="k-armed-bandit-k-臂赌博机">K-armed Bandit K-臂赌博机</h2><p>与监督学习的区别有一点是RL的最终奖赏在多步学习之后才能观察到。 一种简单策略：最大化单步奖励。此时强化学习仍与监督学习不同，因为机器需要通过尝试发现各个动作产生的结果。需要考虑两个方面：知道每个动作带来的奖赏；执行奖赏最大的动作。 问题复杂之处在于，一个动作的奖赏通常来自一个概率分布而非确定值。</p><p>单步强化学习对应了K臂赌博机的模型。赌徒投入一个硬币后可选择按下一个摇臂，每个摇臂以一定的概率吐出金币但这个概率赌徒不知道。赌徒的目标是通过一定的策略最大化自己的奖赏。 若想获知每个摇臂的期望奖赏，则可采用仅探索法，将所有机会平均分配给每个摇臂，然后计算期望。 如果只想执行奖赏最大的动作，则可采用仅利用法，按下目前最优的摇臂。若有多个最优则随机选一个。 显然，在探索和利用之间，必须要达成一个较好的折中。</p><p>下面是一系列案例和资源网站。 似乎用的比较多的库是GYM。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO建站（二）</title>
      <link href="/200109796.html"/>
      <url>/200109796.html</url>
      
        <content type="html"><![CDATA[<h3 id="将网站迁移到新电脑">将网站迁移到新电脑</h3><p>安装nodejs和git for windows，npm中安装hexo：<code>npm install -g hexo-cli</code>。之后把博客文件夹从旧电脑复制过来即可。</p><p>为了上传，还要配置一下新电脑和github仓库之间的联系。这里还是放一个比较好的<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">教程</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 个人网站 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPS使用技巧记录</title>
      <link href="/3253309366.html"/>
      <url>/3253309366.html</url>
      
        <content type="html"><![CDATA[<h3 id="公式中插入超过33的矩阵">公式中插入超过<span class="math inline">\(3*3\)</span>的矩阵</h3><p>​ 恕我直言，WPS最新版这个公式属实邪门。用起来没有更方便，甚至都不能自己手动把界面下拉让用户能看到更多的选项…… ​ 今天遇到的问题是WPS自带的公式功能最大插入<span class="math inline">\(3*3\)</span>矩阵，但我需要用到<span class="math inline">\(1*7\)</span>的矩阵。方法是首先插入一个<span class="math inline">\(1*3\)</span>​​的矩阵，然后选中整个矩阵（不包括括号），然后右键——插入——在此前插入列（或者在此后插入列），这样就可以突破原本的<span class="math inline">\(3*3\)</span>的限制了……</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏王-Overlap歌词（中日语+假名对照版）</title>
      <link href="/abac2baf.html"/>
      <url>/abac2baf.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。</p></blockquote><p>かくせないほどまばゆいひかり　せいじゃくやぶりこのよによみがえる</p><p>隠　せないほど眩　　い光　　　静　寂　　破　りこの世に甦　　　る</p><p>难以隐藏的炫目光芒　　　　　　划破沉寂　　　　在这世上苏醒</p><p>はげしいくゆらぐかわいただいち　いのちをかけてひばなぶすけあう</p><p>はげしいく揺らぐ渇　いた大　地　命　　をかけて火花　ぶすけ合う　</p><p>与剧烈震荡的干涸大地　　　　　　不惜生命般摩擦出火花</p><p>もういちどだけでいい　きせきおきてよ</p><p>もう一　度だけでいい　奇跡　起きてよ</p><p>再一次就好　　　　　　发生奇迹吧</p><p>かこになくしたきおくのページをとりもどすちからを</p><p>過去になくした記憶　のページを取り戻どすpower を</p><p>请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして　</p><p>闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして</p><p>坚信能冲破黑暗的心　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす</p><p>瞬　　きできない　鋭　　い眼　光　を燃やす</p><p>眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ</p><p>光　　と影　の二　つの心　　　クリスタルに映　る未来　へ</p><p>光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES</p><p>今　動き　出す　紅　く漲　　るEYES</p><p>此刻开始行动　　那涨红的双眼</p><hr /><p>たがいのきずをなめあうひびに　おわりをつげて　しずかにたちあがる</p><p>互　いの傷　を舐め合う日々に　终わりを告　て　静　かに立ち上がる</p><p>对互相舔舐伤口的时光　　　　　宣告终结　　　　静静站起身来</p><p>ちいさなあかりともしたよるの　きみとかわしたやくそくまもりぬく</p><p>小　さな明かり灯した　夜　の　君　と交　した約　束　守　り抜く</p><p>那微灯映照之夜　　　　　　　　与你结下的约定　　　　我会坚守到底</p><p>かすむしんきろうがきみをみせるよ</p><p>霞　む蜃　気楼　が君　を见せるよ</p><p>模糊的幻象之中　　看见了你的身影</p><p>すすんださきになにがおきてもまけわしないかくごで</p><p>進　んだ先　に何　が掟　　も負けわしない覚　悟で</p><p>无论前路上发生什么　　　　　我都会有绝不认输的觉悟</p><p>きせきはおこるしんじるこころ　むかえにきたしょうりのめがみが</p><p>奇跡　は起こる信　じる心　　　迎　えに来た勝　　利の女神　が</p><p>坚信能引发奇迹的心　　　　　　胜利女神将迎接它的到来</p><p>すべてをたおすどんなかべにもひるまない　</p><p>全　てを倒　すどんな壁　にも怯　まない</p><p>打倒一切敌人　不畏惧任何困难</p><p>まよいつづけるふたつのこころ　いろあせることないせかいへ</p><p>迷　い続　ける二　つの心　　　色　褪せることない世界　へ</p><p>仍在迷惘的两颗心　　　　　　　一同前往永不黯淡的世界</p><p>いまかがやくよ　かさなりあったEYES</p><p>今　輝　　くよ　重　なりあったEYES</p><p>此刻绽放光芒　　那重合的双眼</p><p>しずむたいようにつきがとけるよ</p><p>沈　む太　陽　に月　が溶けるよ</p><p>月亮融化在西沉的落日之中</p><p>かこになくしたきおくのページをとりもどすちからを</p><p>過去になくした記憶　のページを取り戻どすpower を</p><p>请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして　</p><p>闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして</p><p>坚信能冲破黑暗的心　　　　　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす</p><p>瞬　　きできない　鋭　　い眼　光　を燃やす</p><p>眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ</p><p>光　　と影　の二　つの心　　　クリスタルに映　る未来　へ</p><p>光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES</p><p>今　動き　出す　紅　く漲　　るEYES</p><p>此刻开始行动　　那涨红的双眼</p><p>かさなりあうEYES</p><p>重　なり合うEYES</p><p>那重合的双眼</p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 日文歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识点总结</title>
      <link href="/79803d5e.html"/>
      <url>/79803d5e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容均来源于网络，如尚硅谷的免费视频课程、菜鸟教程和优质博客等；本文仅供学习交流使用。</p></blockquote><h2 id="初识java">初识Java</h2><p>Java发行版有多个后缀名，通常Java SE 开发桌面级应用；Java EE 开发web应用；Java ME运行在移动端；</p><p>Java的应用：企业级应用；Android平台开发；大数据平台开发；移动领域应用；</p><p>Java的特点： 一：面向对象。类，对象；封装，继承，多态； 二：健壮性；三：跨平台性，通过JVM虚拟机实现；</p><p>两个核心机制：虚拟机和垃圾回收机制；</p><p>JDK：Java开发工具包，其中包含了JRE。其中有编译工具javac.exe和打包工具jar.exe。 JRE：Java运行环境，包括虚拟机和Java程序所需核心类库等。想运行一个开发好的Java程序，只安装JRE即可。</p><p>JDK的目录：bin，基本程序；db，数据库；include，头文件；lib，jar包；src，常用的类库和源码；</p><p>程序员编写.java 源文件，用javac.exe编译为.class 字节码文件，再用Java.exe运行；</p><p>编译运行java源文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac helloworld.java  (加后缀)</span><br><span class="line">java helloworld  （不加后缀）</span><br></pre></td></tr></table></figure><p>Java严格区分大小写，但是Windows路径不区分大小写；</p><p>注释分为单行注释、多行注释和文档注释；文档注释可被编译器编译，生成网页形式的说明文档；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">javadoc -d myHello -author -version HelloJava.java</span><br></pre></td></tr></table></figure><p>一个源文件中可以写多个类，但最多只能有一个类声明为public，并且这个类得和.java文件同名。 编译时每个类单独生成一个class文件。</p><h2 id="不知道学了多少遍的基础知识"><del>不知道学了多少遍的</del>基础知识</h2><h4 id="变量相关">变量相关</h4><p>Java中有关键字和保留字。保留字现在还不是关键字但以后可能会是。 自己起的变量名叫<strong>标识符</strong>，注意不能用数字开头；</p><p>命名规范：包名全小写；类名接口名所有单词首字母大写；变量和方法名第一个单词首字母小写，后面开始大写；常量名全大写，单词之间用_连接；变量必须定义在作用域（{}）中；</p><p>声明long型变量以l或者L结尾； char中只能有一个字符，可以是转义字符； Unicode底层字符，可以是如同'123'的字符；保存文件的时候用ANSI编码时，cmd可以输出中文；</p><h4 id="类型之间的关系">类型之间的关系</h4><p>byte、char、short同级，运算之后必须赋值给int类型的变量；强制类型转换时截断或者变成最小值； byte b+1编译不通过，因为默认常数是int型，小数是double型； string可以和boolean类型做运算，结果为后面连接一个true或者false；</p><p>进行赋值时，八进制用0开头，二进制0b开头，十六进制0x开头；</p><h4 id="运算符">运算符</h4><p>运算符分为算术、赋值、比较、逻辑、位运算、三元运算符； 取余运算的结果符号与被模数的符号相同。</p><p>自增1不会改变本身数据的类型（针对int，byte等类型）；Java支持连续赋值； +=不会改变变量本身的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 += <span class="number">2</span>;  <span class="comment">// 可通过编译；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n);  <span class="comment">// 32</span></span><br></pre></td></tr></table></figure><p>比较运算符结果都是Boolean型； instanceof()：检查是否是类的对象；</p><p>&amp;&amp; 短路与；|| 短路或；^ 逻辑异或。短路运算符按顺序运行，如果左侧的表达式已知其值是true或者false，则右侧的表达式不会进行计算； 逻辑运算符只能适用于布尔类型变量；</p><p>位运算：直接对整数的二进制进行运算。&gt;&gt;&gt; 无符号右移（不管被移动数字是正还是负，最高位都用0补齐）；~取反运算；</p><p>使用位运算符交换两个变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure><p>单目运算符、三元运算符、赋值运算符都是从右向左计算；这导致a?b:c?d:e 等价于 a?b:(c?d:e) 而不是 (a?b:c)?d:e</p><h4 id="java程序在控制台进行交互">Java程序在控制台进行交互</h4><p>从键盘获取不同类型变量：使用Scanner类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> num = scan.nextInt();</span><br><span class="line">string: scan.next();</span><br><span class="line">scan.nextDouble();</span><br><span class="line">scan.nextBoolean();</span><br></pre></td></tr></table></figure><p>char型没有单独的输入方式，可以用读取字符串的方式读入，再从中取出某一位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(i);</span><br><span class="line"></span><br><span class="line">String s = readKeyBoard(i);  <span class="comment">// 从键盘读入一个长度i的字符串</span></span><br><span class="line">s.tpUpperCase();  <span class="comment">// 变成大写</span></span><br><span class="line">s.charAt(i);  <span class="comment">// 可以取出某个位置的字符</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span>)(Math.random()*<span class="number">90</span>+<span class="number">10</span>);  <span class="comment">// random产生0到1的随机数</span></span><br></pre></td></tr></table></figure><p>switch后面的表达式类型可以是：byte，short，char，int，枚举类型，string</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x，y[];  <span class="comment">// x是一维数组，y是二维数组；</span></span><br><span class="line"><span class="comment">// 此时x代表一个对象（Java和C不同）</span></span><br><span class="line">y[<span class="number">0</span>] = x; <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">array2 = array1;  <span class="comment">// 即可完成数组的复制，注意这个时候array2和array1指向同一个位置，改array2，array1也会改变</span></span><br><span class="line"><span class="comment">// 正确的数组复制需要new一个数组，逐个赋值</span></span><br></pre></td></tr></table></figure><p>Java的string可以很长。</p><h4 id="数组">数组</h4><p>数组的元素可以是基本或者引用数据类型；数组长度定好之后不能修改！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] ids;</span><br><span class="line">ids = <span class="keyword">new</span> in[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>数组元素是引用数据类型则默认值是null；</p><p>arrays工具类的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(int[] a, int[] b);  //判断两个数组是否相等</span><br><span class="line">String toString(int[] a);  //输出数组信息</span><br><span class="line">void fill(int[] a, int val);  //指定值填充到数组中</span><br><span class="line">void sort(int[] a);  //排序</span><br><span class="line">int binarySearch(int[] a, int key);  //对排序后的数组进行二分法检索指定的值</span><br></pre></td></tr></table></figure><p>数组如果没有赋值会报空指针错误，null；</p><h4 id="新建变量的存储位置">新建变量的存储位置</h4><p>栈中：存放局部变量；堆中：new出来的对象和数组； string：常量池中；static类型的变量：保存在静态域中；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] arr2 = new String[3][2];</span><br><span class="line">String[][] arr3 = new String[3][];</span><br></pre></td></tr></table></figure><h2 id="java面向对象">Java面向对象</h2><p>Java类及类的成员包含的“内容”：属性，方法，构造器； 其中有些特殊的成员：代码块，内部类 面向对象的三大特性：封装，继承，多态。有些人还命名的其他特性如抽象性。</p><h4 id="类和对象">类和对象</h4><p>类的成员：属性（成员变量），行为（方法函数）。</p><p>属性直接定义在类的{}里，局部变量在方法等的内部； 局部变量不能加修饰符（除了final）。非static属性是类的每个对象都有一套。</p><p><del>小tips：alt+左箭头可以快速到函数定义位置或返回</del></p><p>如果要使用对象的方法，哪怕是在对象内部使用也要new一个对象；</p><p>四舍五入取整：Math.round(double d)；非对象语言和Java交互的时候依然表现为对象；</p><p>引用数据类型在使用的时候其变量名都是代表地址值；</p><p>匿名对象的使用（每次都重新创建一个对象）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new phone().sendEmail();</span><br><span class="line">mall.show(mew phone()); </span><br></pre></td></tr></table></figure><p>函数的值传递机制： 参数是基本数据类型，实参赋给形参的是他储存的真实数据值； 参数是引用数据类型，形参得到的是变量所保存的数据的地址值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(char[] x); //直接输出了char数组</span><br></pre></td></tr></table></figure><h4 id="重载">重载</h4><p>重载两同一不同：同一个类，相同方法名；参数列表不同：参数个数或者类型不同； 返回值相同或者不同都可以构成重载；</p><p>可变个数形参的方法：public void show(String ... strs)；即“数据类型 ... 数据名”的形式；参数数量可以是0个。</p><p>需要注意可变个数形参的方法与把数组作为参数的方法不构成重载； 可变个数形参必须放在最后；重载的函数中最多声明一个可变个数形参；</p><h4 id="类的封装和隐藏">类的封装和隐藏</h4><p>把类的属性声明成private，则类外不能直接调用属性；只能通过方法如setlegs，getlegs. 封装性的体现需要权限修饰符来配合：private，缺省，protected，public（从小到大）。 属性体现封装性，类也可以体现封装性；</p><table><thead><tr class="header"><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr class="odd"><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr class="even"><td>default</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr class="odd"><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr class="even"><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>有四种权限修饰符可以修饰类和类的内部结构。class的权限只可以用public和default； 不同的包可以定义重名类。</p><p>构造器：功能是创建对象，实际使用中和类同名。不显式定义则默认提供一个空参的构造器。构造器严格来说不是方法，可以重载。</p><p>属性赋值的先后顺序：默认，显式初始化，构造器中赋值，调用属性进行赋值。</p><p>Javabean：特殊的java类。类是公共的，有一个无参的公共的构造器，有属性，有对应的get，set方法；可重用组件。</p><p>默认构造器的权限和其所在的类相同。</p><p>在开发过程中，为了清晰的显示类和类之间的关系，可以使用UML类图。</p><h4 id="this和import的使用">this和import的使用</h4><p>方法内部用，则表示对该方法对象的引用；构造器内部使用，表示构造器正在初始化的对象；</p><p>this表示当前对象，可以修饰方法，属性；</p><p>类的方法中可以使用this.属性或this.方法，构造器中也可以this修饰方法和属性；</p><p>this调用构造器：this(args)，主要是为了减少构造器中的冗余代码；自始至终对象只有一个；this(args)必须声明在当前构造器首行，构造器内部最多只能调用一个其他构造器；</p><p><del>ALT+SHITF+S 调出代码生成器</del></p><p>package：更好的管理类，声明类或者接口属于的包，放在首行；</p><p>MVC设计模式：M模型处理数据，V视图显示数据，C控制处理业务逻辑；</p><p>import：在源文件中使用import导入指定包下的类和接口；声明在包和类的声明之间；import xxx.*导入其下所有内容，但是不包含其中的子包；</p><p>import static：导入类或接口中的静态结构，同时import static的结尾一定是.*</p><p><del>持续更新ing</del></p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO和GitHub建站（一）</title>
      <link href="/b077d8cb.html"/>
      <url>/b077d8cb.html</url>
      
        <content type="html"><![CDATA[<h3 id="环境搭建">环境搭建</h3><p>首先安装node.js，直接官网下载安装。接着安装git for windows，直接官网安装（访问官网及后续安装搞个梯子会方便很多）。安装之后用下述语句查看版本以确认安装成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>新建一个文件夹用于存放博客相关的环境和内容配置，例如"blog"。在该文件夹中右击，选择"Git bash here"。安装HEXO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级，可不进行</span><br><span class="line">hexo init #初始化博客</span><br></pre></td></tr></table></figure><p>HEXO的常用指令如下（这些指令均要在上面创建的blog文件夹路径下运行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章</span><br><span class="line">hexo g == hexo generate # 生成</span><br><span class="line">hexo s == hexo server # 启动服务预览（安装hexo之后直接就可以进行）</span><br><span class="line">hexo d == hexo deploy # 部署到GitHub（需要预先与GitHub进行连接）</span><br><span class="line"># 上面的几条语句，使用的时候输入&quot;==&quot;前面的部分就可以了。</span><br><span class="line"></span><br><span class="line">hexo server # Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s # 静态模式</span><br><span class="line">hexo server -p 5000 # 更改端口</span><br><span class="line">hexo server -i 192.168.1.1 # 自定义 IP</span><br><span class="line">hexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure><p>这样就可以在本地预览网站效果。为了能在其他设备上访问自己的网站，我选择GitHub托管自己的数据。</p><p>具体的操作是在GitHub上建立仓库，然后配置权限让自己可以把blog的内容直接部署到GitHub上。上传成功之后就可以用仓库的名称来访问博客，如我的是"shymuel.github.io"。但github的后缀容易被墙，我的解决方法是自己购买一个域名。国内域名需要实名审核但比较保险，大家可以自行选择合适的域名商。</p><h3 id="volantis主题使用">Volantis主题使用</h3><p>HEXO使用量最大的主题大概就是<a href="http://theme-next.iissnan.com/getting-started.html">NexT</a>了，它的功能十分强大，看起来也比较简洁。</p><p>我为了看起来更加的二次元而选择了<a href="https://volantis.js.org/v5/getting-started/">Volantis</a>主题，主要是为了使用它的定时换背景功能（因为我有太多壁纸想放上去了）。图片目前我还是放在本地，采用相对路径。后面抽空研究一下如何使用CDN实现图片读取。</p><p>Volantis自带文章目录功能，可根据md文件中的标题在网页一侧生成目录。</p><p>配置背景图、头像之类的需要在blog文件夹下新建名为"_config.volantis.yml"的文件进行配置。建议按照<a href="https://volantis.js.org/v5/theme-settings/">主题文档</a>进行。</p><p>对于字数统计和阅读时长显示，先要安装wordcount插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount </span><br></pre></td></tr></table></figure><p>之后可以通过主题配置文件里的 word_count 关键字来选择是否开启此功能，默认false。在配置文件的enable后面加上true。</p><h3 id="twikoo评论插件">Twikoo评论插件</h3><p>根据<a href="https://twikoo.js.org/quick-start.html">官方文档</a>进行配置。我选择的是Vercel部署方式。原开发者做了非常非常详细的<a href="https://www.bilibili.com/video/BV1Fh411e7ZH">视频教程</a>。我把_config.volantis.yml中关于评论的设置改成了如下的样子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">twikoo:</span><br><span class="line">    js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本</span><br><span class="line">    path: # 全局评论地址</span><br><span class="line">    # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项</span><br><span class="line">    envId: https://twikoo-dusky.vercel.app/ # vercel id</span><br><span class="line">    appId: # your appId</span><br><span class="line">    appKey: # your appKey</span><br><span class="line">    meta: [nick,mail,link] # valine comment header info</span><br><span class="line">    requiredFields: [nick,mail]</span><br><span class="line">    enableQQ: true # Unstable avatar link</span><br><span class="line">    recordIP: false # Record commenter IP</span><br><span class="line">    avatar: img/avatar.jpg # gravatar style https://valine.js.org/avatar</span><br><span class="line">    pageSize: 10 # comment list page size</span><br><span class="line">    lang: zh-cn</span><br><span class="line">    highlight: true</span><br><span class="line">    mathJax: false</span><br><span class="line"></span><br></pre></td></tr></table></figure> 部署之后还可以根据自己的需求，下载密钥设置管理员密码来对评论系统进行管理和定制。</p><h3 id="暗黑模式">暗黑模式</h3><p>按照_config.volantis.yml中的描述，修改navbar目录，在menu子目录中添加： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- name: 暗黑模式 # 可自定义</span><br><span class="line">      icon: fas fa-moon # 可自定义</span><br><span class="line">      toggle: darkmode</span><br></pre></td></tr></table></figure></p><h3 id="自动生成文章的唯一永久链接">自动生成文章的唯一永久链接</h3><p>使用abbrlink生成。首先下载abbrlink。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>之后修改根目录站点配置文件config.yml，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://自己的网址名/</span><br><span class="line">permalink: :abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc32   #算法： crc16(default) and crc32</span><br></pre></td></tr></table></figure><p>之后hexo三连即可。</p><h3 id="插入latex公式">插入LateX公式</h3><p>更换渲染工具为 hexo-renderer-pandoc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装 hexo-math 插件以支持 latex 公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>volantis主题的话，在_config.volantis.yml中把mathjax后面改成true即可。注意要clean之后重新生成，latax公式才能正常显示。</p><p>记得要在有公式的博客开头加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 个人网站 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/b585e161.html"/>
      <url>/b585e161.html</url>
      
        <content type="html"><![CDATA[<p>最后还是回来写代码了……感觉传统工科的老师都在搞机器学习，那我也没有办法，只能重新回来刷题。</p><p>这个博客上的内容可能会写的支离破碎一些，毕竟现在都在做各种项目，也不可能把全部的代码放上来，大概只是记录一下自己能做到什么功能吧，核心代码也会放一些。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
