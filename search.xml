<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【XAI】Explainable AI Resources</title>
      <link href="/415146091.html"/>
      <url>/415146091.html</url>
      
        <content type="html"><![CDATA[<p>本文总结了一系列<strong>XAI</strong>资源。可解释性技术根据算法用途的不同可分为：（1）输出解释Output Explanation，和（2）DNN原理解释Principle Explanation。根据研究对象的不同，可分为面向CNN和transformer的技术。根据解释方法部署的不同阶段，可分为事前解释方法和事后解释方法。</p><p>Key words：XAI，interpretable DNN, CNN, transformer</p><p>同年的工作中，会议放在期刊之前，因为期刊审稿周期长，通常提交时间更早。</p><h1 id="领域大牛">0 领域大牛</h1><p>XAI：张拳石，周博磊。</p><h1 id="output-explanation">1 Output Explanation</h1><p>对于输出解释，我们将面向CNN的算法和面向Transformer的算法分开列出，如果面向CNN的算法也能用于Transformer将说明（尽管通常这会在两篇不同的论文中）。</p><p>根据解释算法部署阶段的不同分为事前解释方法和事后解释方法。</p><p>根据解释的生效范围的不同，可以分为局部解释和全局解释。局部解释生成针对单个输入的解释，全局解释生成针对一组输入的解释，我们将半局部解释的含义包含在全局解释中。</p><p>全局解释的形式包括从模型中提取规则以建立可解释模型（如决策树，规则集），或解释神经元/层。</p><p>局部解释的形式包括attribution map，给出相似例子等。</p><h2 id="review">1.0 Review</h2><ul><li>Explaining deep neural networks and beyond: A review of methods and applications.<ul><li>Samek W, Montavon G, Lapuschkin S, et al. Proceedings of the IEEE, 2021.</li><li>CNN，事后解释。</li></ul></li><li></li></ul><h2 id="cnn">1.1 CNN</h2><h3 id="intrinsic-methods">1.1.1 Intrinsic Methods</h3><p>事前可解释方法通常提供全局解释。</p><h3 id="post-hoc-methods">1.1.2 Post-hoc Methods</h3><p><strong>Global Interpretability Methods</strong></p><p>activation maximization：</p><ul><li>Synthesizing the preferred inputs for neurons in neural networks via deep generator networks. [<a href="https://github.com/ndey96/deep-generator-network">code</a>]<ul><li>Nguyen A, Dosovitskiy A, Yosinski J, et al. Advances in neural information processing systems, 2016.</li><li>用GAN生成AM图片。</li></ul></li><li>Multifaceted feature visualization: Uncovering the different types of features learned by each neuron in deep neural networks.<ul><li>Nguyen A, Yosinski J, Clune J. arXiv preprint arXiv:1602.03616, 2016.</li><li>研究多语义神经元，使用多种初始值生成更丰富的样本，没有中稿，没有代码。</li></ul></li><li>Deep inside convolutional networks: Visualising image classification models and saliency maps. [<a href="https://github.com/MisaOgura/flashtorch">code</a>]<ul><li>Simonyan K, Vedaldi A, Zisserman A. arXiv preprint arXiv:1312.6034, 2013.</li><li>系列算法的开山之作，包含了模型最大化和基于梯度的方法。</li></ul></li></ul><p><strong>Local Interpretability Methods</strong></p><p>attribution：</p><p>（1）LRP(layer-wise relevance propagation)：</p><ul><li>On pixel-wise explanations for non-linear classifier decisions by layer-wise relevance propagation.<ul><li>Bach S, Binder A, Montavon G, et al. PloS one, 2015.</li><li>LRP系列开山之作，用caffe写的，没有代码。</li></ul></li></ul><p>（2）Gradient-based：</p><ul><li>Axiomatic attribution for deep networks.<ul><li>Sundararajan M, Taly A, Yan Q. International conference on machine learning. PMLR, 2017.</li><li>提出积分梯度IG。可以解决LRP和基于梯度的方法对于模型结构的依赖性。代码建议用captum的。</li></ul></li></ul><p>（3）LIME(Local Interpretable Model-Agnostic Explanations)：</p><ul><li>"Why should i trust you?" Explaining the predictions of any classifier. [<a href="https://github.com/marcotcr/lime">code</a>]<ul><li>Ribeiro M T, Singh S, Guestrin C. Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining. 2016.</li><li>LIME系列的开山之作。</li></ul></li></ul><h2 id="transformer">1.2 Transformer</h2><h2 id="evaluation-of-xai-methods">1.3 Evaluation of XAI methods</h2><h1 id="principle-explanation">2 Principle Explanation</h1><p>模型原理研究可以全部视为全局解释方法。</p><h2 id="cnn-1">2.1 CNN</h2><h2 id="transformer-1">2.2 Transformer</h2><h2 id="evaluation-of-xai-methods-1">2.3 Evaluation of XAI methods</h2><p>intrinsic XAI指的是在模型训练结束之前进行一些操作，使得训练出的模型具备更高的可解释性。</p><h2 id="model">1.1 model</h2><ul><li>PIP-Net: Patch-Based Intuitive Prototypes for Interpretable Image Classification. [<a href="https://github.com/m-nauta/pipnet">code</a>]<ul><li>Meike NautaJörg SchlöttererMaurice van KeulenChristin Seifert. 2023 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR) (2023)</li></ul></li><li>MonoNet: Enhancing interpretability in neural networks via Monotonic Features.<ul><li>An-Phi NguyenDana Lea MorenoNicolas Le-BelMaría Rodríguez Martínez. Bioinformatics Advances (2023)</li></ul></li><li></li></ul><h2 id="neuronlayer">1.2 neuron/layer</h2><h2 id="input-feature">1.3 input feature</h2><h2 id="hidden-semanics">1.4 hidden semanics</h2><ul><li>ProtoSeg: Interpretable Semantic Segmentation with Prototypical Parts. [code](<a href="https://github.com/gmum/proto-segmentation">https://github.com/gmum/proto-segmentation</a>)<ul><li>Mikolaj SachaDawid RymarczykLukasz StruskiJacek TaborBartosz Zielinski. 2023 IEEE/CVF Winter Conference on Applications of Computer Vision (WACV) (2023)</li></ul></li></ul><h1 id="section"></h1><h1 id="xai-toolkit">3 XAI toolkit</h1><p>Lucid：基于</p><p>captum：</p><h1 id="xai-website">4 XAI website</h1>]]></content>
      
      
      
        <tags>
            
            <tag> XAI </tag>
            
            <tag> resources </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【竹夭的Pytorch讲义】01</title>
      <link href="/3212441176.html"/>
      <url>/3212441176.html</url>
      
        <content type="html"><![CDATA[<h1 id="大纲">0 大纲</h1><ol type="1"><li>安装和设置环境<ul><li>配置开发环境，如安装适当的Python版本和IDE，安装PyTorch和相关的软件包</li><li>初识pytorch</li></ul></li><li>张量和张量操作<ul><li>张量的概念和基本操作</li><li>张量的创建、索引和切片操作</li><li>张量的数学运算和广播操作</li></ul></li><li>自动求导和反向传播<ul><li>自动求导的概念和原理</li><li>使用PyTorch进行自动求导和反向传播</li><li>优化器和学习率</li></ul></li><li>构建神经网络模型<ul><li>PyTorch中的神经网络模型的组成和结构</li><li>构建自定义的神经网络模型</li><li>常见的神经网络层和激活函数</li></ul></li><li>数据加载和预处理<ul><li>数据集的收集和准备</li><li>使用PyTorch的<code>Dataset</code>和<code>DataLoader</code>加载和处理数据</li><li>数据增强和预处理操作</li></ul></li><li>训练和评估模型<ul><li>训练模型的基本流程和步骤</li><li>定义损失函数和评估指标</li><li>批量训练和迭代优化模型</li><li>模型的评估和性能指标的计算</li></ul></li><li>迁移学习和预训练模型<ul><li>迁移学习的概念和应用</li><li>使用预训练模型进行迁移学习的步骤</li><li>常见的预训练模型和使用方法</li></ul></li><li>模型部署和推理<ul><li>将训练好的模型导出和保存</li><li>在生产环境中使用模型进行推理和预测</li><li>常见的模型部署方法和工具</li></ul></li></ol><h1 id="安装和设置环境">1 安装和设置环境</h1><h2 id="配置开发环境">1.1 配置开发环境</h2><p>用anaconda3管理包，用pycharm（学生可以免费用professional版）编写代码。</p><p>安装pytorch不需要翻墙，直接用官网的命令即可。</p><h2 id="初识pytorch">1.2 初识pytorch</h2><p><a href="https://pytorch.org/docs/1.11/">pytorch官方文档</a>。</p><h3 id="两个实用函数">1.2.1 两个实用函数</h3><p>研究Pytorch包之类的新package用到两个函数：<code>dir()</code>，用来打开package，输出分割区；<code>help()</code>，用来输出package或其中一些内容的帮助文档，一般看函数的帮助文档，注意函数后面不需要加括号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">ans = torch.cuda.is_available()</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(torch))</span><br><span class="line"><span class="built_in">help</span>(torch)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(torch.AnyType))</span><br><span class="line"><span class="built_in">help</span>(torch.cuda.is_available)</span><br></pre></td></tr></table></figure><p>可以运行上述代码，观察输出。</p><p>对pytorch的初步认识：</p><p>Pytorch实现模型训练：数据+模型+损失函数+优化器=迭代训练。</p><ul><li>数据：包括数据读取和数据清洗等。</li><li>模型：包括构建模型模块，组织复杂网络，初始化网络参数，定义网络层。</li><li>损失函数：包括创建损失函数，设置损失函数超参数，根据不同任务选择合适的损失函数。</li><li>优化器：包括根据梯度使用某种优化器更新参数，管理模型参数，管理多个参数组实现不同学习率，调整学习率。</li><li>迭代训练：组织上面4个模块进行反复训练。包括观察训练效果，绘制Loss/Accuracy曲线，用TensorBoard进行可视化分析。</li></ul><h1 id="张量和张量操作">2 张量和张量操作</h1><h2 id="张量的概念和基本操作">2.1 张量的概念和基本操作</h2><p>本章代码：</p><ul><li><a href="https://github.com/zhangxiann/PyTorch_Practice/blob/master/lesson1/tensor_introduce1.py">https://github.com/zhangxiann/PyTorch_Practice/blob/master/lesson1/tensor_introduce1.py</a></li><li><a href="https://github.com/zhangxiann/PyTorch_Practice/blob/master/lesson1/tensor_introduce1.py">https://github.com/zhangxiann/PyTorch_Practice/blob/master/lesson1/tensor_introduce1.py</a></li></ul><p>标量可以称为0维张量，向量可以称为1维张量，矩阵可以称为2维张量，RGB图像可以表示3维张量。可以把张量看作多维数组。</p><p><strong>size和shape的关系</strong></p><p>Numpy中，size()和shape()是两个函数，np.size(a)返回a中所有元素的个数，np.shape(a)返回a每维的大小。</p><p>Pytorch中，shape是张量的一个属性，比如a.shape。a.size会输出a在内存中的占用情况，a.size(axis)会输出a在axis维度上的大小。</p><p><strong>Tensor与Variable</strong></p><p>在PyTorch 0.4.0之前，torch.autograd包中存在Variable这种数据类型，主要是用于封装Tensor，进行自动求导。Variable主要包含下面几种属性。</p><ul><li>data：被包装的Tensor。</li><li>grad：data 的梯度。</li><li>grad_fn：创建 Tensor 所使用的 Function，是自动求导的关键，根据所记录的函数才能计算出导数。</li><li>requires_grad：指示是否需要梯度，并不是所有的张量都需要计算梯度。</li><li>is_leaf：指示是否叶子节点(张量)，叶子节点的概念在计算图中会用到，后面详细介绍。</li></ul><figure><img src="\img\PytorchMaterial01\zYh4LIVVFoKV7WIW2Rlr7CGSk9Zx_XiqVr-BOVwL440.png" class="lazyload" data-srcset="\img\PytorchMaterial01\zYh4LIVVFoKV7WIW2Rlr7CGSk9Zx_XiqVr-BOVwL440.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Variable类的属性" /><figcaption aria-hidden="true">Variable类的属性</figcaption></figure><p>在PyTorch 0.4.0之后，Variable并入了Tensor。在之后版本的Tensor中，除了具有上面Variable的5个属性，还有另外3个属性。</p><ul><li>dtype：张量的数据类型，如torch.FloatTensor，torch.cuda.FloatTensor。</li><li>shape：张量的形状，如(64, 3, 224, 224)。</li><li>device：张量所在设备 (CPU/GPU)，GPU是加速计算的关键。</li></ul><figure><img src="\img\PytorchMaterial01\w8VfyAXy7mCS6furVknGmccs3Tm7BYnkbxi0ZQFInbU.png" class="lazyload" data-srcset="\img\PytorchMaterial01\w8VfyAXy7mCS6furVknGmccs3Tm7BYnkbxi0ZQFInbU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Tensor类的属性" /><figcaption aria-hidden="true">Tensor类的属性</figcaption></figure><p>关于dtype，PyTorch提供了9种数据类型，共分为3大类：float(16-bit, 32-bit, 64-bit)、integer(unsigned-8-bit ,8-bit, 16-bit, 32-bit, 64-bit)、Boolean。模型参数和数据用的最多的类型是float-32-bit。label 常用的类型是integer-64-bit。</p><figure><img src="\img\PytorchMaterial01\N0lkHqYEFcF326qIJfskWNFNPWPx4a25ajWS9JYLao4.png" class="lazyload" data-srcset="\img\PytorchMaterial01\N0lkHqYEFcF326qIJfskWNFNPWPx4a25ajWS9JYLao4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="常用数据类型及其写法" /><figcaption aria-hidden="true">常用数据类型及其写法</figcaption></figure><h2 id="张量的创建和索引">2.2 张量的创建和索引</h2><h3 id="张量的创建">2.2.1 张量的创建</h3><p><strong>直接创建Tensor</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.tensor(data, dtype=<span class="literal">None</span>, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>, pin_memory=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li>data：数据，可以是list，numpy。</li><li>dtype：数据类型，默认与data的一致。</li><li>device：所在设备，cuda/cpu。</li><li>requires_grad：是否需要梯度。</li><li>pin_memory：是否存于锁页内存。</li></ul><p><strong>从numpy创建Tensor</strong></p><p>使用<code>torch.from_numpy(ndarray)</code> 。利用这个方法创建的tensor和原来的ndarray共享内存，当修改其中一个数据，另外一个也会被改动。</p><p><strong>根据数值创建Tensor</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.zeros(*size, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>根据size创建全0张量。</p><ul><li>size：张量的形状。</li><li>out：输出的张量。如果指定了out，那么<code>torch.zeros()</code>返回的张量和 out 指向的是同一个地址。</li><li>layout：内存中布局形式，有strided，sparse_coo等。当是稀疏矩阵时，设置为sparse_coo可以减少内存占用。</li><li>device：所在设备，cuda/cpu。</li><li>requires_grad：是否需要梯度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.zeros_like(<span class="built_in">input</span>, dtype=<span class="literal">None</span>, layout=<span class="literal">None</span>, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>, memory_format=torch.preserve_format)</span><br></pre></td></tr></table></figure><p>根据input的形状创建全0张量。</p><ul><li>input：创建与input同形状的全0张量。</li><li>dtype：数据类型。</li><li>layout：内存中布局形式，有strided，sparse_coo等。当是稀疏矩阵时，设置为sparse_coo可以减少内存占用。</li></ul><p>同理还有全1张量的创建方法：<code>torch.ones()</code>，<code>torch.ones_like()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.full(size, fill_value, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>torch.full()</code>，<code>torch.full_like()</code>可以创建自定义数值的张量。</p><ul><li>size：张量的形状，如(3,3)。</li><li>fill_value：张量中每一个元素的值。</li></ul><p><strong>根据数学公式创建Tensor</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.arange(start=<span class="number">0</span>, end, step=<span class="number">1</span>, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>创建等差的1维张量。注意区间为[start, end)。</p><ul><li>start：数列起始值。</li><li>end：数列结束值，开区间，取不到结束值。</li><li>step：数列公差，默认为1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.linspace(start, end, steps=<span class="number">100</span>, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>创建均分的1维张量。数值区间为[start, end]。<span class="math inline">\(a_i=a_0+\frac{end-start}{step-1}*i\)</span></p><ul><li>start：数列起始值。</li><li>end：数列结束值。</li><li>steps：数列长度，即元素个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.logspace(start, end, steps=<span class="number">100</span>, base=<span class="number">10.0</span>, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>创建对数均分的1维张量。数值区间为[start, end]，底为base。</p><ul><li>start：数列起始值。</li><li>end：数列结束值。</li><li>steps：数列长度（元素个数）。</li><li>base：对数函数的底，默认为10。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.eye(n, m=<span class="literal">None</span>, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>创建单位对角矩阵（2维张量），默认为方阵。</p><ul><li>n：矩阵行数。通常只设置n，为方阵。</li><li>m：矩阵列数。</li></ul><p><strong>根据概率创建Tensor</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.normal(mean, std, *, generator=<span class="literal">None</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>生成正态分布（高斯分布）。</p><ul><li>mean：均值。</li><li>std：标准差。</li></ul><p>该函数有4种模式：</p><ol type="1"><li>mean为标量，std为标量。这时需要设置size。</li><li>mean为标量，std为张量。</li><li>mean为张量，std为标量。</li><li>mean为张量，std为张量。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(*size, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>torch.randn()</code>和<code>torch.randn_like()</code> ，用来生成标准正态分布。</p><ul><li>size：张量的形状。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.rand(*size, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>torch.rand()</code>和<code>torch.rand_like()</code>在区间[0, 1)上生成均匀分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">randint(low=<span class="number">0</span>, high, size, *, generator=<span class="literal">None</span>, out=<span class="literal">None</span>,</span><br><span class="line">dtype=<span class="literal">None</span>, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>torch.randint()</code>和<code>torch.randint_like()</code> ，在区间[low, high)上生成整数均匀分布并采样。</p><ul><li>size：张量的形状。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.randperm(n, out=<span class="literal">None</span>, dtype=torch.int64, layout=torch.strided, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>生成从0到n-1的随机排列，常用于生成索引。</p><ul><li>n：张量的长度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.bernoulli(<span class="built_in">input</span>, *, generator=<span class="literal">None</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>以input为概率，生成伯努利分布（即0-1 分布，两点分布）。</p><ul><li>input：概率值。</li></ul><h3 id="张量的索引">2.2.2 张量的索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">max</span>(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>, out=<span class="literal">None</span>) -&gt; (Tensor, LongTensor)</span><br></pre></td></tr></table></figure><p>按维度dim返回最大值以及最大值的索引。dim = 0表示按列求最大值，dim = 1表示按行求最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nonzero(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure><p>返回一个包含输入input中非零元素索引的张量，输出张量中的每行包含input中非零元素的索引。如果输入input有n维，则输出的索引张量out的size为z×n , 这里z是输入张量input中所有非零元素的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.where(condition，a，b)</span><br></pre></td></tr></table></figure><p>按照一定的规则合并两个tensor类型。</p><p>condition：条件限制，如果满足条件，则选择a，否则选择b作为输出。注意a和b是tensor。</p><p>numpy中也有where()，其输入非tensor。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.index_select(<span class="built_in">input</span>, dim, index, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>在维度dim上，按照index索引取出数据拼接为张量返回。</p><ul><li>input：要索引的张量。</li><li>dim：要索引的维度。</li><li>index：要索引数据的序号。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.masked_select(<span class="built_in">input</span>, mask, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>按照mask中的True进行索引拼接得到一维张量返回。</p><ul><li>input：要索引的张量。</li><li>mask：与input同形状的布尔类型张量。</li></ul><h2 id="张量的维度操作和数学运算">2.3 张量的维度操作和数学运算</h2><h3 id="张量的维度操作">2.3.1 张量的维度操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cat(tensors, dim=<span class="number">0</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将张量按照dim维度进行拼接。</p><ul><li>tensors：张量序列。</li><li>dim：要拼接的维度。dim=0是行数，1是列数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.stack(tensors, dim=<span class="number">0</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>将张量在新创建的dim维度上进行拼接。</p><ul><li>tensors：张量序列。</li><li>dim：要拼接的维度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.chunk(<span class="built_in">input</span>, chunks, dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>将张量按照维度dim进行平均切分。若不能整除，则最后一份张量小于其他张量。</p><ul><li>input：要切分的张量。</li><li>chunks：要切分的份数。</li><li>dim：要切分的维度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.split(tensor, split_size_or_sections, dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>将张量按照维度dim进行平均切分。可以指定每一个分量的切分长度。</p><ul><li>tensor：要切分的张量</li><li>split_size_or_sections：为int时表示每一份的长度，如果不能被整除，则最后一份张量小于其他张量；为list时按照list元素作为每一个分量的长度切分。如果list元素之和不等于切分维度dim的值则报错。</li><li>dim：要切分的维度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.reshape(<span class="built_in">input</span>, shape)</span><br></pre></td></tr></table></figure><p>变换张量的形状（维度）。当张量在内存中是连续时，返回的张量和原来的张量共享数据内存，改变一个变量时，另一个变量也会被改变。</p><ul><li>input：要变换的张量。</li><li>shape：新张量的形状。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.transpose(<span class="built_in">input</span>, dim0, dim1)</span><br></pre></td></tr></table></figure><p>交换张量的两个维度。常用于图像的变换，比如把<code>c*h*w</code>变换为<code>c*w*h</code>。</p><ul><li>input：要交换维度的张量。</li><li>dim0：要交换的第一个维度。</li><li>dim1：要交换的第二个维度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.t(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure><p>2维张量转置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.squeeze(<span class="built_in">input</span>, dim=<span class="literal">None</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>压缩长度为1的维度。</p><ul><li>dim：若为None，则移除所有长度为1的维度；若指定维度，则当且仅当该维度长度为1时可以移除。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.unsqueeze(<span class="built_in">input</span>, dim)</span><br></pre></td></tr></table></figure><p>根据dim扩展维度，长度为1。</p><h3 id="张量的数学运算">2.3.2 张量的数学运算</h3><p>主要分为3类：加减乘除，对数指数，幂函数和三角函数。这里介绍一下常用的几种方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.add(<span class="built_in">input</span>, other, out=<span class="literal">None</span>)</span><br><span class="line">torch.add(<span class="built_in">input</span>, other, *, alpha=<span class="number">1</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>逐元素计算input+alpha*other。因为在深度学习中经常用到先乘后加的操作。</p><ul><li>input：第一个张量。</li><li>alpha：乘项因子。</li><li>other：第二个张量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.addcdiv(<span class="built_in">input</span>, tensor1, tensor2, *, value=<span class="number">1</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\text{out}_{i}=\text{input}_{i}+\text{value}\times \frac{\text{tensor1}_{i}}{\text{tensor2}_{i}}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.addcmul(<span class="built_in">input</span>, tensor1, tensor2, *, value=<span class="number">1</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\text{out}_{i}=\text{input}_{i}+\text{value}\times \text{tensor1}_{i} \times \text{tensor 2}_{i}\)</span></p><h2 id="section"></h2><h1 id="自动求导和反向传播">3 自动求导和反向传播</h1><h2 id="计算图与自动求导">3.1 计算图与自动求导</h2><p><strong>计算图</strong></p><p>计算图是用来描述运算的有向无环图，主要包括节点（Node）和边（Edge）。节点表示数据，如向量、矩阵、张量。边表示运算，如加减乘除卷积等。</p><p>有公式<span class="math inline">\(y=(x+w)*(w+1)\)</span>，<span class="math inline">\(x=2, \ w=1\)</span>，对<span class="math inline">\(w\)</span>求导，根据复合函数的求导法则可以得到如下过程：</p><p><span class="math inline">\(\begin{aligned} \frac{\partial y}{\partial w} &amp;=\frac{\partial y}{\partial a} \frac{\partial a}{\partial w}+\frac{\partial y}{\partial b} \frac{\partial b}{\partial w} \\ &amp;=b\times1+a\times1 \\ &amp;=b+a \\ &amp;=(w+1)+(x+w) \\ &amp;=2 w+x+1 \\ &amp;=2\times1+2+1=5\end{aligned}\)</span></p><p>前面说过Tensor中有一个属性<code>is_leaf</code>标记是否为叶子节点，这个概念主要是为了节省内存，在计算图中的一轮反向传播结束之后，非叶子节点的梯度是会被释放的。如果在反向传播结束之后仍然需要保留非叶子节点的梯度，可以使用张量的<code>retain_grad()</code>方法：<code>a.retain_grad()</code>。</p><p>Tensor中的<code>grad_fn</code>属性记录的是创建该张量时所用的方法（函数），反向传播求导梯度时需要用到该属性。</p><p><strong>PyTorch的动态图机制</strong></p><p>PyTorch采用的是动态图机制（Dynamic Computational Graph），而Tensorflow采用的是静态图机制（Static Computational Graph）。动态图是运算和搭建同时进行，也就是可以先计算前面的节点的值再根据这些值搭建后面的计算图。优点是灵活，易调节易调试。PyTorch的写法跟其他Python库是完全一致的，没有额外的学习成本。</p><p>静态图是先搭建图，然后再输入数据进行运算。优点是高效，因为静态计算是通过先定义后运行的方式，之后再次运行的时候就不再需要重新构建计算图，所以速度会比动态图更快。但是不灵活。TensorFlow每次运行的时候图都是一样的，是不能够改变的，所以不能直接使用Python的while循环语句，需要使用辅助函数tf.while_loop写成TensorFlow内部的形式。</p><p><strong>自动求导（autograd）</strong></p><p>深度学习中，权值的更新依赖于梯度的计算，因此梯度的计算是至关重要的。PyTorch 中只需要搭建好前向计算图，就可以利用<code>torch.autograd</code>自动求导得到所有张量的梯度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.autograd.backward(tensors, grad_tensors=<span class="literal">None</span>, retain_graph=<span class="literal">None</span>, create_graph=<span class="literal">False</span>, grad_variables=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>自动求取梯度。</p><ul><li>tensors：用于求导的张量，如loss。</li><li>retain_graph：保存计算图。PyTorch采用动态图机制，默认每次反向传播之后都会释放计算图。该参数设置为True可以不释放计算图，这样就可以多次计算导数。</li><li>create_graph：创建导数计算图，用于高阶求导。</li><li>grad_tensors：多梯度权重。当有多个loss混合计算梯度时，设置每个loss的权重。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.autograd.grad(outputs, inputs, grad_outputs=<span class="literal">None</span>, retain_graph=<span class="literal">None</span>, create_graph=<span class="literal">False</span>, only_inputs=<span class="literal">True</span>, allow_unused=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>求取梯度。</p><ul><li>outputs：用于求导的张量，如loss。</li><li>inputs：需要梯度的张量。</li><li>create_graph：创建导数计算图，用于高阶求导。</li><li>retain_graph：保存计算图。</li><li>grad_outputs：多梯度权重计算。</li></ul><p><code>torch.autograd.grad()</code>的返回结果是一个 tunple，需要取出第0个元素才是真正的梯度。</p><p>求一阶导时需要设置<code>create_graph=True</code>，让一阶导数<code>grad_1</code>也拥有计算图，然后再使用一阶导求取二阶导。</p><p>需要注意的3个点：</p><ul><li><p>在每次反向传播求导时，计算的梯度不会自动清零。如果进行多次迭代计算梯度而没有清零，那么梯度会在前一次的基础上叠加。使用<code>w.grad.zero_()</code>可将梯度清零。</p></li><li><p>依赖于叶子节点的节点，requires_grad属性默认为True。</p></li><li><p>叶子节点不可执行inplace操作。以加法来说，inplace操作有<code>a += x</code>，<code>a.add_(x)</code>，改变后的值和原来的值内存地址是同一个。非inplace操作有<code>a = a + x</code>，<code>a.add(x)</code>，改变后的值和原来的值内存地址不是同一个。</p></li></ul><p>如果在反向传播之前用inplace方法改变了叶子节点的值，再执行backward()会报错。这是因为在进行前向传播时，计算图中依赖于叶子节点的那些节点会记录叶子节点的地址，在反向传播时就会利用叶子节点的地址所记录的值来计算梯度。比如在<span class="math inline">\(y=a \times b\)</span>，其中<span class="math inline">\(a=x+w\)</span>，<span class="math inline">\(b=w+1\)</span>，<span class="math inline">\(x\)</span>和<span class="math inline">\(w\)</span>是叶子节点。当求导<span class="math inline">\(\frac{\partial y}{\partial a} = b = w+1\)</span>，需要用到叶子节点<span class="math inline">\(w\)</span>。</p><h2 id="使用pytorch进行自动求导和反向传播">3.2 使用PyTorch进行自动求导和反向传播</h2><p>以<strong>逻辑回归（Logistic Regression）</strong>为例，基于PyTorch实现自动求导和反向传播。</p><p>逻辑回归是线性的二分类模型。模型表达式<span class="math inline">\(y=f(z)=\frac{1}{1+e^{-z}}\)</span>，其中<span class="math inline">\(z=WX+b\)</span>。<span class="math inline">\(f(z)\)</span>称为sigmoid函数，也被称为Logistic函数。</p><p><span class="math inline">\(y&lt;0.5\)</span>时类别为0；<span class="math inline">\(0.5 \leq y\)</span>时类别为1。</p><p>其中<span class="math inline">\(z=WX+b\)</span>也是线性回归的模型。从横坐标来看，当<span class="math inline">\(z&lt;0\)</span>时，类别为0；当<span class="math inline">\(0 \leq z\)</span> 时，类别为1，直接使用线性回归也可以进行分类。逻辑回归是在线性回归的基础上加入了一个sigmoid 函数，这是为了更好地描述置信度，把输入映射到(0,1)区间中，符合概率取值。</p><p>逻辑回归也被称为对数几率回归：<span class="math inline">\(\ln \frac{y}{1-y}=W X+b\)</span>。几率的表达式为：<span class="math inline">\(\frac{y}{1-y}\)</span>，<span class="math inline">\(y\)</span>表示正类别的概率，<span class="math inline">\(1-y\)</span>表示另一个类别的概率。根据对数几率回归可以推导出逻辑回归表达式：</p><p><span class="math inline">\(\begin{aligned}&amp;\ln \frac{y}{1-y}=W X+b \\&amp;\frac{y}{1-y}=e^{W X+b} \\&amp;y=e^{W X+b}-y * e^{W X+b} \\&amp;y\left(1+e^{W X+b}\right)=e^{W X+b} \\&amp;y=\frac{e^{W X+b}}{1+e^{W X+b}}=\frac{1}{1+e^{-(W X+b)}}\end{aligned}\)</span></p><p><strong>Pytorch实现逻辑回归</strong></p><p>PyTorch 构建模型需要5大步骤：</p><ul><li>数据：进行数据预处理。</li><li>模型：包括构建模型模块，组织复杂网络，初始化网络参数，定义网络层。</li><li>损失函数：包括创建损失函数，设置损失函数超参数，根据不同任务选择合适的损失函数。</li><li>优化器：包括根据梯度使用某种优化器更新参数，管理模型参数，管理多个参数组实现不同学习率，调整学习率。</li><li>迭代训练：组织上面4个模块进行反复训练。包括观察训练效果，绘制Loss/Accuracy曲线，用TensorBoard进行可视化分析。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span>(<span class="params">Module</span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;Applies a linear transformation to the incoming data: :math:`y = xA^T + b`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        in_features: size of each input sample</span></span><br><span class="line"><span class="string">        out_features: size of each output sample</span></span><br><span class="line"><span class="string">        bias: If set to ``False``, the layer will not learn an additive bias.</span></span><br><span class="line"><span class="string">            Default: ``True``</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Shape:</span></span><br><span class="line"><span class="string">        - Input: :math:`(*, H_&#123;in&#125;)` where :math:`*` means any number of</span></span><br><span class="line"><span class="string">          dimensions including none and :math:`H_&#123;in&#125; = \text&#123;in\_features&#125;`.</span></span><br><span class="line"><span class="string">        - Output: :math:`(*, H_&#123;out&#125;)` where all but the last dimension</span></span><br><span class="line"><span class="string">          are the same shape as the input and :math:`H_&#123;out&#125; = \text&#123;out\_features&#125;`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        weight: the learnable weights of the module of shape</span></span><br><span class="line"><span class="string">            :math:`(\text&#123;out\_features&#125;, \text&#123;in\_features&#125;)`. The values are</span></span><br><span class="line"><span class="string">            initialized from :math:`\mathcal&#123;U&#125;(-\sqrt&#123;k&#125;, \sqrt&#123;k&#125;)`, where</span></span><br><span class="line"><span class="string">            :math:`k = \frac&#123;1&#125;&#123;\text&#123;in\_features&#125;&#125;`</span></span><br><span class="line"><span class="string">        bias:   the learnable bias of the module of shape :math:`(\text&#123;out\_features&#125;)`.</span></span><br><span class="line"><span class="string">                If :attr:`bias` is ``True``, the values are initialized from</span></span><br><span class="line"><span class="string">                :math:`\mathcal&#123;U&#125;(-\sqrt&#123;k&#125;, \sqrt&#123;k&#125;)` where</span></span><br><span class="line"><span class="string">                :math:`k = \frac&#123;1&#125;&#123;\text&#123;in\_features&#125;&#125;`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; m = nn.Linear(20, 30)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; input = torch.randn(128, 20)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; output = m(input)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; print(output.size())</span></span><br><span class="line"><span class="string">        torch.Size([128, 30])</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.BCEloss()  <span class="comment"># 计算二分类问题的交叉熵</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zhangxianrong/p/14773075.html">交叉熵介绍博客</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.optim.SGD(params, lr, momentum, dampening, weight_decay, nesterov)</span><br></pre></td></tr></table></figure><ul><li>params：待优化参数的iterable，或者是定义了参数组的dict。这个参数代表权重<span class="math inline">\(w\)</span>和偏置<span class="math inline">\(b\)</span>等神经网络中的参数。</li><li>lr：学习率。</li><li>momentum：动量因子。每次<span class="math inline">\(x\)</span>的更新量<span class="math inline">\(v=-dx*lr\)</span>，考虑动量之后公式变为<span class="math inline">\(v&#39;=-dx*lr+v*momenmtum\)</span>。</li><li>weight_decay：权重惩罚。</li><li>dampening：动量的抑制因子。</li><li>nesterov：使用nesterov动量。</li></ul><p>用<code>.item()</code>取出张量中的元素而不是用下标，主要是精度有区别。</p><p><a href="https://blog.csdn.net/ys1305/article/details/97959046/">Pytorch各层输出</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.scatter(x, y, s=<span class="literal">None</span>, c=<span class="literal">None</span>, marker=<span class="literal">None</span>, cmap=<span class="literal">None</span>, norm=<span class="literal">None</span>, vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>, alpha=<span class="literal">None</span>, linewidths=<span class="literal">None</span>, verts=<span class="literal">None</span>, edgecolors=<span class="literal">None</span>, *, data=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><p>用于生成一个scatter散点图。</p><ul><li>x, y：表示的是shape大小为(n,)的数组，也就是我们即将绘制散点图的数据点，输入数据。</li><li>s：表示的是散点图上一个点的大小，是一个标量或者是一个shape大小为(n,)的数组，可选，默认20。</li><li>c：表示的是色彩或颜色序列，可选，默认蓝色'b'。但是c不应该是一个单一的RGB数字，也不应该是一个RGBA的序列，因为不便区分。c可以是一个RGB或RGBA二维行数组。</li><li>marker：MarkerStyle，表示的是标记的样式，可选，默认'o'。</li><li>cmap：Colormap，标量或者是一个colormap的名字，cmap仅仅当c是一个浮点数数组的时候才使用。如果没有申明就是image.cmap，可选，默认None。</li><li>norm：Normalize，数据亮度在0-1之间，也是只有c是一个浮点数的数组的时候才使用。如果没有申明，就是默认None。</li><li>vmin，vmax：标量，当norm存在的时候忽略。用来进行亮度数据的归一化，可选，默认None。</li><li>alpha：散点的透明度。标量，0-1之间，可选，默认None。</li><li>linewidths：标记取不同样式的时候，其中也许会有可以设置宽度的线，这时候这个参数是有效的。</li></ul><h2 id="优化器和学习率">3.3 优化器和学习率</h2><h3 id="优化器">3.3.1 优化器</h3><ul><li><strong>梯度下降 (Gradient Descent)</strong></li><li><strong>批量梯度下降 (Batch Gradient Descent)</strong>: 使用整个训练数据集来计算梯度。</li><li><strong>随机梯度下降 (Stochastic Gradient Descent, SGD)</strong>: 在每次迭代中使用一个训练样本来计算梯度。</li><li><strong>小批量梯度下降 (Mini-Batch Gradient Descent)</strong>: 使用一个小的数据子集（小批量）来计算梯度。2. <strong>Momentum</strong></li><li>为了加速SGD，Momentum考虑了过去的梯度来平滑更新。3. <strong>Adagrad (Adaptive Gradient Algorithm)</strong></li><li>为每个参数调整学习率，使频繁出现的参数有较小的学习率，而较少出现的参数有较大的学习率。4. <strong>RMSprop (Root Mean Square Propagation)</strong></li><li>与Adagrad类似，但是使用移动平均的平方梯度来调整学习率。5. <strong>Adam (Adaptive Moment Estimation)</strong></li><li>结合了Momentum和RMSprop的想法。它计算梯度的指数移动平均值和平方梯度的指数移动平均值来调整每个参数的学习率。6. <strong>Adadelta</strong></li><li>是Adagrad的一个扩展，旨在减少其学习率的急剧下降。7. <strong>Nadam</strong></li><li>结合了Adam和Nesterov的动量。8. <strong>FTRL (Follow The Regularized Leader)</strong></li><li>主要用于大规模线性模型，如LR和FM。9. <strong>L-BFGS (Limited-memory Broyden–Fletcher–Goldfarb–Shanno)</strong></li><li>一种准牛顿方法，通常用于全批量优化。</li></ul><p>每种优化器都有其特定的应用场景和优势。在深度学习中，Adam、RMSprop和SGD with Momentum是最常用的优化器。选择哪种优化器取决于具体的问题和数据。实际上，为了找到最佳的优化器和超参数设置，通常需要进行多次实验。</p><p><a href="https://blog.csdn.net/KGzhang/article/details/77479737">https://blog.csdn.net/KGzhang/article/details/77479737</a></p><p><a href="https://blog.csdn.net/Decennie/article/details/119222319">https://blog.csdn.net/Decennie/article/details/119222319</a></p><p><a href="https://zhuanlan.zhihu.com/p/38945390">https://zhuanlan.zhihu.com/p/38945390</a></p><p>AdamW是一种深度学习模型的优化器，它基于Adam优化器（自适应矩估计）进行修改，更准确地实现了权重衰减。AdamW在一些情况下被观察到比原始的Adam优化器有更好的性能。</p><p>在深度学习中，我们通常通过随机梯度下降（SGD）或其变种来优化模型的参数，以最小化损失函数。这种优化过程可能会导致模型的参数值过大，从而导致过拟合。为了避免过拟合，我们可以对模型的参数进行权重衰减，即在优化过程中对模型参数应用一种惩罚。</p><p>原始的Adam优化器在其参数更新公式中包含一个衰减项，但这种方式实际上并不能有效地实现权重衰减。相反，它更类似于L2正则化，这与权重衰减的概念是有区别的。</p><p>在这里，AdamW优化器的提出就是为了解决这个问题。它将权重衰减与优化步骤分开，确保权重衰减只应用于模型的参数，而不是应用于梯度或者其它中间步骤。这样可以更精确地实现权重衰减，帮助模型在训练过程中保持更好的泛化能力。</p><p>总的来说，AdamW优化器在实践中通常可以带来更好的性能，尤其是对于大型的预训练模型，如BERT、GPT等。</p><h3 id="学习率">3.3.2 学习率</h3><p><a href="https://blog.csdn.net/qq_35091353/article/details/117322293">待预热的学习率</a>。</p><p><code>get_cosine_schedule_with_warmup</code>：创建一个余弦退火学习率调度器，并包含了一个预热阶段。在预热阶段，学习率从 0 线性增加到初始学习率。预热步数由 <code>config.lr_warmup_steps</code> 指定。预热阶段过后，学习率开始按照余弦退火的方式下降。<code>num_training_steps</code>表示总的训练步数，计算方式是训练数据的批次数乘以训练的总周期数。<code>num_training_steps=(len(train_dataloader) * config.num_epochs)</code> 中，计算方式是训练数据的批次数乘以训练的总周期数。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI框架 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Haskell教程】01</title>
      <link href="/4240470103.html"/>
      <url>/4240470103.html</url>
      
        <content type="html"><![CDATA[<p>该系列博客是我结合多个来源的Haskell教程和自己对Haskell的理解写的。主体内容来源于w3cschool的Haskell教程，不过这个教程也是根据外国的一本教材翻译来的，我把一些语法错误、我认为没必要的修辞等内容去掉，并对我觉得不清楚的内容进行了进一步的解释。该系列的章节设置就是按照w3cshool中的章节名来的，但是每篇博客会控制在1w个字符左右（我能够耐心读完的长度）。对于后续一些困难的、具体的知识点（如Monad），知乎上大佬的回答非常有用，在此表达由衷的感谢。</p><p><a href="%5Bhttps://www.w3cschool.cn/hsriti/r6w1aozt.html%5D">w3cschool Haskell教程</a>，<a href="https://iowiki.com/haskell/haskell_monads.html">WIKI教程 Haskell教程</a>，<a href="https://code.world/haskell">Haskell网站编译器</a>。</p><p>我是在windows系统上安装Haskell编译环境的。<a href="https://www.haskell.org/ghcup/">官网地址</a>上提供的一条指令安装的方法由于网络问题完全不行。我使用另一个网站提供的<a href="https://www.haskell.org/ghcup/install/#manual-installation">链接</a>成功安装。使用其中的命令时也会因为网络问题中断安装，这种时候不要慌，看清楚报错中说的要从哪个链接下载文件安装到什么文件夹，手动创建该文件夹，自己下载文件并放置到该文件中，然后再次运行命令，命令就会认为已经成功安装该文件，进行接下来的步骤了。</p><h2 id="haskell简介">1 Haskell简介</h2><p>Haskell 是<strong>惰性</strong>的。也就是说若非特殊指明，函数在真正需要结果以前不会被求值。</p><p>Haskell 是<strong>静态类型</strong>的。当你编译程序时，编译器需要明确哪个是数字，哪个是字符串。这就意味着很大一部分错误都可以在编译时被发现，若试图将一个数字和字符串相加，编译器就会报错。Haskell 拥有一套强大的类型系统，支持自动类型推导。</p><h2 id="haskell入门">2 Haskell入门</h2><h3 id="运算符和函数">2.1 运算符和函数</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">49</span> * <span class="number">100</span></span><br><span class="line">(<span class="number">50</span> * <span class="number">100</span>) - <span class="number">4999</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span></span><br><span class="line"><span class="type">True</span> &amp;&amp; <span class="type">False</span>   </span><br><span class="line"><span class="type">False</span> || <span class="type">True</span>   </span><br><span class="line"><span class="title">not</span> <span class="type">False</span>   </span><br><span class="line"><span class="number">5</span> == <span class="number">5</span></span><br><span class="line"><span class="number">5</span> /= <span class="number">4</span>  # 不等于的意思</span><br></pre></td></tr></table></figure><p><code>+</code>运算符要求两端都是数值，而<code>==</code>运算符仅对两个可比较的值可用。这就要求他们的类型都必须一致。<code>5+4.0</code>是可以执行的，5既可以做被看做整数也可以被看做浮点数，但4.0则不能被看做整数。<code>*</code>是一个将两个数相乘的函数，就像三明治一样，用两个参数将它夹在中央，这被称作中缀函数。而其他大多数不能与数夹在一起的函数则被称作前缀函数。绝大部分函数都是前缀函数，在接下来我们就不多做甄别。大多数命令式编程语言中的函数调用形式通常就是函数名，括号，由逗号分隔的参数表。而在haskell中，函数调用的形式是<code>函数名，空格，空格分隔的参数表</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">succ <span class="number">8</span>  <span class="comment"># 返回一个数的后继</span></span><br><span class="line"><span class="built_in">min</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="built_in">max</span> <span class="number">100</span> <span class="number">101</span> </span><br></pre></td></tr></table></figure><p><strong>函数调用拥有最高的优先级</strong>，如下两句是等效的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">succ</span> <span class="number">9</span> + max <span class="number">5</span> <span class="number">4</span> + <span class="number">1</span></span><br><span class="line">(succ <span class="number">9</span>) + (max <span class="number">5</span> <span class="number">4</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果<strong>某函数有两个参数，可以用 ` 符号将它括起，以中缀函数的形式调用它</strong>。例如取两个整数相除所得商的<code>div</code>函数，<code>div 92 10</code>可得9，但这种形式不容易理解：究竟是哪个数是除数，哪个数被除？使用中缀函数的形式<code>92 `div` 10</code>就更清晰了。从命令式编程走过来的人们往往会觉得函数调用与括号密不可分，在C中，调用函数必加括号，就像<code>foo()</code>，<code>bar(1)</code>，或者<code>baz(3,"haha")</code>。而在Haskell中，函数的调用必使用空格，例如<code>bar (bar 3)</code>，它并不表示以bar和3两个参数去调用bar，而是以bar 3所得的结果作为参数去调用bar。在C中，就相当于<code>bar(bar(3))</code>。</p><p>自定义函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleMe</span> x = x + x </span><br></pre></td></tr></table></figure><p>函数的声明与它的调用形式大体相同，都是先函数名，后跟由空格分隔的参数表。但在声明中一定要在<code>=</code>后面定义函数的行为。</p><p><code>+</code>运算符对整数和浮点都可用（实际上所有有数字特征的值都可以），所以我们的函数可以处理一切数值。声明一个包含两个参数的函数如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleUs</span> x y = x*<span class="number">2</span> + y*<span class="number">2</span>  </span><br><span class="line"><span class="title">doubleUs</span> x y = x + x + y + y  # 二者同级</span><br><span class="line"></span><br><span class="line"><span class="title">doubleMe</span> x = x + x</span><br><span class="line"><span class="title">doubleUs</span> x y = doubleMe x + doubleMe y </span><br><span class="line"><span class="title">main</span> = print(doubleUs <span class="number">5</span> <span class="number">4</span>)   </span><br></pre></td></tr></table></figure><p><strong>Haskell中的函数没有顺序</strong>，所以先声明doubleUs还是先声明doubleMe都是同样的。如下，我们编写一个函数，它将小于100的数都乘以2，因为大于100的数都已经足够大了！（实验之后发现不需要缩进）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleSmallNumber</span> x = <span class="keyword">if</span> x &gt; <span class="number">100</span>                           </span><br><span class="line">    <span class="keyword">then</span> x                           </span><br><span class="line">    <span class="keyword">else</span>  x*<span class="number">2</span></span><br><span class="line"><span class="title">main</span> = print(doubleSmallNumber <span class="number">50</span>)</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleSmallNumber&#x27;</span> x = (<span class="keyword">if</span> x &gt; <span class="number">100</span> <span class="keyword">then</span> x <span class="keyword">else</span> x*<span class="number">2</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>若是去掉括号，那就会只在小于100的时候加1。注意函数名最后的那个单引号，它没有任何特殊含义，只是一个函数名的合法字符罢了。通常，我们使用单引号来区分一个稍经修改但差别不大的函数。定义这样的函数也是可以的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">conanO&#x27;Brien</span> = <span class="string">&quot;It&#x27;s a-me, Conan O&#x27;Brien!&quot;</span> </span><br></pre></td></tr></table></figure><p>在这里有两点需要注意。首先就是我们没有大写conan的首字母，因为<strong>首字母大写的函数是不允许的</strong>，稍后我们将讨论其原因；另外就是这个函数并没有任何参数。<strong>没有参数的函数通常被称作“定义”（或者“名字”），一旦定义，conanO'Brien就与字符串"It's a-me, Conan O'Brien!"完全等价，且它的值不可以修改。</strong></p><h3 id="list入门">2.2 List入门</h3><p>在Haskell中，List是最常用的数据结构，并且十分强大，灵活地使用它可以解决很多问题。本节我们将对List，字符串和list comprehension有个初步了解。 在Haskell中，List是一种<strong>单类型的数据结构</strong>，可以用来存储多个类型相同的元素。我们可以在里面装一组数字或者一组字符，但不能把字符和数字装在一起。</p><blockquote><p>Note：在ghci下，我们可以使用let关键字来定义一个常量。在ghci下执行<code>let a = 1</code>与在脚本中编写a=1是等价的</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lostNumbers</span> = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print(lostNumbers)</span><br></pre></td></tr></table></figure><p>一个List由方括号括起，其中的元素用逗号分隔开来。若试图写<code>[1,2,'a',3,'b','c',4]</code>这样的List，Haskell就会报出这几个字符不是数字的错误。字符串实际上就是一组字符的List，"Hello"只是<code>['h','e','l','l','o']</code>的语法糖而已。所以我们可以使用处理List的函数来对字符串进行操作。 将两个List合并是很常见的操作，这可以通过++运算符实现。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span> ++ <span class="string">&quot; &quot;</span> ++ <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>在使用<code>++</code>运算符处理长字符串时要格外小心(对长List也是同样)，Haskell会遍历整个的List（++符号左边的那个）。在处理较短的字符串时问题还不大，但要是在一个5000万长度的List上追加元素，那可得执行好一会儿了。所以说，用<code>:</code>运算符<strong>往一个List前端插入元素会是更好的选择</strong>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;<span class="type">A&#x27;</span>:<span class="string">&quot; SMALL CAT&quot;</span>   </span><br><span class="line"><span class="string">&quot;A SMALL CAT&quot;</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] </span><br></pre></td></tr></table></figure><p><code>:</code>运算符可以连接一个元素到一个List或者字符串之中，而<code>++</code>运算符则是连接两个List。若要使用<code>++</code>运算符连接单个元素到一个List之中，就用方括号把它括起使之成为单个元素的List。<code>[1,2,3]</code>实际上是<code>1:2:3:[]</code>的语法糖。<code>[]</code>表示一个空List，若要从前端插入3，它就成了<code>[3]</code>，再插入2，它就成了<code>[2,3]</code>，以此类推。</p><blockquote><p><strong>Note</strong>:<code>[],[[]],[[],[],[]]</code>是不同的。第一个是一个空的List，第二个是含有一个空List的List，第三个是含有三个空List的List。</p></blockquote><p>若是要按照索引取得List中的元素，可以使用<code>!!</code>运算符，索引的下标为0。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;Steve Buscemi&quot;</span> !! <span class="number">6</span>   </span><br><span class="line">&#x27;<span class="type">B&#x27;</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">9.4</span>,<span class="number">33.2</span>,<span class="number">96.2</span>,<span class="number">11.2</span>,<span class="number">23.25</span>] !! <span class="number">1</span>   </span><br><span class="line"><span class="number">33.2</span> </span><br></pre></td></tr></table></figure><p>若是试图在一个只含有4个元素的List中取它的第6个元素，就会<strong>报错</strong>。</p><p>List同样也可以用来装List，甚至是List的List的List：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> b = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]   </span><br><span class="line"><span class="title">ghci</span>&gt; b   </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]   </span><br><span class="line"><span class="title">ghci</span>&gt; b ++ [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]   </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]:b   </span><br><span class="line">[[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]   </span><br><span class="line"><span class="title">ghci</span>&gt; b !! <span class="number">2</span>   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br></pre></td></tr></table></figure><p>List中的List可以是不同长度，但必须得是相同的类型。不可以在List中混合放置字符和数组，也不可以混合放置数值和字符。</p><p>当List内装有可比较的元素时，使用<code>&gt;</code>和<code>&gt;=</code>可以比较List的大小。它会先比较第一个元素，若它们的值相等，则比较下一个，以此类推。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] &gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] &gt; [<span class="number">2</span>,<span class="number">10</span>,<span class="number">100</span>]   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>] &gt; [<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>] &gt; [<span class="number">2</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>] == [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]   </span><br><span class="line"><span class="type">True</span> </span><br></pre></td></tr></table></figure><p>如下是几个常用的函数:</p><p><code>head</code>返回一个List的头部，也就是List的首个元素。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; head [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><code>tail</code>返回一个List的尾部，也就是List除去头部之后的部分。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; tail [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]   </span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br></pre></td></tr></table></figure><p><code>last</code>返回一个List的最后一个元素。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; last [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]   </span><br><span class="line"><span class="number">1</span>  </span><br></pre></td></tr></table></figure><p><code>init</code>返回一个List出去最后一个元素的部分。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; init [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]   </span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]  </span><br></pre></td></tr></table></figure><p><code>null</code>检查一个List是否为空。如果是，则返回True，否则返回False。应当避免使用<code>xs==\[\]</code>之类的语句来判断List是否为空，使用<code>null</code>会更好。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; null [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]   </span><br><span class="line"><span class="type">False</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; null []   </span><br><span class="line"><span class="type">True</span> </span><br></pre></td></tr></table></figure><p><code>reverse</code>将一个List反转。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; reverse [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] </span><br></pre></td></tr></table></figure><p><code>take</code>返回一个List的前几个元素，看：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">3</span> [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]   </span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">1</span> [<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>]   </span><br><span class="line">[<span class="number">3</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">5</span> [<span class="number">1</span>,<span class="number">2</span>]   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">0</span> [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]  </span><br><span class="line">[] </span><br></pre></td></tr></table></figure><p>如上，<strong>若是取超过List长度的元素个数，只能得到原List；若take 0个元素，则会得到一个空List！</strong><code>drop</code>与<code>take</code>的用法大体相同，它会<strong>删除</strong>一个List中的前几个元素。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; drop <span class="number">3</span> [<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]   </span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; drop <span class="number">0</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; drop <span class="number">100</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line">[]  </span><br></pre></td></tr></table></figure><p><code>maximum</code>返回一个List中最大的那个元素。<code>minimun</code>返回最小的。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; minimum [<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]   </span><br><span class="line"><span class="number">1</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; maximum [<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="number">9</span>  </span><br></pre></td></tr></table></figure><p><code>sum</code>返回一个List中所有元素的和。<code>product</code>返回一个List中所有元素的积。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sum [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>]   </span><br><span class="line"><span class="number">31</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; product [<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]   </span><br><span class="line"><span class="number">24</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; product [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>]   </span><br><span class="line"><span class="number">0</span>  </span><br></pre></td></tr></table></figure><p><code>elem</code>判断一个元素是否在包含于一个List，通常以中缀函数的形式调用它。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `elem` [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">10</span> `elem` [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]   </span><br><span class="line"><span class="type">False</span> </span><br></pre></td></tr></table></figure><h3 id="更多list函数">2.3 更多list函数</h3><p>怎样得到一个包含1到20之间所有数的List？可以用区间（Range）。Range是构造List方法之一，而其中的值必须是可枚举的，像1、2、3、4...。字符同样也可以枚举，字母表就是A . . Z所有字符的枚举。而名字就不可以枚举了。</p><p>要得到包含1到20中所有自然数的List，只要[1 . . 20]即可。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1.</span><span class="number">.20</span>]   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;a&#x27;..&#x27;z&#x27;]   </span><br><span class="line"><span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;<span class="type">K&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]   </span><br><span class="line"><span class="string">&quot;KLMNOPQRSTUVWXYZ&quot;</span></span><br></pre></td></tr></table></figure><p>Range允许你申明一个步长。要得到1到20间所有的偶数或者3的倍数该怎样？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>, <span class="number">4.</span><span class="number">.20</span>] </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>, <span class="number">6.</span><span class="number">.20</span>]   </span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]  </span><br></pre></td></tr></table></figure><p><strong>仅需用逗号将前两个元素隔开，再标上上限即可。</strong>可惜的是不能通过[ 1 , 2 , 4 . . 100 ]这样的语句来获得所有2的幂。一方面是因为<strong>步长只能标明一次</strong>，另一方面就是<strong>仅凭前几项，数组的后项是不能确定的</strong>。要得到20到1的List，[20..1]是不可以的。必须得<code>[20,19. .1]</code>。在Range中使用浮点数要格外小心！出于定义的原因，浮点数并不精确。若是使用浮点数的话就会得到如下的糟糕结果</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">0.1</span>, <span class="number">0.3</span>.<span class="number">.1</span>]   </span><br><span class="line">[<span class="number">0.1</span>,<span class="number">0.3</span>,<span class="number">0.5</span>,<span class="number">0.7</span>,<span class="number">0.8999999999999999</span>,<span class="number">1.0999999999999999</span>] </span><br></pre></td></tr></table></figure><p>建议避免在Range中使用浮点数。</p><p>也可以不标明Range的上限，从而得到一个无限长度的List。后面会讲解关于无限List的更多细节。取前24个13的倍数该怎样？完全可以<code>[13 , 26 . . 24 * 13]</code>，但有更好的方法：<code>take 24 [13 , 26 .. ]</code>。</p><p>由于Haskell是惰性的，它不会对无限长度的List求值，而是等着看会取多少。如下是几个生成无限List的函数。<strong><code>cycle</code>接受一个List做参数并返回一个无限List。</strong>如果你只是想看一下它的运算结果而已，它会运行个没完的。所以应该在某处划好范围。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">12</span> (cycle <span class="string">&quot;LOL &quot;</span>)   </span><br><span class="line"><span class="string">&quot;LOL LOL LOL &quot;</span>  </span><br></pre></td></tr></table></figure><p><strong><code>repeat</code>接受一个值作参数</strong>，并返回一个仅包含该值的无限List。这与用<code>cycle</code>处理单元素List差不多。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (repeat <span class="number">5</span>)   </span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>] </span><br></pre></td></tr></table></figure><p>若只是想得到包含相同元素的List，使用<code>replicate</code>会更简单，如<code>replicate 3 10</code>，得<code>[10, 10, 10]</code>。</p><h3 id="list-comprehension">2.4 List Comprehension</h3><p>学过数学的你对集合的comprehension（Set Comprehension）概念一定不会陌生。通过它，可以从既有的集合中按照规则产生一个新集合。前十个偶数的set comprehension可以表示为<span class="math inline">\(S=\{2 \cdot x \mid x \in \mathbb{N}, x \leq 10\}\)</span>。</p><p>在Haskell下可以通过类似<code>take 10 [2, 4 ..]</code>的代码来实现。但若是把简单的乘2改成更复杂的函数操作该怎么办呢？用list comprehension，它与set comprehension 十分的相似，用它取前十个偶数轻而易举。这个list comprehension可以表示为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [ x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]   </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br></pre></td></tr></table></figure><p>可以给这个comprehension再添个限制条件（predicate），它与前面的条件由一个逗号分隔。这里我们要求只取乘以2后大于等于12的元素。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [ x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>], x*<span class="number">2</span> &gt;= <span class="number">12</span>]   </span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>] </span><br></pre></td></tr></table></figure><p>取50到100间所有除7的余数为3的元素该怎么办？使用<strong>整除</strong>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50.</span><span class="number">.100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>]   </span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]  </span><br></pre></td></tr></table></figure><p>从一个List中筛选出符合特定限制条件数据的操作也可以称为过滤（flitering）。</p><p>假设想要一个comprehension，能够使list中所有大于10的奇数变为“BANG”，小于10的奇数变为“BOOM”，其他则统统扔掉。方便重用起见，我们将这个comprehension置于一个函数之中。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">boomBangs</span> xs = [ <span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">then</span> <span class="string">&quot;BOOM!&quot;</span> <span class="keyword">else</span> <span class="string">&quot;BANG!&quot;</span> | x &lt;- xs, odd x]</span><br></pre></td></tr></table></figure><p>这个comprehension的最后部分就是限制条件，使用odd函数判断是否为奇数：返回True，就是奇数，该List中的元素才被包含。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; boomBangs [<span class="number">7.</span><span class="number">.13</span>]   </span><br><span class="line">[<span class="string">&quot;BOOM!&quot;</span>,<span class="string">&quot;BOOM!&quot;</span>,<span class="string">&quot;BANG!&quot;</span>,<span class="string">&quot;BANG!&quot;</span>]  </span><br></pre></td></tr></table></figure><p>也可以加多个限制条件。若要达到 10 到 20 间所有不等于 13，15 或 19 的数，可以这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">10.</span><span class="number">.20</span>], x /= <span class="number">13</span>, x /= <span class="number">15</span>, x /= <span class="number">19</span>]  </span><br><span class="line">[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">20</span>] </span><br></pre></td></tr></table></figure><p>除了多个限制条件之外，从多个List中取元素也是可以的。这样的话comprehension会把所有的元素组合交付给我们的输出函数。在不过滤的前提下，取自两个长度为4的集合的comprehension会产生一个长度为 16 的 List。假设有两个List，[ 2 , 5 , 10 ] 和 [ 8 , 10 , 11 ] ， 要取它们所有组合的积，可以这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]]   </span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]  </span><br></pre></td></tr></table></figure><p>意料之中，得到的新 List 长度为 9 。若只取乘积大于 50 的结果该如何？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>], x*y &gt; <span class="number">50</span>] </span><br><span class="line">[<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]  </span><br></pre></td></tr></table></figure><p>取个包含一组名词和形容词的List comprehension吧，写诗的话也许用得着。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> nouns = [<span class="string">&quot;hobo&quot;</span>,<span class="string">&quot;frog&quot;</span>,<span class="string">&quot;pope&quot;</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> adjectives = [<span class="string">&quot;lazy&quot;</span>,<span class="string">&quot;grouchy&quot;</span>,<span class="string">&quot;scheming&quot;</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [adjective ++ <span class="string">&quot; &quot;</span> ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]   </span><br><span class="line">[<span class="string">&quot;lazy hobo&quot;</span>,<span class="string">&quot;lazy frog&quot;</span>,<span class="string">&quot;lazy pope&quot;</span>,<span class="string">&quot;grouchy hobo&quot;</span>,<span class="string">&quot;grouchy frog&quot;</span>, <span class="string">&quot;grouchy pope&quot;</span>,<span class="string">&quot;scheming hobo&quot;</span>, </span><br><span class="line"><span class="string">&quot;scheming frog&quot;</span>,<span class="string">&quot;scheming pope&quot;</span>] </span><br></pre></td></tr></table></figure><p>编写自己的 length 函数吧！就叫做 length '!</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length&#x27;</span> xs = sum [<span class="number">1</span> | _ &lt;- xs]  </span><br></pre></td></tr></table></figure><p><code>_</code>表示我们并不关心从 List 中取什么值。这个函数将一个 List 中所有元素置换为1，并且使其相加求和。得到的结果便是我们的 List 长度。<strong>字符串也是List，可以使用 list comprehension 来处理。</strong>如下是除去字符串中所有非大写字母的函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [&#x27;<span class="type">A&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]]  </span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; removeNonUppercase <span class="string">&quot;Hahaha! Ahahaha!&quot;</span>   </span><br><span class="line"><span class="string">&quot;HA&quot;</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; removeNonUppercase <span class="string">&quot;IdontLIKEFROGS&quot;</span>   </span><br><span class="line"><span class="string">&quot;ILIKEFROGS&quot;</span>  </span><br></pre></td></tr></table></figure><p>若操作含有 List 的 List ，使用嵌套的 List comprehension 也是可以的。假设有个包含许多数值的 List 的 List ，在不拆开它的前提下除去其中的所有奇数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> xxs = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]]   </span><br><span class="line"><span class="title">ghci</span>&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]   </span><br><span class="line">[[<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">6</span>]] </span><br></pre></td></tr></table></figure><p>将 List Comprehension 分成多行也是可以的。若非在 GHCI 之下，还是将 List Comprehension 分成多行好，尤其是需要嵌套的时候。</p><h3 id="tuple">2.5 Tuple</h3><p>从某种意义上讲，Tuple（元组）很像 List，都是将多个值存入一个个体的容器。但它们却有着本质的不同，一组数字的 List 就是一组数字，它们的类型相同，且不关心其中包含元素的数量。而<strong>Tuple 则要求你对需要组合的数据的数目非常的明确</strong>，它的类型取决于其中项的数目与其各自的类型。 Tuple 中的项由括号括起，并由逗号隔开。</p><p>另外的不同之处就是<strong>Tuple 中的项不必为同一类型</strong>，在Tuple 里可以存入多类型项的组合。</p><p>在Haskell中表示二维向量该如何？使用 List 是一种方法，它倒也工作良好。若要将一组向量置于一个 List 中来表示平面图形又该怎样？我们可以写类似 [ [ 1 , 2 ] , [ 8 , 11 ] , [ 4 , 5 ] ] 的代码来实现。但问题在于， [ [ 1 , 2 ] , [ 8 , 11 , 5 ] , [ 4 , 5 ] ] 也是同样合法的，因为其中元素的类型都相同。尽管这样并不靠谱，但编译时并不会报错。然而<strong>一个长度为 2 的 Tuple （也可以称作序对，Pair），是一个独立的类型</strong>，这便意味着一个包含一组序对的 List 不能再加入一个三元组，所以说把原先的方括号改为圆括号使用Tuple会 更好: [ ( 1 , 2 ) , ( 8 , 11 ) , ( 4 , 5 ) ]。若试图表示这样的图形： [ ( 1 , 2 ) , ( 8 , 11 , 5 ) , (4 , 5 ) ] ，就会报出以下的错误：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Couldn&#x27;t match expected type `(t, t1)&#x27;   </span><br><span class="line">against inferred type `(t2, t3, t4)&#x27;   </span><br><span class="line">In the expression: (8, 11, 5)   </span><br><span class="line">In the expression: [(1, 2), (8, 11, 5), (4, 5)]   </span><br><span class="line">In the definition of `it&#x27;: it = [(1, 2), (8, 11, 5), (4, 5)]</span><br></pre></td></tr></table></figure><p>同样，[ ( 1 , 2 ) , ( " one " , 2 ) ] 这样的 List 也不行，因为其中的第一个 Tuple 是一对数字，而第二个 Tuple 却成了一个字符串和一个数字。 Tuple 可以用来储存多个数据，如，我们要表示一个人的名字与年 龄，可以使用这样的 Tuple : ( " Christopher " , " Walken " , 55 )。从这个例子里也可以看出，<strong>Tuple 中也可以存储 List</strong>。</p><p>使用 Tuple 前应当事先明确一条数据中应该由多少个项。<strong>每个不同长度的 Tuple 都是独立的类型</strong>，所以你就不可以写个函数来给它追加元素。而唯一能做的，就是通过函数来给一个 List 追加序对，三元组或是四元组等内容。</p><p>可以有单元素的 List ，但 Tuple 不行。单元素的 Tuple 本身就只有一个值，对我们又有啥意义？不靠谱。</p><p>同 List 相同，只要其中的项是可比较的，Tuple 也可以比较大小，但是不可以比较不同长度的 Tuple 。如下是两个有用的序对操作函数：</p><p><code>fst</code>返回一个序对的首项。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fst (<span class="number">8</span>,<span class="number">11</span>)   </span><br><span class="line"><span class="number">8</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; fst (<span class="string">&quot;Wow&quot;</span>, <span class="type">False</span>)   </span><br><span class="line"><span class="string">&quot;Wow&quot;</span></span><br></pre></td></tr></table></figure><p><code>snd</code>返回序对的尾项。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; snd (<span class="number">8</span>,<span class="number">11</span>)   </span><br><span class="line"><span class="number">11</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; snd (<span class="string">&quot;Wow&quot;</span>, <span class="type">False</span>)   </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure><blockquote><p>Note：这两个函数仅对序对有效，而不能应用于三元组，四元组和五元组之上。稍后，我们将过一遍从Tuple中取数据的所有方式。</p></blockquote><p><code>zip</code>可以用来生成一组序对 (Pair) 的 List 。它取两个 List，然后将它们交叉配对，形成一组序对的 List 。它很简单，却很实用，尤其是你需要组合或是遍历两个 List时。如下是个例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]   </span><br><span class="line">[(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">5</span>)]   </span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span> .. <span class="number">5</span>] [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>]   </span><br><span class="line">[(<span class="number">1</span>,<span class="string">&quot;one&quot;</span>),(<span class="number">2</span>,<span class="string">&quot;two&quot;</span>),(<span class="number">3</span>,<span class="string">&quot;three&quot;</span>),(<span class="number">4</span>,<span class="string">&quot;four&quot;</span>),(<span class="number">5</span>,<span class="string">&quot;five&quot;</span>)]</span><br></pre></td></tr></table></figure><p>它把元素配对并返回一个新的 List 。第一个元素配第一个，第二个元素配第二个..以此类推。注意，由于序对中可以含有不同的类型，zip函数可能会将不同类型的序对组合在一起。若是两个不同长度的 List 会怎么样？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>] [<span class="string">&quot;im&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;turtle&quot;</span>]</span><br><span class="line">[(<span class="number">5</span>,<span class="string">&quot;im&quot;</span>),(<span class="number">3</span>,<span class="string">&quot;a&quot;</span>),(<span class="number">2</span>,<span class="string">&quot;turtle&quot;</span>)]</span><br></pre></td></tr></table></figure><p><strong>较长的那个会在中间断开，去匹配较短的那个</strong>。由于Haskell是惰性的，使用<code>zip</code>同时处理有限和无限的 List 也是可以的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1.</span>.] [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;mango&quot;</span>]  </span><br><span class="line">[(<span class="number">1</span>,<span class="string">&quot;apple&quot;</span>),(<span class="number">2</span>,<span class="string">&quot;orange&quot;</span>),(<span class="number">3</span>,<span class="string">&quot;cherry&quot;</span>),(<span class="number">4</span>,<span class="string">&quot;mango&quot;</span>)]</span><br></pre></td></tr></table></figure><p>接下来考虑一个同时应用到 List 和 Tuple 的问题：如何取得所有三边长度皆为整数且小于等于10，周长为24的直角三角形？首先，把所有三遍长度小于等于 10 的三角形都列出来：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; let triangles = [ (a,b,c) | c &lt;-  [1..10], b &lt;-  [1..10], a &lt;- [1..10] ]</span><br></pre></td></tr></table></figure><p>刚才我们是从三个 List 中取值，并且通过输出函数将其组合为一个三元组。只要在 ghci 下边调用 triangle ，你就会得到所有三边都小于等于 10的三角形。我们接下来给它添加一个限制条件，令其必须为直角三角形。同时也考虑上b边要短于斜边，a边要短于b边情况：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2]</span><br></pre></td></tr></table></figure><p>已经差不多了。最后修改函数，告诉它只要周长为24的三角形。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; let rightTriangles&#x27; = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]   ghci&gt; rightTriangles&#x27;   </span><br><span class="line">[(6,8,10)]</span><br></pre></td></tr></table></figure><p>得到正确结果！这便是函数式编程的一般思路：先取一个初始的集合并将其变形，执行过滤条件，最终取得正确的结果。</p><h2 id="haskell类型和类型类">3 Haskell类型和类型类</h2><h3 id="类型">3.1 类型</h3><p>在前面我们谈到Haskell是静态类型的，在<strong>编译时每个表达式的类型都已明确</strong>，这就<strong>提高了代码的安全性</strong>。若代码中让布尔值与数字相除，就不会通过编译。这样的好处就是与其让程序在运行时崩溃，不如在编译时捕获可能的错误。Haskell中万物皆有类型，因此在执行编译之时编译器可以大有所为。</p><p>与java和pascal不同，<strong>haskell支持类型推导</strong>。写下一个数字，你就没必要另告诉haskell说“它是个数字”，它自己能推导出来。这样我们就不必在每个函数或表达式上都标明其类型了。在前面我们只简单涉及一下haskell的类型方面的知识，但是理解这一类型系统对于haskell 的学习是至关重要的。</p><p>类型是每个表达式都有的某种标签，它标明了这一表达式所属的范畴。例如，表达式<code>True</code>是boolean型，<code>"hello"</code>是个字符串，等等。</p><p>可以使用ghci来检测表达式的类型。使用:t命令后跟任何可用的表达式，即可得到该表达式的类型，先试一下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t &#x27;a&#x27;   </span><br><span class="line">&#x27;a&#x27; :: <span class="type">Char</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">True</span>   </span><br><span class="line"><span class="type">True</span> :: <span class="type">Bool</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="string">&quot;HELLO!&quot;</span>   </span><br><span class="line"><span class="string">&quot;HELLO!&quot;</span> :: [<span class="type">Char</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; :t (<span class="type">True</span>, &#x27;a&#x27;)   </span><br><span class="line">(<span class="type">True</span>, &#x27;a&#x27;) :: (<span class="type">Bool</span>, <span class="type">Char</span>)   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="number">4</span> == <span class="number">5</span>   </span><br><span class="line"><span class="number">4</span> == <span class="number">5</span> :: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>可以看出，<code>:t</code>命令处理一个表达式的输出结果为表达式后跟<code>::</code>及其类型，<code>::</code>读作“它的类型为”。凡是明确的类型，其首字母必为大写。<code>'a'</code>，如它的样子，是<code>Char</code>类型，易知是个字符（character）。<code>True</code>是<code>Bool</code>类型。检测<code>"hello"</code>得一个<code>[Char]</code>？这方括号表示一个List，所以我们可以将其读作“一组字符的List”。而与List不同，<strong>每个Tuple都是独立的类型</strong>，于是<code>(True,"a")</code>的类型是<code>(Bool,Char)</code>，而<code>('a','b','c')</code>的类型为<code>(Char,Char,Char)</code>。<code>4==5</code>一定返回 False，所以它的类型为Bool。</p><p>同样，函数也有类型。编写函数时，给它一个明确的类型声明是个好习惯，比较短的函数就不用多此一举了。还记得前面那个过滤大写字母的List Comprehension吗？给它加上类型声明便是这个样子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]   </span><br><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [&#x27;<span class="type">A&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]]</span><br></pre></td></tr></table></figure><p><code>removeNonUppercase</code>的类型为<code>[Char]-&gt;[Char]</code>，从它的参数和返回值的类型上可以看出，它将一个字符串映射为另一个字符串。<code>[Char]</code>与<code>String</code>是等价的，但使用String会更清晰：<code>removeNonUppercase :: String -&gt; String</code>。编译器会自动检测出它的类型，我们还是标明了它的类型声明。要是多个参数的函数该怎样？如下便是一个将三个整数相加的简单函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>   </span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure><p><strong>参数之间由-&gt;分隔，而与返回值之间并无特殊差异。返回值是最后一项，参数就是前三项</strong>。稍后，我们将讲解为何只用<code>-&gt;</code>而不是<code>Int,Int,Int-&gt;Int</code>之类“更好看”的方式来分隔参数。</p><p>如果你打算给你编写的函数加上个类型声明却拿不准它的类型是啥，只要<strong>先不写类型声明，把函数体写出来，再使用:t命令测一下即可。</strong>函数也是表达式，所以<code>:t</code>对函数也是同样可用的。</p><p>如下是几个常见的类型：</p><p><code>Int</code>表示整数。7可以是Int，但7.2不可以。<code>Int</code>是有界的，也就是说它由上限和下限。对32位的机器而言，上限一般是214748364，下限是-214748364。</p><p><code>Integer</code>也表示整数，但它是无界的。这就意味着可以用它存放非常非常大的数，我是说非常大。它的效率不如Int高。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span>   </span><br><span class="line"><span class="title">factorial</span> n = product [<span class="number">1.</span>.n]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; factorial 50   </span><br><span class="line">30414093201713378043612608166064768844377641568960512000000000000</span><br></pre></td></tr></table></figure><p><code>Float</code>表示单精度的浮点数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">circumference</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>   </span><br><span class="line"><span class="title">circumference</span> r = <span class="number">2</span> * pi * r</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; circumference <span class="number">4.0</span>   </span><br><span class="line"><span class="number">25.132742</span></span><br></pre></td></tr></table></figure><p><code>Double</code>表示双精度的浮点数。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">circumference&#x27; :: Double -&gt; Double   </span><br><span class="line">circumference&#x27; r = 2 * pi * r</span><br><span class="line"></span><br><span class="line">ghci&gt; circumference&#x27; 4.0   </span><br><span class="line">25.132741228718345</span><br></pre></td></tr></table></figure><p><code>Bool</code>表示布尔值，它只有两种值：<code>Tru</code>e和<code>False</code>。</p><p><code>Char</code>表示一个字符。一个字符由单引号括起，一组字符的List即为字符串。</p><p>Tuple的类型取决于它的长度及其中项的类型。注意，空Tuple同样也是个类型，它只有一种值：<code>()</code>。</p><h3 id="类型变量">3.2 类型变量</h3><p>你觉得head函数的类型是啥？它可以取任意类型的List的首项，是怎么做到的呢？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t head   </span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br></pre></td></tr></table></figure><p>前面说过，<strong>凡是类型其首字母必大写，所以它不会是个类型</strong>。它是个类型变量，意味着a可以是任意的类型。这一点与其他语言中的泛型（generic）很相似，但在Haskell中要更为强大。它可以让我们轻而易举地写出类型无关的函数。<strong>使用到类型变量的函数被称作“多态函数 ”</strong>，<code>head</code>函数的类型声明里标明了它可以取任意类型的List并返回其中的第一个元素。</p><p>在命名上，类型变量使用多个字符是合法的，不过约定俗成，通常都是使用单个字符，如a,b,c,d...</p><p>还记得<code>fst</code>？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fst   </span><br><span class="line"><span class="title">fst</span> :: (a, b) -&gt; a</span><br></pre></td></tr></table></figure><p>可以看到<code>fst</code>取一个包含两个类型的Tuple作参数，并以第一个项的类型作为返回值。这便是<code>fst</code>可以处理一个含有两种类型项的pair的原因。注意，a和b是不同的类型变量，但它们不一定非得是不同的类型，它只是标明了首项的类型与返回值的类型相同。</p><h3 id="类型类">3.3 类型类</h3><p>如果一个类型属于某类型类，那它必实现了该类型类所描述的行为。很多从OOP走过来的人们往往会把类型类当成面向对象语言中的类而感到疑惑，但它们不是一回事。<strong>易于理解起见，可以把它看做是java中接口（interface）的类似物</strong>。</p><p><code>==</code>函数的类型声明是怎样的？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t (==)   </span><br><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Note</strong>:判断相等的<code>==</code>运算符是函数，<code>+-\*/</code>之类的运算符也是同样。在默认条件下，它们多为中缀函数。若要检查它的类型，就必须得用括号括起使之作为另一个函数，或者说以前缀函数的形式调用它。</p></blockquote><p>在这里我们见到个新东西：<code>=&gt;</code>符号。它左边的部分叫做类型约束。我们可以这样阅读这段类型声明：“相等函数取两个相同类型的值作为参数并返回一个布尔值，而这两个参数的类型同在<code>Eq</code>类之中（即类型约束）”</p><p><code>Eq</code>这一类型类提供了判断相等性的接口，凡是可比较相等性的类型必属于<code>Eq</code>类。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> == <span class="number">5</span>    </span><br><span class="line"><span class="type">True</span>    </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> /= <span class="number">5</span>    </span><br><span class="line"><span class="type">False</span>    </span><br><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; == &#x27;a&#x27;    </span><br><span class="line"><span class="type">True</span>    </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;Ho Ho&quot;</span> == <span class="string">&quot;Ho Ho&quot;</span>    </span><br><span class="line"><span class="type">True</span>    </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">3.432</span> == <span class="number">3.432</span>    </span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure><p><code>elem</code>函数的类型为:<code>(Eq a)=&gt;a-&gt;[a]-&gt;Bool</code>。（竹夭曰：现在是<code>elem :: (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool</code>）这是它在检测值是否存在于一个list时使用到了==的缘故。</p><p>几个基本的类型类：</p><p><code>Eq</code>包含可判断相等性的类型。提供实现的函数是<code>==</code>和<code>/=</code>。所以，只要一个函数有<code>Eq</code>类的类型限制，那么它就必定在定义中用到了<code>==</code>和<code>/=</code>。刚才说了，<strong>除函数以外的所有类型都属于<code>Eq</code>，所以它们都可以判断相等性</strong>。</p><p><code>Ord</code>包含可比较大小的类型。除了函数以外，我们目前所谈到的所有类型都属于<code>Ord</code>类。<code>Ord</code>包中包含了<code>&gt;, &lt;, =</code>之类用于比较大小的函数。<code>compare</code>函数取两个<code>Ord</code>类中的相同类型的值作参数，返回比较的结果。这个结果是如下三种类型之一：<code>GT, LT, EQ</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t (&gt;)   </span><br><span class="line">(&gt;) :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>类型若要成为<code>Ord</code>的成员，必先加入<code>Eq</code>家族。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;Abrakadabra&quot;</span> &lt; <span class="string">&quot;Zebra&quot;</span>   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;Abrakadabra&quot;</span> `compare` <span class="string">&quot;Zebra&quot;</span>   </span><br><span class="line"><span class="type">LT</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> &gt;= <span class="number">2</span>   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> `compare` <span class="number">3</span>   </span><br><span class="line"><span class="type">GT</span></span><br></pre></td></tr></table></figure><p><code>Show</code>的成员为<strong>可用字符串表示的类型</strong>。目前为止，除函数以外的所有类型都是<code>Show</code>的成员。操作<code>Show</code>类型类，最常用的函数表示<code>show</code>。它可以取任一<code>Show</code>的成员类型并将其转为字符串。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; show <span class="number">3</span>   </span><br><span class="line"><span class="string">&quot;3&quot;</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; show <span class="number">5.334</span>   </span><br><span class="line"><span class="string">&quot;5.334&quot;</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; show <span class="type">True</span>   </span><br><span class="line"><span class="string">&quot;True&quot;</span></span><br></pre></td></tr></table></figure><p><code>Read</code>是与<code>Show</code>相反的类型类。read函数可以将一个字符串转为<code>Read</code>的某成员类型。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;True&quot;</span> || <span class="type">False</span>   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;8.2&quot;</span> + <span class="number">3.8</span>   </span><br><span class="line"><span class="number">12.0</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;5&quot;</span> - <span class="number">2</span>   </span><br><span class="line"><span class="number">3</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;[1,2,3,4]&quot;</span> ++ [<span class="number">3</span>]   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>一切良好，如上的所有类型都属于这一类型类。尝试read "4"又会怎样？（竹夭曰：这里报错是因为“4”没有被用到，编译器不能确定“4”是什么类型）</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; read &quot;4&quot;   </span><br><span class="line">&lt; interactive &gt;:1:0:   </span><br><span class="line">    Ambiguous type variable `a&#x27; in the constraint:   </span><br><span class="line">      `Read a&#x27; arising from a use of `read&#x27; at :1:0-7   </span><br><span class="line">    Probable fix: add a type signature that fixes these type variable(s)</span><br></pre></td></tr></table></figure><p>ghci跟我们说它搞不清楚我们想要的是什么样的返回值。注意调用read后跟的那部分，ghci通过它来辨认其类型。若要一个boolean值，他就知道必须得返回一个Bool类型的值。但在这里它只知道我们要的类型属于Read类型类，而不能明确到底是哪个。看一下read函数的类型声明吧：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t read   </span><br><span class="line"><span class="title">read</span> :: (<span class="type">Read</span> a) =&gt; <span class="type">String</span> -&gt; a</span><br></pre></td></tr></table></figure><p><strong>它的返回值属于Read类型类，但我们若用不到这个值，编译器就永远都不会得知该表达式的类型。</strong>所以我们需要在一个表达式后跟<code>::</code>的<strong>类型注释</strong>，以明确其类型。如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;5&quot;</span> :: <span class="type">Int</span>   </span><br><span class="line"><span class="number">5</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;5&quot;</span> :: <span class="type">Float</span>   </span><br><span class="line"><span class="number">5.0</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; (read <span class="string">&quot;5&quot;</span> :: <span class="type">Float</span>) * <span class="number">4</span>   </span><br><span class="line"><span class="number">20.0</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;[1,2,3,4]&quot;</span> :: [<span class="type">Int</span>]   </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">&quot;(3, &#x27;a&#x27;)&quot;</span> :: (<span class="type">Int</span>, <span class="type">Char</span>)   </span><br><span class="line">(<span class="number">3</span>, &#x27;a&#x27;)</span><br></pre></td></tr></table></figure><p>编译器可以辨认出大部分表达式的类型，但遇到<code>read "5"</code>的时候它就搞不清楚究竟该是<code>Int</code>还是<code>Float</code>了。只有经过运算，Haskell才会明确其类型；同时由于Haskell是静态的，它还必须得在编译前搞清楚所有值的类型，所以我们最好提前告诉编译器。</p><p><code>Enum</code>的成员都是连续的类型--也就是可枚举。<code>Enum</code>类存在的主要好处就在于我们可以在Range中用到它的成员类型：每个值都有后继子（successer）和前置子（predecesor），分别可以通过<code>succ</code>函数和<code>pred</code>函数得到。该类型类包含的类型有：<code>()</code>,<code>Bool</code>,<code>Char</code>,<code>Ordering</code>,<code>Int</code>,<code>Integer</code>,<code>Float</code>和<code>Double</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [&#x27;a&#x27;..&#x27;e&#x27;]   </span><br><span class="line"><span class="string">&quot;abcde&quot;</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="type">LT</span> .. <span class="type">GT</span>]   </span><br><span class="line">[<span class="type">LT</span>,<span class="type">EQ</span>,<span class="type">GT</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span> .. <span class="number">5</span>]   </span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; succ &#x27;<span class="type">B&#x27;</span>   </span><br><span class="line">&#x27;<span class="type">C&#x27;</span></span><br></pre></td></tr></table></figure><p><code>Bounded</code>的成员都有一个上限和下限。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; minBound :: <span class="type">Int</span>   </span><br><span class="line"><span class="number">-2147483648</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; maxBound :: <span class="type">Char</span>   </span><br><span class="line">&#x27;\<span class="number">1114111</span>&#x27;   </span><br><span class="line"><span class="title">ghci</span>&gt; maxBound :: <span class="type">Bool</span>   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; minBound :: <span class="type">Bool</span>   </span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure><p><code>minBound</code>和<code>maxBound</code>函数很有趣，它们的类型都是<code>(Bounded a) =&gt; a</code>。可以说，它们都是多态常量。</p><p>如果其中的项都属于<code>Bounded</code>类型类，那么该Tuple也属于<code>Bounded</code> 。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; maxBound :: (<span class="type">Bool</span>, <span class="type">Int</span>, <span class="type">Char</span>)   </span><br><span class="line">(<span class="type">True</span>,<span class="number">2147483647</span>,&#x27;\<span class="number">1114111</span>&#x27;)</span><br></pre></td></tr></table></figure><p><code>Num</code>是表示数字的类型类，它的成员类型都具有数字的特征。检查一个数字的类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t <span class="number">20</span>   </span><br><span class="line"><span class="number">20</span> :: (<span class="type">Num</span> t) =&gt; t</span><br></pre></td></tr></table></figure><p><strong>所有的数字都是多态常量</strong>，他们可以作为所有<code>Num</code>类型类中的成员类型。以上便是<code>Num</code>类型类中包含的所有类型，检测<code>*</code>运算符的类型，可以发现它可以处理一切的数字：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t (*)   </span><br><span class="line">(*) :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>它只取两个相同类型的参数。所以<code>(5 :: Int) * (6 :: Integer)</code>会引发一个类型错误，而<code>5 * (6 :: Integer)</code>就不会有问题。</p><p>类型只有继承<code>Show</code>和<code>Eq</code>，才可以加入<code>Num</code>。</p><p><code>Integral</code>同样是表示数字的类型类。<code>Num</code>包含所有的数字：实数和整数。而<code>Intgral</code>仅包含整数，其中的成员类型有<code>Int</code>和<code>Integer</code>。<code>Floating</code>仅包含浮点类型：<code>Float</code>和<code>Double</code>。</p><p>有个函数在处理数字时会非常有用，它便是<code>fromIntegral</code>。其类型声明为：<code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>。从中可以看出，它取一个整数做参数并返回一个更加通用的数字，这在同时处理整数和浮点时会尤为有用。举例来说，<code>length</code>函数的类型声明为：<code>length :: [a] -&gt; Int</code>，而非更通用的形式，如<code>(Num b) =&gt; length :: [a] -&gt; b</code>。这应该是历史原因，如果取了一个List长度的值再给它加3.2就会报错，因为这是将浮点数和整数相加。面对这种情况，我们就用<code>fromIntegral (length [1,2,3,4]) + 3.2</code>来解决。</p><p>注意到，<code>fromIntegral</code>的类型声明中用到了多个类型约束。如你所见，<strong>只要将多个类型约束放到括号里用逗号隔开即可</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AnalogueElectronics2】课程笔记</title>
      <link href="/2119635949.html"/>
      <url>/2119635949.html</url>
      
        <content type="html"><![CDATA[<h2 id="online-syllabus">0 Online Syllabus</h2><p>Block 1:</p><ul><li>block models of analogue;</li><li>op-amps（运放）.</li></ul><p>Block 2: Diodes.</p><p>Block 3: Transistors</p><ul><li>Bipolar and field effect transistor;</li><li>Transistor biasing circuits;</li><li>Analysis of small-signal AC circuits.</li></ul><p>这篇博文只是我的课程笔记，所以不可能达到课件那种精细程度，还请读者海涵。</p><h2 id="block-1">1 Block 1</h2><h3 id="amplifiers">1.1 Amplifiers</h3><ul><li>Amplifiers from system prospective;</li><li>Bode Plot;</li><li>Decibels and how we can understand them.</li></ul><p>Matching conditions：放大器输入电阻远大于电源电阻，放大器输出电阻远小于负载电阻。</p><p>Amplifier Classifications</p><table><colgroup><col style="width: 16%" /><col style="width: 5%" /><col style="width: 6%" /><col style="width: 28%" /><col style="width: 23%" /><col style="width: 22%" /></colgroup><thead><tr class="header"><th style="text-align: center;">Type</th><th style="text-align: center;">Input</th><th style="text-align: center;">Output</th><th style="text-align: center;">Gain</th><th style="text-align: center;">Matching Conditions</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Voltage</td><td style="text-align: center;">V</td><td style="text-align: center;">V</td><td style="text-align: center;"><span class="math inline">\(K_v=\frac{V_{out}}{V_{in}}\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{in}\gg R_s(\infty)\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{O}\gg R_L(0)\)</span></td></tr><tr class="even"><td style="text-align: center;">Current</td><td style="text-align: center;">I</td><td style="text-align: center;">I</td><td style="text-align: center;"><span class="math inline">\(K_I=\frac{I_{out}}{I_{in}}\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{in}\ll R_s(0)\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{O}\gg R_L(\infty)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Transresistance</td><td style="text-align: center;">I</td><td style="text-align: center;">V</td><td style="text-align: center;"><span class="math inline">\(R_m=\frac{V_{out}}{I_{in}}\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{in}\ll R_s(0)\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{O}\ll R_L(0)\)</span></td></tr><tr class="even"><td style="text-align: center;">Transconductance</td><td style="text-align: center;">V</td><td style="text-align: center;">I</td><td style="text-align: center;"><span class="math inline">\(G_m=\frac{I_{out}}{V_{in}}\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{in}\gg R_s(\infty)\)</span></td><td style="text-align: center;"><span class="math inline">\(R_{O}\gg R_L(\infty)\)</span></td></tr></tbody></table><p>Efficiency: 功率，用<span class="math inline">\(\eta\)</span>表示。</p><p><span class="math inline">\(P_{in}+P_{DC}=P_L+P_{diss}\)</span>；<span class="math inline">\(\eta=\frac{P_L}{P_{DC}}\times 100\%\)</span>.</p><p>单端or多端输入输出。</p><p>波特图：展示放大器的频率响应。Gain用分贝表示，横轴是log10为底的频率。</p><p>典型的放大器：</p><ol type="1"><li>通频带，放大倍数和频率无关；</li><li>上限截止频率和下限截止频率，增益比中频段少3分贝。</li></ol><p>分贝：dB，放大器增益的单位。电学中的分贝定义的是信号放大倍数的对数，对电压（电流）与功率放大倍数的定义是不同的。</p><p>电压（电流）放大倍数分贝数定义：<span class="math inline">\(K=20\log\left|\frac{V_O}{V_I}\right|\)</span>；</p><p>功率放大倍数分贝数定义：<span class="math inline">\(K=10\log\left|\frac{P_O}{P_I}\right|\)</span>。</p><p><span class="math inline">\(K&lt;0\)</span>，信号被衰减；<span class="math inline">\(K&gt;0\)</span>，信号被放大。</p><p>Negative gain indicates a phase change of <span class="math inline">\(180^o\)</span> between input and output signals.</p><p>截止频率是-3dB的情形，相当于输出功率变为输入功率的一半，输出电压或电流变为输入的0.707倍。</p><p>dBm是分贝毫瓦，代指功率的<strong>绝对值</strong>。<span class="math inline">\(0\operatorname{dBm}=1\operatorname{mW}\)</span>。</p><p>放大器系统的频率响应：</p><ul><li>完美耦合情况下的信号增益；</li><li>造成信号损失的因素，可能是因为不完美耦合或故意造成衰减。</li></ul><p>要得到总的频率响应，只需将波特图叠加到一起。</p><p>例题：介绍了串级系统如何计算增益，以及如何设计得到所需增益的电路。</p><h3 id="operational-amplifiers">1.2 Operational Amplifiers</h3><p>运算放大器：接近理想的直流放大器。用来信号整理，滤波和数学运算。运算有加减，积分和微分。</p><p>理想运算放大器的三个特性：</p><ul><li>infinite gain;</li><li>infinite input impedance;</li><li>zero output impedance.</li></ul><p><span class="math inline">\(V_O=A_{OL}*(V_1-V_2)\)</span></p><p><span class="math inline">\(A_{OL}\)</span>：开环增益；<span class="math inline">\(Z_{in}\)</span>：输入电阻；<span class="math inline">\(Z_{out}\)</span>：输出电阻；Bandwidth：通频带；Offset Voltage：漂移电压；Common mode rejection ratio：共模抑制比，差模电压放大倍数/共模电压放大倍数。</p><p>current rule：虚断；voltage rule：虚短，同相输入端和反向输入端之间电压差为0；</p><p>GBP：指定频率出的带宽和增益的乘积。GBP是一个定值，故可以反过来用GBP求特定增益对应的频率。</p><p>Inverting amplifiers：反相放大器。</p><p><a href="https://blog.csdn.net/sinat_15677011/article/details/106392484">运算放大器的关键指标</a>；GBP，如果运放开环增益始终满足-20dB/10倍频，也就是频率提高10倍，开环增益变为0.1倍，那么它们的乘积将是一个常数。<span class="math inline">\(GBP=BW\times A\)</span>。BW和A都不用分贝表示。</p><p>放大器电路的输入电阻的计算；</p><figure><img src="\img\AnalogueElectronics2\w8VfyAXy7mCS6furVknGmccs3Tm7BYnkbxi0ZQFInbU.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\w8VfyAXy7mCS6furVknGmccs3Tm7BYnkbxi0ZQFInbU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="正增益电路" /><figcaption aria-hidden="true">正增益电路</figcaption></figure><figure><img src="\img\AnalogueElectronics2\0elpVIygxNfseriMVNKhdQc5ttVNXxgHabPE5cmt8HU.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\0elpVIygxNfseriMVNKhdQc5ttVNXxgHabPE5cmt8HU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="负增益电路" /><figcaption aria-hidden="true">负增益电路</figcaption></figure><h3 id="differential-amplifiers">1.3 Differential Amplifiers</h3><figure><img src="\img\AnalogueElectronics2\OrT7YkhuJhUWNyrQg08aR9aHdiwV49-ntuNEtWd3I6s.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\OrT7YkhuJhUWNyrQg08aR9aHdiwV49-ntuNEtWd3I6s.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="差分放大电路" /><figcaption aria-hidden="true">差分放大电路</figcaption></figure><p>用叠加原理，依次将V1、V2置为0，观察其对Vout的影响。</p><p><span class="math inline">\(Gain=\frac{V_{out}}{V_2-V_1}\)</span>；</p><p>但是，差分放大电路有个问题，即输入电阻较小。输入电阻看定义谁是Ui，然后看一下输入电流是多少。解决输入电阻小的问题，可以利用电压跟随器。</p><h4 id="instrumentation-amplifier">Instrumentation Amplifier</h4><figure><img src="\img\AnalogueElectronics2\ZZZhQMIkTfbBu-1PtqopzkpcDsNHwNLGOkxnAidhX7w.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\ZZZhQMIkTfbBu-1PtqopzkpcDsNHwNLGOkxnAidhX7w.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="测量放大器" /><figcaption aria-hidden="true">测量放大器</figcaption></figure><figure><img src="\img\AnalogueElectronics2\K-mXL4beYfHkrm9W5Bmo6VHntNOnR9fodVa3bnXU2Jo.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\K-mXL4beYfHkrm9W5Bmo6VHntNOnR9fodVa3bnXU2Jo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="测量放大器" /><figcaption aria-hidden="true">测量放大器</figcaption></figure><h3 id="filters">1.4 Filters</h3><figure><img src="\img\AnalogueElectronics2\XABWAskHUdCSKJa98NQiWzu2Gdr8LNcMcv6PLl3v2qE.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\XABWAskHUdCSKJa98NQiWzu2Gdr8LNcMcv6PLl3v2qE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="电容电感电路的阻抗" /><figcaption aria-hidden="true">电容电感电路的阻抗</figcaption></figure><p>Ideal Low Pass Filter, Ideal High Pass Filter, Band Pass Filter.</p><p>Active LPF: Provides Gain, Op-Amps or Transistors; Passive LPF: No Gain, R or C or L.</p><p>这里要开始求频率响应。</p><p><span class="math inline">\(f=\frac{1}{T}=\frac{\omega}{2\pi}\)</span>；</p><p>引入运放构成滤波器：电压关系用阻抗来计算。</p><p>电容加在R2是低通，加在R1是高通。R1R2都加电容就有了带通滤波器。中间还有相位差是0对应的频率。</p><p><span class="math inline">\(1F=10^{3}mF=10^{6}\mu F=10^{9}nF=10^{12}pF\)</span></p><p>画波特图。感觉是和自控里面一样的。</p><p>Schmitt Triger：将周期信号变成方波。</p><p>Astable Multivibrator based Schmitt Triger.</p><p>求振荡器的充放电时间。</p><p>Astable Relaxation Oscillator: 这一节考察充放电时间。</p><figure><img src="\img\AnalogueElectronics2\zy9ZjYw7htavomSeZPNPhA_2zP4XoOZLrNa5Yra34z0.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\zy9ZjYw7htavomSeZPNPhA_2zP4XoOZLrNa5Yra34z0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="多谐振荡器充放电示意图" /><figcaption aria-hidden="true">多谐振荡器充放电示意图</figcaption></figure><h4 id="op-amp-monostable-pulse-generator">Op-amp Monostable Pulse Generator</h4><p>单稳态触发器。</p><p>It has one stable and one quasi-stable state.</p><p>Output voltage will remain at that stable state unless an external triggering pulse causes a transmission to quasi-stable state.</p><p>After certain time T, output will return to its stable state.</p><p>It got its name from the fact that only one of its output states is stable. It is also known as a 'one-shot'.</p><p>这个超级有意思，15-(-15)变成30V，然后Vx本来是0，要瞬间加上一个30V的大电压。如果从+15变成-15，Vx要瞬间减少30V。</p><h2 id="block-2">2 Block 2</h2><p>二极管电压计算公式：</p><p><span class="math inline">\(\begin{aligned} I_{D} &amp;=I_{O}\left[\exp \left(\frac{V_{D}}{V_{T}}\right)-1\right] \\ I_{D} &amp;=I_{O}\left[\exp \left(\frac{V_{D}}{V_{T}}\right)\right] \\ \ln \left(I_{D}\right) &amp;=\ln \left[I_{O}\left[\exp \left(\frac{V_{D}}{V_{T}}\right)\right]\right] \\ &amp;=\ln I_{O}+\left[\left(\frac{V_{D}}{V_{T}}\right)\right] \end{aligned}\)</span></p><p>二极管建模：理想二极管+常值电压+串联电阻。</p><p>三种等效模型：理想二极管，理想二极管+常值电压，理想二极管+常值电压+串联电阻。</p><p><a href="https://www.bilibili.com/video/av840970358">二极管的教学视频</a></p><p>二极管将正弦整流成DC。这个DC为啥除以π，没看懂。</p><p>全波整流桥式电路：直流电压是0.637Vmax。</p><p><a href="https://www.electronics-tutorials.ws/diode/diode_6.html">https://www.electronics-tutorials.ws/diode/diode_6.html</a></p><p>voltage doubler circuit：电压翻倍电路。钳位电路+半波整流电路。</p><p><a href="https://m.elecfans.com/article/1296525.html">倍压整流电路</a>。</p><h2 id="block-3">3 Block 3</h2><p>双极型晶体管：NPN, PNP；场效应管：N沟道，P沟道。</p><p>场效应管：源极（source, S），栅极（gate, G），漏极（drain, D）。MOSFET的控制端称为栅极，源极和漏极是对称的，命名来自于电流方向。电流从漏极流向源极，即电压高的一端为漏极。</p><figure><img src="\img\AnalogueElectronics2\Nwed_2CFrEHgzQPqqIvm7i3tyf4OsZFxODUM3aCkOPA.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\Nwed_2CFrEHgzQPqqIvm7i3tyf4OsZFxODUM3aCkOPA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="场效应管的S模型" /><figcaption aria-hidden="true">场效应管的S模型</figcaption></figure><p><span class="math inline">\(V_{GS}\)</span>高于阈值电压VT时，元件导通，否则关断。N沟道MOSFET的典型VT是0.7V。iG永远为0。</p><p>如果<span class="math inline">\(v_{\mathrm{DS}}&lt;v_{\mathrm{GS}}-V_{\mathrm{T}}\)</span>，则工作在数电状态，称为三极管区域，这时可以将场效应管视为SR模型，电流随Vd线性增加。</p><p><span class="math inline">\(v_{\mathrm{DS}}\geq v_{\mathrm{GS}}-V_{\mathrm{T}}\)</span>的区域称为饱和区域，电流曲线会变得扁平。</p><p>双极型晶体管：两种管的图像。Vbe=0.6V。截止区，放大区，饱和区。</p><p>Active Region, Saturation, Cut-off.</p><p>理想情况下集电极电流和Vc无关，实际上是有依赖的。装置的电导有限。</p><p>双极型晶体管和场效应管的对比：</p><table><thead><tr class="header"><th>双极型晶体管同时利用电子和空穴，是双极型管。</th><th>场效应管只用电子或空穴，是单极性的。</th></tr></thead><tbody><tr class="odd"><td>电流控制电流的器件。</td><td>电压控制电流的器件。</td></tr><tr class="even"><td>输入基于b和e，像一个前向PN结，输入电阻小。</td><td>g和s之间像电容，输入电阻大。</td></tr></tbody></table><p>双极型二极管作为放大器：Uc&gt;Ub&gt;Ue</p><p>b极增加正弦信号，ib变化会引起ic变化，然后引起Uce反向变化。</p><p>放大器分析的要点：</p><ol type="1"><li>静态工作点选好，让晶体管工作在放大区；</li><li>输入一个小信号。</li></ol><p>因为放大倍数β是一个难以控制的量，所以应该选择Ic而不是Ib。电路也变化了：</p><figure><img src="\img\AnalogueElectronics2\CDB5rjXvHvRO5DYI4Ir6B97fiSMQja8DrHrjoJPmiTo.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\CDB5rjXvHvRO5DYI4Ir6B97fiSMQja8DrHrjoJPmiTo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="计算电路中各个值" /><figcaption aria-hidden="true">计算电路中各个值</figcaption></figure><figure><img src="\img\AnalogueElectronics2\I-Cqx3dY5oKb02JlTlOMs9WPUUuS3KOgp9YqOos1DMc.png" class="lazyload" data-srcset="\img\AnalogueElectronics2\I-Cqx3dY5oKb02JlTlOMs9WPUUuS3KOgp9YqOos1DMc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="计算电路中各个值" /><figcaption aria-hidden="true">计算电路中各个值</figcaption></figure><p>电阻系列的变化方式：E12，E6，E24。</p><p>现在开始学双极型晶体管放大电路的交流通路……注意，电容在交流电的时候相当于短路。</p><p>基于场效应管的放大电路，输出电压从源极引出。</p><h2 id="常用名词对照表">4 常用名词对照表</h2><table><thead><tr class="header"><th>Operational Amplifiers</th><th>运算放大器</th><th>Systems Perspective</th><th>系统视角</th></tr></thead><tbody><tr class="odd"><td>overall gain</td><td>总增益</td><td>frequency response</td><td>频率响应</td></tr><tr class="even"><td>passband</td><td>通频带</td><td>Bode Plots</td><td>波特图</td></tr><tr class="odd"><td>milliWatt(dBm)</td><td>毫瓦特</td><td>decibels(dB)</td><td>分贝</td></tr><tr class="even"><td>Cascaded Systems</td><td>串级系统</td><td>cut-off</td><td>截止</td></tr><tr class="odd"><td>Inverting</td><td>反向放大电路</td><td>Non-Inverting</td><td>正向放大电路</td></tr><tr class="even"><td>Differential Amplifier</td><td>差分放大电路</td><td></td><td></td></tr><tr class="odd"><td>Instrumentation Amplifier</td><td>测量放大器</td><td>Low Pass Filter</td><td>低通滤波器</td></tr><tr class="even"><td>High Pass Filter</td><td>高通滤波器</td><td>Band Pass Filter</td><td>带通滤波器</td></tr><tr class="odd"><td>Schmitt Triger</td><td>施密特触发器</td><td>Astable Multivibrator</td><td>不稳多谐振荡器</td></tr><tr class="even"><td>Op-amp Monostable Pulse Generator</td><td>单稳态脉冲触发器</td><td></td><td></td></tr><tr class="odd"><td>Diodes</td><td>二极管</td><td>Transistors</td><td>晶体管</td></tr><tr class="even"><td>Bipolar Transistors</td><td>双极型晶体管</td><td>Field Effect Transistors</td><td>场效应管</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git使用】入门知识</title>
      <link href="/3586729497.html"/>
      <url>/3586729497.html</url>
      
        <content type="html"><![CDATA[<p>软件准备：<a href="https://git-scm.com/download/win">下载Git Bash</a>并注册Git账号。</p><p>在某个位置，右键单击空白处，点击Git Bash Here，配置用户名和邮箱：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line"># 如果不放心可以输入以下命令检查自己的用户名和邮箱</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h2 id="上传项目到gitee">0 上传项目到Gitee</h2><p>参考资料：<a href="https://blog.csdn.net/qq_51618777/article/details/124420589?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-124420589-blog-125158920.pc_relevant_multi_platform_whitelistv1&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-124420589-blog-125158920.pc_relevant_multi_platform_whitelistv1&amp;utm_relevant_index=1">Git入门使用</a>。</p><p>上传项目可以分成3步：在Gitee网页中创建远程仓库，将本地代码上传到本地仓库，将本地代码上传到远程仓库。</p><p>首先<strong>在Gitee上创建该项目的远程仓库</strong>，此处不讲。</p><p>接着进行<strong>本地项目上传到本地仓库</strong>的这一步。在项目文件夹中右键单击空白处，点击Git Bash Here。逐条输入以下命令：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init  # 初始化本地仓库</span><br><span class="line">git add .  # 注意这里有个点</span><br><span class="line">git commit -m &#x27;本次提交的说明&#x27;  # 说明信息为必填项，信息最好有意义，便于后期理解</span><br></pre></td></tr></table></figure><p>要将本地仓库上传到远程仓库，首先要将本地仓库与远程仓库相连接。</p><p>在远程仓库复制http链接，然后输入下列命令（xxx为刚才复制的链接）：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxx  # 远程链接仓库</span><br><span class="line">git pull --rebase origin master  # 强制更新远程仓库</span><br><span class="line">git push -u origin master  # 将本地仓库中的文件推送到远程仓库</span><br></pre></td></tr></table></figure><p>最后回到Gitee网页，刷新一下即可！</p><hr /><p>下面开始是<a href="https://www.bilibili.com/video/BV1sJ411D7xN?spm_id_from=333.337.search-card.all.click&amp;vd_source=7a9ed8a5f4f6ba19804da5b9453270eb">黑马程序员的教程</a>。因为原教程很多内容用不到，故只看完了P1-P10。</p><h2 id="git-基础">1 Git 基础</h2><p>Git是目前世界上最先进的分布式<strong>版本控制系统</strong>。</p><p>Git下载和安装：</p><ul><li><a href="https://git-scm.com/downloads">下载地址</a>；</li><li>使用默认值安装；</li><li>资源管理器内单击鼠标右键选择<code>Git Bash Here</code> ；</li><li>输入<code>git --version</code> 检查是否安装成功。</li></ul><h2 id="git基本工作流程及命令">2 Git基本工作流程及命令</h2><h3 id="git中的文件位置">2.1 Git中的文件位置</h3><p>文件的位置改变：工作区→暂存区→本地仓库→远程仓库。</p><ol type="1"><li>工作区：本地电脑存放项目文件的地方，比如learnGitProject文件夹。添加、编辑、修改文件等动作。</li><li>暂存区(Index/Stage)：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。.git文件夹中包含了两个部分，一个是暂存区(Index 或者 Stage)，顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里。</li><li>本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中。</li><li>远程仓库：项目代码在远程git服务器上的位置。比如项目在github上就是放在一个远程仓库中，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可。</li></ol><p>日常开发时代码放置在工作区中，也就是本地的XXX.java这些文件，通过add等这些命令将文件提交给暂存区(Index/Stage)，也就意味着代码全权交给了git进行管理，之后通过commit等命令将暂存区提交给master分支上，也就是打了一个版本，也可以说代码提交到了本地仓库中。另外，团队协作过程中自然而然还涉及到与远程仓库的交互。</p><p>因此，经过这样的分析，git命令可以分为这样的逻辑进行理解和记忆：</p><ol type="1"><li><p>git管理配置的命令；</p></li><li><p>工作区与暂存区的交互；</p></li><li><p>暂存区与本地仓库（分支）上的交互；</p></li><li><p>本地仓库与远程仓库的交互。</p></li></ol><table><thead><tr class="header"><th>工作目录</th><th>暂存区</th><th>git仓库</th><th>远程仓库</th></tr></thead><tbody><tr class="odd"><td>被 Git 管理的项目</td><td>临时存放被修改的文件</td><td>目录用于存放提交记录</td><td>远程代码仓库</td></tr><tr class="even"><td>git init</td><td>git add</td><td>git commit</td><td>git push</td></tr></tbody></table><h3 id="git使用前的配置命令">2.2 Git使用前的配置命令</h3><p>在使用前告诉git你是谁：</p><ol type="1"><li>第一次使用git，配置用户信息：<ol type="1"><li>配置用户名：<code>git config --global user.name "用户名"</code>；</li><li>配置用户邮箱：<code>git config --global user.email "邮箱地址"</code>。</li></ol></li><li>查询配置信息：<ol type="1"><li>查询用户名（查询邮箱同理）：<code>git config --global user.name</code>；</li><li>列出当前配置：<code>git config --list</code>；</li><li>列出repository配置：<code>git config --local --list</code>；</li><li>列出全局配置：<code>git config --global --list</code>；</li><li>列出系统配置：<code>git config --system --list</code>。</li></ol></li><li>其他配置：<ol type="1"><li>配置解决冲突时使用哪种差异分析工具，比如要使用vimdiff：<code>git config --global merge.tool vimdiff</code>；</li><li>配置git命令输出为彩色的：<code>git config --global color.ui auto</code>；</li><li>配置git使用的文本编辑器：<code>git config --global core.editor vi</code>。</li></ol></li><li>注：也可直接修改：<code>C:\Users\用户\.gitconfig</code> 。</li></ol><h3 id="工作区上的操作命令">2.3 工作区上的操作命令</h3><p>新建仓库：</p><ol type="1"><li>将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：<code>git init</code>；</li><li>从远程git仓库复制项目：<code>git clone 远程仓库地址</code> ；</li><li>克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名，如：<code>git clone git://github.com/wasd/example.git NewName</code>；</li><li>查看文件状态：<code>git status</code>。</li></ol><p>查新信息：</p><ol type="1"><li><p>查询当前工作区所有文件的状态：<code>git status</code>;</p></li><li><p>比较工作区中文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：<code>git diff</code>；</p></li><li><p>提交文件到暂存区：<code>git add 文件/文件列表</code> 。</p></li></ol><p>提交文件到暂存区：</p><ol type="1"><li>提交当前目录所有文件到暂存区：<code>git add .</code>；</li><li>提交当前目录指定文件到暂存区：<code>git add 文件名1 文件名2 文件名3</code>；</li><li>提交当前目录某个文件夹中所有文件到暂存区：<code>git add [dir]</code>；</li></ol><p>提交文件到仓库（或者叫版本库）：</p><ol type="1"><li>将暂存区中的文件提交到本地仓库中，即打上新版本：<code>git commit -m "commit_info"</code>；</li><li>将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程：<code>git commit -a -m "commit_info"</code>；</li><li>提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：<code>git commit --amend</code>；</li></ol><p>查看版本差异和回退历史记录：</p><ol type="1"><li>比较<strong>暂存区</strong>与<strong>上一版本</strong>的差异：<code>git diff --cached</code>;</li><li>指定文件在暂存区和本地仓库的不同：<code>git diff --cached 文件1</code>;</li><li>查看提交历史：<code>git log</code>或<code>git log --pertty=oneline</code>。推荐用第二个命令，显示结果更简洁。可以用参数<code>-p</code>规定显示多少次提交的内容差异，比如<code>-2</code>表示显示最近的两次更新，如<code>git log -p -2</code>。</li><li>回退到某个版本（覆盖暂存区和工作目录）：<code>git reset --hard 提交编号</code>。</li></ol><p>注意：回退到过去版本之后，要想回到之前最新的版本，需要使用指令<code>git reflog</code>去查看历史操作，以得到最新的commit_id，此时的commit_id没有显示全，但是仍然可以用，至少要前4位。</p><p>删除和修改文件：</p><ul><li><p>用暂存区中的文件覆盖工作目录中的文件：<code>git checkout -- 文件名</code> 。不加 <code>-- 文件名</code>则覆盖全部文件。</p></li><li><p>将文件从暂存区中删除，但是工作区还有该文件：<code>git rm --cached 文件名</code> 。</p></li><li><p>删除工作区文件，并且也从暂存区删除对应文件的记录：<code>git rm 文件名</code> 。</p></li><li><p>取消暂存区已经暂存的文件：<code>git reset HEAD ...</code>。</p></li></ul><p>撤销操作：</p><p>如果想保留上一次的修改以备以后继续工作，可以使用<strong>储藏(stashing)</strong>和<strong>分支</strong>来处理。其中储藏可以理解为在不commit的情况下保存自己的工作，之后可以切换分支。储藏的具体讲解可以看<a href="https://blog.csdn.net/MoNianQing/article/details/113499420">博客1</a>和<a href="https://blog.csdn.net/weixin_44154094/article/details/114339029">博客2</a>。</p><ul><li>将当前代码储藏，以便能够切换分支：<code>git stash</code>。</li><li>查看当前所有的储藏：<code>git stash list</code>。</li><li>应用最新的储藏：<code>git stash apply</code>。如果想应用某个特定版本的储藏：<code>git stash apply stash@&#123;2&#125;</code>。其中<code>stash@&#123;2&#125;</code> 是储藏编号。apply命令只是应用储藏，而储藏的内容仍然还在栈上。</li><li>删除指定的储藏：<code>git stash drop stash&#123;0&#125;</code>。</li><li>删除所有的储藏：<code>git stash clear</code>。</li><li>如果想在恢复内容的同时将储藏从栈中删除，可以使用pop：<code>git stash pop</code>。</li><li>在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于<code>stash unapply</code>的命令，但是可以通过取消该储藏的补丁达到同样的效果：<code>git stash show -p stash@&#123;0&#125; | git apply -R</code>。</li><li>如果你沒有指定具体的某个储藏，Git会取消最近的储藏：<code>git stash show -p | git apply -R</code>。</li></ul><p>更新文件：</p><ul><li>重命名文件，并将已改名文件提交到暂存区：<code>git mv [file-original] [file-renamed]</code>;</li></ul><h2 id="git进阶">3 Git进阶</h2><h3 id="分支">3.1 分支</h3><p>生成副本，避免影响开发主线。</p><p>分支的类别：</p><ol type="1"><li>主分支(master)：第一次向git仓库提交更新记录时自动产生的一个分支。</li><li>开发分支(develop)：作为开发的分支，基于master分支创建。</li><li>功能分支(feature)：作为开发具体功能的分支基于开发分支创建。</li></ol><p>注意修改某分支文件后要<code>commit</code>后再切换分支，否则某分支的文件会出现在其他分支里。</p><h3 id="分支命令">3.2 分支命令</h3><ul><li><p>查看本地仓库的所有分支：<code>git branch</code>。</p></li><li><p>创建分支：<code>git branch 分支名称</code>。新建并切换到新建分支上：<code>git checkout -b 分支名词</code> 。</p></li><li><p>切换分支：<code>git checkout 分支名称</code>。</p></li><li><p>合并分支：<code>git merge 来源分支</code>。</p></li><li><p>删除分支（分支合并后才允许被删除，但可以用-D强制删除）：<code>git branch -d 分支名称</code>。</p></li><li><p><code>git push origin :branch-name</code> : 远程仓库同步删除分支</p></li><li><p>查看各个分支最后一个提交对象的信息：<code>git branch -v</code>;</p></li><li><p>查看哪些分支已经合并到当前分支：<code>git branch --merged</code>;</p></li><li><p>查看当前哪些分支还没有合并到当前分支：<code>git branch --no-merged</code>;</p></li><li><p>把远程分支合并到当前分支：<code>git merge /</code>，如<code>git merge origin/serverfix</code>；如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进(Fast forward)，而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交。</p></li></ul><h2 id="github">4 Github</h2><p>注册Github账号：略。</p><p>多人协作开发流程：</p><ul><li>A在自己的计算机中创建本地仓库；</li><li>A在GitHub中创建远程仓库；</li><li>A将本地仓库推送到远程仓库；</li><li>B克隆远程仓库到本地进行开发；</li><li>B将本地仓库开发内容推送到远程仓库；</li><li>A将远程仓库中的最新内容拉去本地。</li></ul><p>Github中创建远程仓库：略。</p><h3 id="推送代码">4.1 推送代码</h3><p>前面已经说过，从远程仓库拷贝代码是用<code>git clone</code>命令。</p><p>推送代码到远程仓库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git push 远程仓库地址 分支名称</span><br><span class="line">git push 远程仓库地址别名 分支名称</span><br><span class="line"></span><br><span class="line">git push -u 远程仓库地址别名 分支名称  # -u表示记住推送地址和分支，下次只需要输入git push</span><br><span class="line"></span><br><span class="line">git remote add 远程仓库地址别名 远程仓库地址</span><br></pre></td></tr></table></figure><p>删除别名：<code>git remote remove 远程仓库地址别名</code> 。</p><p>第一次提交需要用户名和密码，电脑会记住密码在凭据管理器，第二次就不用了。</p><p>本地仓库上的操作：</p><ol type="1"><li>查看本地仓库关联的远程仓库：<code>git remote</code>；在克隆完每个远程仓库后，远程仓库默认为<code>origin</code>；加上<code>-v</code>的参数后，会显示远程仓库的<code>url</code>地址；</li><li>添加远程仓库，一般会取一个简短的别名：<code>git remote add [remote-name] [url]</code>，比如：<code>git remote add example git://github.com/example/example.git</code>;</li><li>从远程仓库中抓取本地仓库中没有的更新：<code>git fetch [remote-name]</code>，如<code>git fetch origin</code>；使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，需要人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用<code>git pull</code>来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；</li><li>将本地仓库某分支推送到远程仓库上：<code>git push [remote-name] [branch-name]</code>，如<code>git push origin master</code>；如果想将本地分支推送到远程仓库的不同名分支：<code>git push :</code>，如<code>git push origin serverfix:awesomebranch</code>;如果想删除远程分支：<code>git push [romote-name] :</code>，如<code>git push origin :serverfix</code>。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。</li><li>查看远程仓库的详细信息：<code>git remote show origin</code>；</li><li>修改某个远程仓库在本地的简称：<code>git remote rename [old-name] [new-name]</code>，如<code>git remote rename origin org</code>；</li><li>移除远程仓库：<code>git remote rm [remote-name]</code>；</li></ol><h3 id="拉取远程仓库中的代码">4.2 拉取远程仓库中的代码</h3><p>克隆远程仓库到本地：<code>git clone 仓库地址</code> 。</p><p>拉取远程仓库最新版本到本地：<code>git pull 远程仓库地址 分支名称</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】Collections</title>
      <link href="/1245507953.html"/>
      <url>/1245507953.html</url>
      
        <content type="html"><![CDATA[<p>这个库内含多种容器。</p><h2 id="defaultdict">1 defaultdict</h2><p>它解决的是我们使用dict当中最常见的问题，就是<strong>key为空</strong>的情况，访问一个dict中不存在的key会导致系统抛出异常。</p><p>dict当中为我们提供了<strong>带默认值的get方法</strong>。比如，可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">dict</span>.get(key, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这样，当key不在dict当中存在的时候，会自动返回设置的默认值。这省去了很多麻烦的判断，但是在一些特殊情况下仍然存在一点问题。比如当希望将key相同的value存进一个list当中而不是只保留一个，需要写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">7</span>)]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">in</span> d:</span><br><span class="line">        d[k].append(v)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[k] = [v]</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    cur = d.get(k, [])</span><br><span class="line">    cur.append(v)</span><br><span class="line">    d[k] = cur</span><br></pre></td></tr></table></figure><p>为了完美解决这个问题，可以使用<code>collections</code>当中的<code>defaultdict</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k].append(v)</span><br></pre></td></tr></table></figure><p>使用defaultdict之后，如果key不存在，容器会自动返回预先设置的默认值。需要注意的是 defaultdict 传入的默认值可以是<strong>一个类型也可以是一个方法</strong>。如果传入int，默认值会被设置成int()的结果，也就是0。如果想要自定义或者修改，可以传入一个方法，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> data:</span><br><span class="line">    d[k] += v</span><br></pre></td></tr></table></figure><h2 id="counter">2 Counter</h2><p>对数据进行<strong>统计</strong>。只需要一行代码即可统计一个list中的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;watermelon&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;peach&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">counter = Counter(words)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(counter)</span><br><span class="line"></span><br><span class="line">Counter(&#123;<span class="string">&#x27;apple&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;pear&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;watermelon&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;peach&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码直接将一个list传入Counter中作为参数，它会自动给每个元素计数。</p><p>筛选topK也非常简单，Counter 提供了<code>most_common()</code>方法，只需要传入需求的K即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter.most_common(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">[(<span class="string">&#x27;apple&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><p>除此之外，Counter的构造函数还接收dict类型。可以直接通过一个value是int类型的dict来初始化一个Counter，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(&#123;<span class="string">&#x27;apple&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;pear&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line">c = Counter(apple=<span class="number">4</span>, pear=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>并且，Counter还支持<strong>加减法</strong>的操作。两个Counter相加时会自动合并，即相同的key对应的value累加。相减也是同理，会将能对应的value做减法，被减的key中没有对应的会保留，而减数中没有对应的key则会被丢弃。并且需要注意，Counter支持value为负数。</p><h2 id="deque">3 deque</h2><p>queue是队列，deque是<strong>双端队列</strong>。deque的队首和队尾都支持元素的插入和弹出。</p><p>除了常用的clear、copy、count、extend等api之外，deque当中最常用也是最核心的api还有append、pop、appendleft和popleft。append和pop与list的append和pop一样是在队尾进行操作，而appendleft和popleft则是在队列<strong>左侧</strong>，也就是队首进行pop和append的操作。</p><p>真正用到双端队列的算法不太多，使用deque主要有两个原因。第一个原因是deque收到GIL的管理，它是<strong>线程安全</strong>的。而list则没有GIL锁，因此不是线程安全的。也就是说在并发场景下，list可能会导致一致性问题，而deque不会。另一个原因是deque<strong>支持固定长度</strong>，当长度满了之后继续append时，它会自动弹出最早插入的数据。</p><p>当拥有海量的数据，想要保留最后出现的指定数量的数据的时候，就可以使用deque：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">dque = deque(maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 假设我们想要从文件当中获取最后10条数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f.read():</span><br><span class="line">    dque.append(i)</span><br></pre></td></tr></table></figure><h2 id="namedtuple">4 namedtuple</h2><p>namedtuple很特殊，涉及到<strong>元编程</strong>的概念。</p><p>常见的面向对象是定义类，然后通过类的构造函数来创建实例。元编程指的是定义元类，根据元类创建出一个类。如果用模具和成品来分别比喻类和实例的话，元类相当于是<strong>模具的模具</strong>。</p><p>namedtuple是一个非常简单的元类，通过它可以非常方便地定义想要的类。</p><p>比如如果我们想要定义一个学生类，这个类当中有name、score、age这三个字段，那么这个类会写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, score=<span class="literal">None</span>, age=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p>这只是粗略的写法，如果考虑规范还需要定义property等注解，又需要很多代码。使用namedtuple可以简化这个工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="comment"># 这个是类，columns也可以写成&#x27;name score age&#x27;，即用空格分开</span></span><br><span class="line">Student = namedtuple(<span class="string">&#x27;Student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是实例</span></span><br><span class="line">student = Student(name=<span class="string">&#x27;xiaoming&#x27;</span>, score=<span class="number">99</span>, age=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(student.name)</span><br></pre></td></tr></table></figure><p>通过使用namedtuple，只用<strong>一行就定义了一个类</strong>。还可以通过传入defaults参数来定义缺省值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student = namedtuple(<span class="string">&#x27;Student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>], defaults=(<span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>可以注意到，虽然定义了三个字段，但是只设置了两个缺失值。在这种情况下，namedtuple会自动将缺失值匹配上score和age两个字段。因为在Python的规范当中，<strong>必选参数一定在可选参数前面</strong>。所以nuamdtuple会自动<strong>右对齐</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】零散知识点</title>
      <link href="/348283507.html"/>
      <url>/348283507.html</url>
      
        <content type="html"><![CDATA[<h2 id="c中的注释">1 C++中的注释</h2><p>单行注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br></pre></td></tr></table></figure><p>多行注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这是多行注释的第一行</span></span><br><span class="line"><span class="comment">* 这是多行注释的第二行</span></span><br><span class="line"><span class="comment">* &quot;*&quot;不是必须的，但加上会显得整齐些</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>条件注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0为条件参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">   code</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p>为代码撰写注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 写在代码开头</span></span><br><span class="line"><span class="comment">* 代码功能、版权、作者、编写日期等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写在代码块前面的注释：内容为大段的解释信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当使用visual的时候，可以在函数上方直接打三个斜杠，然后就会获得……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 求a和b的和</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;a&quot;&gt;被加数&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是肉眼可见的，上面的注释风格实在是太丑了，这能忍？好消息是Visual Studio 2019给我们提供了注释风格的选项，路径为【工具 / 选项 / 文本编辑器 / C/C++ / 代码样式 / 常规】，在这里面可以选择注释风格，理论上来说"///"是最快捷的，但我还是觉得难看，选择了"/**"的注释风格：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求和</span></span><br><span class="line"><span class="comment"> * @param a </span></span><br><span class="line"><span class="comment"> * @param b </span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速将一部分代码注释掉：选中代码，ctrl+k，ctrl+c，或者ctrl+k+c三个键一起按。</p><p>取消注释：选中代码，ctrl+k，ctrl+u，或者ctrl+k+u三个键一起按。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】面向对象</title>
      <link href="/3267076484.html"/>
      <url>/3267076484.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象相关概念">0 面向对象相关概念</h2><ul><li><strong>面向对象(Object Oriented)</strong>：软件开发方法，一种编程范式。</li><li><strong>类(Class)</strong>：具有相同的属性和方法的对象的集合，它的定义中包含该集合中每个<strong>对象</strong>所共有的属性和方法。对象是指类的实例。</li><li><strong>类变量</strong>：类变量定义在类中且在函数体之外，通常不作为<strong>实例变量</strong>使用。该变量的值由该类的所有对象共享。</li><li><strong>数据成员</strong>：类变量或者实例变量，用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写</strong>：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的<strong>覆盖(override)</strong>，也称为方法的<strong>重写</strong>。</li><li><strong>局部变量</strong>：定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量</strong>：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</li><li><strong>继承</strong>：即一个派生类(derived class)继承基类(base class)的变量和方法，Python也允许把一个派生类的对象作为一个基类对象对待。</li><li><strong>实例化</strong>：创建一个类的实例，即创建类的一个具体对象。</li><li><strong>方法</strong>：类中定义的函数。</li><li><strong>对象</strong>：通过类定义的数据结构实例。对象包括数据成员（类变量和实例变量）和方法。</li></ul><h2 id="类的基础">1 类的基础</h2><h3 id="定义类">1.1 定义类</h3><p>Python中使用<code>class</code>语句来定义一个新类，<code>class</code>之后为类的名称并以冒号结尾:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>   <span class="comment"># 类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment"># 类体</span></span><br></pre></td></tr></table></figure><p>类的帮助信息可以通过<code>ClassName.__doc__</code>查看，<code>class_suite</code>由类成员，方法，数据属性组成。</p><p>一个简单的Python类的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, salary</span>):</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary)</span><br></pre></td></tr></table></figure><ul><li><code>empCount</code>是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类中使用<code>Employee.empCount</code>访问。</li><li>第一种方法<code>__init__()</code>方法是一种特殊的方法，被称为类的<strong>构造函数</strong>或<strong>初始化方法</strong>，每次创建该类的一个实例时就会调用该方法。</li><li>方法中的变量<code>self</code>代表类的实例，<code>self</code>在定义类的方法时是必须有的，但是在调用时不必传入相应的参数。</li></ul><p><code>self</code>详解：<code>self</code>代表类的实例而非类。类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>，按照惯例它的名称是<code>self</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test object at 0x0000013CE6C87610&gt;</span><br><span class="line">&lt;class &#x27;__main__.Test&#x27;&gt;</span><br></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，<code>self</code>代表的是类的实例，代表当前对象的地址，而<code>self.__class__</code>则指向类。<code>self</code>不是Python的关键字，把它换成其他名称也是可以正常执行的。<code>__main__.Test</code>是类的全名。</p><h3 id="类的实例对象">1.2 类的实例对象</h3><p>其他编程语言中一般用关键字<code>new</code>实例化一个对象，但是Python中并没有这个关键字，类的实例化类似函数调用方式。</p><p>以下使用类的名称<code>Employee</code>来实例化，并通过<code>__init__</code>方法接收参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;创建 Employee 类的第一个对象&quot;&quot;&quot;</span></span><br><span class="line">emp1 = Employee(<span class="string">&quot;Zara&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;创建 Employee 类的第二个对象&quot;&quot;&quot;</span></span><br><span class="line">emp2 = Employee(<span class="string">&quot;Manni&quot;</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h4 id="访问类的属性">1.2.1 访问类的属性</h4><p>使用点号"."来访问对象的属性（变量或方法）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.displayEmployee()</span><br><span class="line">emp2.displayEmployee()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br></pre></td></tr></table></figure><p>完整实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, salary</span>):</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary)</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;创建 Employee 类的第一个对象&quot;</span></span><br><span class="line">emp1 = Employee(<span class="string">&quot;Zara&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">&quot;创建 Employee 类的第二个对象&quot;</span></span><br><span class="line">emp2 = Employee(<span class="string">&quot;Manni&quot;</span>, <span class="number">5000</span>)</span><br><span class="line">emp1.displayEmployee()</span><br><span class="line">emp2.displayEmployee()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name :  Zara , Salary:  2000</span><br><span class="line">Name :  Manni , Salary:  5000</span><br><span class="line">Total Employee 2</span><br></pre></td></tr></table></figure><p>添加，删除，修改类的属性，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.age = <span class="number">7</span>  <span class="comment"># 添加一个 &#x27;age&#x27; 属性</span></span><br><span class="line">emp1.age = <span class="number">8</span>  <span class="comment"># 修改 &#x27;age&#x27; 属性</span></span><br><span class="line"><span class="keyword">del</span> emp1.age  <span class="comment"># 删除 &#x27;age&#x27; 属性</span></span><br></pre></td></tr></table></figure><p>Python有个非常有趣的特性，即支持<strong>给已创建的对象增加属性</strong>！这在Java中是做不到的，C++大概也不能。</p><p>从面向对象的角度来说，不推荐直接用"."来访问属性，推荐使用<code>set()</code>和<code>get()</code>方法来进行属性值的设定和获取，这两类方法称为setter、getter方法。Python提供了以下函数来访问属性：</p><ul><li><code>getattr(obj, name[, default])</code>：访问对象的属性；</li><li><code>hasattr(obj,name)</code>：检查是否存在一个属性；</li><li><code>setattr(obj,name,value)</code>：设置一个属性。如果属性不存在，会创建一个新属性；</li><li><code>delattr(obj, name)</code>：删除属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 返回 &#x27;age&#x27; 属性的值</span></span><br><span class="line"><span class="built_in">hasattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 如果存在 &#x27;age&#x27; 属性返回 True。</span></span><br><span class="line"><span class="built_in">setattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>, <span class="number">8</span>) <span class="comment"># 添加属性 &#x27;age&#x27; 值为 8</span></span><br><span class="line"><span class="built_in">delattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 删除属性 &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="python内置类属性">1.2.2 Python内置类属性</h4><ul><li><code>__dict__</code>：类的属性，是一个由类的数据属性组成的字典；</li><li><code>__doc__</code>：类的文档字符串；</li><li><code>__name__</code>：类名；</li><li><code>__module__</code>：类定义所在的模块，类的全名是<code>__main__.className</code>，如果类位于一个导入模块mymod中，那么<code>className.__module__</code>等于mymod；</li><li><code>__bases__</code>：类的所有父类，是一个由所有父类组成的元组。</li></ul><p>Python内置类属性调用实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, salary</span>):</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__doc__:&quot;</span>, Employee.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__name__:&quot;</span>, Employee.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__module__:&quot;</span>, Employee.__module__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__bases__:&quot;</span>, Employee.__bases__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__dict__:&quot;</span>, Employee.__dict__)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Employee.__doc__: 所有员工的基类</span><br><span class="line">Employee.__name__: Employee</span><br><span class="line">Employee.__module__: __main__</span><br><span class="line">Employee.__bases__: (&lt;class &#x27;object&#x27;&gt;,)</span><br><span class="line">Employee.__dict__: &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: &#x27;所有员工的基类&#x27;, &#x27;empCount&#x27;: 0, &#x27;__init__&#x27;: &lt;function Employee.__init__ at 0x00000250D7A3C1F0&gt;, &#x27;displayCount&#x27;: &lt;function Employee.displayCount at 0x00000250D7A3C160&gt;, &#x27;displayEmployee&#x27;: &lt;function Employee.displayEmployee at 0x00000250D7A3C280&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Employee&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Employee&#x27; objects&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="python对象销毁垃圾回收">1.2.3 Python对象销毁（垃圾回收）</h4><p>Python使用了<strong>引用计数</strong>这一简单技术来跟踪和回收垃圾。</p><p>在Python内部用内部跟踪变量记录着所有使用中的对象各有多少引用，称为<strong>引用计数器</strong>。</p><p>对象被创建时就创建了一个引用计数。当不再需要某对象，即该对象的引用计数变为0时它被垃圾回收。但是回收不是“立即”的，由解释器在适当的时机将垃圾对象占用的内存空间回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">40</span>      <span class="comment"># 创建对象  &lt;40&gt;</span></span><br><span class="line">b = a       <span class="comment"># 增加引用， &lt;40&gt; 的计数</span></span><br><span class="line">c = [b]     <span class="comment"># 增加引用.  &lt;40&gt; 的计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a       <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">b = <span class="number">100</span>     <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">c[<span class="number">0</span>] = -<span class="number">1</span>   <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br></pre></td></tr></table></figure><p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理<strong>循环引用</strong>的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下仅使用引用计数是不够的。Python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充，垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。在这种情况下解释器会暂停下来，试图清理所有未被引用的循环。</p><p>为了研究垃圾回收机制，使用析构函数<code>__del__</code>。<code>__del__</code>在对象销毁的时候被调用，当对象不再被使用时，<code>__del__</code>方法运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"> self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">      self.x = x</span><br><span class="line">      self.y = y</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">      class_name = self.__class__.__name__</span><br><span class="line">      <span class="built_in">print</span>(class_name, <span class="string">&quot;销毁&quot;</span>)</span><br><span class="line"> </span><br><span class="line">pt1 = Point()</span><br><span class="line">pt2 = pt1</span><br><span class="line">pt3 = pt1</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(pt1), <span class="built_in">id</span>(pt2), <span class="built_in">id</span>(pt3)) <span class="comment"># 打印对象的id</span></span><br><span class="line"><span class="keyword">del</span> pt1</span><br><span class="line"><span class="keyword">del</span> pt2</span><br><span class="line"><span class="keyword">del</span> pt3</span><br></pre></td></tr></table></figure><p>以上实例运行结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2012588891008 2012588891008 2012588891008</span><br><span class="line">Point 销毁</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：通常需要在单独的文件中定义一个类，</p><h3 id="类的继承">1.3 类的继承</h3><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。</p><p>通过继承创建的新类称为<strong>子类</strong>或<strong>派生类</strong>，被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。</p><p>继承语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名(<span class="params">基类名</span>)</span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure><p>在Python中继承的一些特点：</p><ol type="1"><li>如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： <a href="https://www.runoob.com/w3cnote/python-extends-init.html">python 子类继承父类构造函数说明</a>。</li><li>在调用基类的方法时，需要加上基类的类名前缀，且需要带上<code>self</code>参数变量。区别在于类中调用普通函数时<strong>并不需要</strong>带上<code>self</code>参数</li><li>Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。即先在本类中查找调用的方法，找不到才去基类中找。</li></ol><p>如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" ，继承的积累在括号中列出：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class SubClassName(ParentClass1, ParentClass2, ...):</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>派生类的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   parentAttr = <span class="number">100</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;调用父类构造函数&quot;</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">parentMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">setAttr</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">      Parent.parentAttr = attr</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">getAttr</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;父类属性 :&quot;</span>, Parent.parentAttr)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;调用子类构造方法&quot;</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">childMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 实例化子类</span></span><br><span class="line">c.childMethod()      <span class="comment"># 调用子类的方法</span></span><br><span class="line">c.parentMethod()     <span class="comment"># 调用父类方法</span></span><br><span class="line">c.setAttr(<span class="number">200</span>)       <span class="comment"># 再次调用父类的方法 - 设置属性值</span></span><br><span class="line">c.getAttr()          <span class="comment"># 再次调用父类的方法 - 获取属性值</span></span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用子类构造方法</span><br><span class="line">调用子类方法</span><br><span class="line">调用父类方法</span><br><span class="line">父类属性 : 200</span><br></pre></td></tr></table></figure><p>继承多个类的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>        <span class="comment"># 定义类 A</span></span><br><span class="line">.....</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>         <span class="comment"># 定义类 B</span></span><br><span class="line">.....</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span>   <span class="comment"># 继承类 A 和 B</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>判断某个类是不是子类可以使用<code>issubclass()</code>或者<code>isinstance()</code>方法：</p><ul><li><code>issubclass(Class1, Class2)</code>：布尔函数，<code>Class1</code>是<code>Class2</code>的子类或者子孙类则返回true。</li><li><code>isinstance(obj, Class)</code>：布尔函数，如果<code>obj</code>是<code>Class</code>类的实例对象或者是<code>Class</code>子类的一个实例对象则返回true。</li></ul><h2 id="类方法的重写">2 类方法的重写</h2><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写（又叫重载）你父类的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用父类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用子类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br></pre></td></tr></table></figure><p>执行以上代码输出结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用子类方法</span><br></pre></td></tr></table></figure><h3 id="基础重载方法">2.1 基础重载方法</h3><table><thead><tr class="header"><th>序号</th><th>方法, 描述 &amp; 简单的调用</th></tr></thead><tbody><tr class="odd"><td>1</td><td><code>__init__(self, args...)</code>：构造函数。<br>简单的调用方法：<code>obj = className(args)</code></td></tr><tr class="even"><td>2</td><td><code>__del__(self)</code>：析构方法, 删除一个对象。<br>简单的调用方法：<code>del obj</code></td></tr><tr class="odd"><td>3</td><td><code>__repr__(self)</code>：转化为供解释器读取的形式。<br>简单的调用方法：<code>repr(obj)</code></td></tr><tr class="even"><td>4</td><td><code>__str__(self)</code>：用于将值转化为适于人阅读的形式。<br>简单的调用方法：<code>str(obj)</code></td></tr><tr class="odd"><td>5</td><td><code>__cmp__ ( self, x )</code>：对象比较。<br>简单的调用方法：<code>cmp(obj, x)</code></td></tr></tbody></table><h3 id="运算符重载">2.2 运算符重载</h3><p>Python同样支持运算符重载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span>  <span class="comment"># __str__在print被调用，目的是输出类的内容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>, -<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line"><span class="built_in">print</span>(v1 + v2)</span><br><span class="line"><span class="built_in">print</span>(v1.__str__())</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下所示:</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector (2, 10)</span><br><span class="line">Vector (7, 8)</span><br><span class="line">Vector (2, 10)</span><br></pre></td></tr></table></figure><h2 id="类的属性与方法">3 类的属性与方法</h2><h3 id="类的私有属性">3.1 类的私有属性</h3><p><code>__private_attrs</code>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时写作<code>self.__private_attrs</code>。</p><h3 id="类的方法">3.2 类的方法</h3><p>在类的内部，使用<code>def</code>关键字可以为类定义一个方法。与一般函数定义不同，类方法必须包含参数<code>self</code>作为第一个参数。</p><h3 id="类的私有方法">3.3 类的私有方法</h3><p><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用时写作<code>self.__private_methods</code>。</p><p>私有属性的实例（私有方法类似）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(self.__secretCount)</span><br><span class="line"> </span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="built_in">print</span>(counter.publicCount)</span><br><span class="line"><span class="built_in">print</span>(counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure><p>Python 通过改变名称来包含类名:</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\jh108\PycharmProjects\PythonLearningCodes\OOP.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    print(counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: &#x27;JustCounter&#x27; object has no attribute &#x27;__secretCount&#x27;</span><br></pre></td></tr></table></figure><p>Python不允许实例化的类访问私有数据，但你可以使用<code>object._className__attrName</code>（对象名._类名__私有属性名）访问属性，参考以下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>:</span></span><br><span class="line">    __site = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">runoob = Runoob()</span><br><span class="line"><span class="built_in">print</span>(runoob._Runoob__site)</span><br></pre></td></tr></table></figure><p>执行以上代码，执行结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure><h3 id="单下划线双下划线头尾双下划线说明">3.4 单下划线、双下划线、头尾双下划线说明</h3><ul><li><code>__foo__</code>: 两边都有双下划线的是特殊方法，一般是系统定义名字，类似<code>__init__()</code>之类的。</li><li><code>_foo</code>: 以单下划线开头的是<code>protected</code>类型的变量，即保护类型。只能允许其本身与子类进行访问，不能用于<code>from module import *</code>。</li><li><code>__foo</code>: 双下划线的表示的是私有类型(private)的变量，只能允许这个类本身进行访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【日文歌词】《うっせぇわ》歌词（中日语+假名对照版）</title>
      <link href="/899839865.html"/>
      <url>/899839865.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。</p></blockquote><p>ただしさとは、おろかさとは<br />正　しさとは、愚　かさとは<br />什么叫正确？什么叫愚蠢？</p><p>それがなにかみせつけてやる<br />それが何　か見せつけてやる<br />现在就让你们见识一下吧！</p><p>ちっちゃなころからゆうとうせい<br />ちっちゃな頃　から優　等　生<br />从小便是优等生</p><p>きづいたらおとなになっていた<br />気づいたら大　人になっていた<br />回过神来便已成为了大人</p><p>ナイフのようなしこうかいろ<br />ナイフの様　な思考　回　路<br />充满了刀锋般的思考方式</p><p>もちあわせるわけもなく<br />持ち合わせる訳　もなく<br />但也没必要和你一起比较吧</p><p>でもあそびたりない、なにかたりない<br />でも遊　び足りない、何　か足りない<br />但是玩不够啊，还不够快乐啊</p><p>こまっちまうこれはだれかのせい<br />困　っちまうこれは誰　かのせい<br />左右为难又是谁的错啊</p><p>あてもなくただこんらんするエイデイ<br />あてもなくただ混　乱　するエイデイ<br />也不过只是没有目的的日程渐渐变得混乱</p><p>それもそっか<br />那也是当然嘛</p><p>さいしんのりゅうこうはとうぜのはあく<br />最　新　の流　　行　は当　然　の把握<br />最流行的东西，第一时间掌握</p><p>きゅうざいのどうこうはつうきんじチェック<br />経　　済　の動　向　は通　勤　時チェック<br />经济的流向上班前查看</p><p>じゅんじょうなせいしんでにゅうしゃしワーク<br />純　　情　　な精　神　で入　　社　しワーク<br />抱有热情的进公司工作</p><p>しゃかいじんじゃとうぜんのルールです<br />社　会　人　じゃ当　然　のルールです<br />这可是社会人的规则啊</p><p>はぁ？うっせぇうっせぇうっせぇわ<br />哈？啰嗦！烦人！吵死了！</p><p>あなたがおもうよりけんこうです<br />あなたが思　うより健　康　です<br />我可比你想的要健康得多</p><p>いっさいがっさいぼんような<br />一　切　合　切　凡　庸　な<br />一切一切都平凡的你</p><p>あなたじゃわからないかもね<br />あなたじゃ分からないかもね<br />你可能不明白吧</p><p>ああよくにあう<br />嗚呼よく似合う<br />啊，和你可真是般配啊</p><p>そのかもなくふかもないメロディー<br />その可もなく不可もないメロディー<br />这没有存在必要的旋律</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>あたまのできがちがうのでもんだいはナシ<br />頭　　の出来が違　うので問　題　はナシ<br />我们头脑构造不一样，所以没什么问题！</p><p>つってもわたしもはんにんげん<br />つっても私　　模範　人　間<br />就算这样我也可是人之模范啊</p><p>なぐったりするのはノーセンキュー<br />殴　ったりするのはノーセンキュー<br />教训你一顿这种事也是不用谢我</p><p>だったらことばのじゅうこうを<br />だったら言　葉の銃　　口　を<br />既然这样就将枪口（话语）</p><p>そのあたまにつきつけてうてば<br />その頭　　に突きつけて撃てば<br />对准脑门一通扫射吧！</p><p>マジヤバない？とまれやしない<br />マジヤバない？止まれやしない<br />这样下去很糟糕吧？不试试放弃吗？</p><p>ふへいふまんだれてなれのはて<br />不平　不満　誰　て成れの果て<br />怨天尤人可不会有好下场的</p><p>サディスティックにへんぼうするせいしん<br />サディスティックに変　貌　する精　神<br />变得施虐者一般的思想</p><p>クソだりぃな<br />真是渣滓</p><p>さけがあいたグラスあればすぐにつぎなさい<br />酒　が空いたグラスあれば直ぐに注ぎなさい<br />酒杯空了就立马装满</p><p>みんながつまみやすいようにくしがいしなさい<br />皆　　がつまみ易い　ように串　外　しなさい<br />为了大家吃东西更方便给我把菜从串上取下来</p><p>かいけいやちゅうもんはせんじんをきる<br />会　計　や注　　文　は先　陣　を切る<br />结账和点菜搞快点</p><p>ふぶんりつさいていげんのマナーです<br />不文　律　最　低　限　のマナーです<br />这是最低限度的不成文规定吧</p><p>はぁ？うっせぇうっせぇうっせぇわ<br />哈？啰嗦！烦人！吵死了！</p><p>くせぇくちふさげやげんかいです<br />くせぇ口　塞　げや限　界　です<br />也该闭上你这张臭嘴了吧我受够了</p><p>ぜったいぜったいげんだいのだいべんしゃはわたしやろがい<br />絶　対　絶　対　現　代　の代　弁　者　は私　　やろがい<br />现代人的榜样绝对就是我了吧</p><p>もうみあきたわ<br />もう見飽きたわ<br />已经见多了啊</p><p>にばんせんじいいかえのパロディ<br />二番　煎　じ言い換えのパロディ<br />换汤不换药只是换了个说法的模仿</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！吵死了！烦死了</p><p>まるまるとにくついたそのがんめんにバツ<br />丸　々　と肉　付いたその顔　面　にバツ<br />恨不得赏你这肥猪一拳</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>わたしがぞくにいうてんさいです<br />私　　が俗　に言う天　才　です<br />我可是你们所说的天才！</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>あなたがおもうよりけんこうです<br />あなたが思　うより健　康　です<br />我可比你想的要健康得多！</p><p>いっさいがっさいぼんような<br />一　切　合　切　凡　庸　な<br />一切一切都平凡的你</p><p>あなたじゃわからないかもね<br />あなたじゃ分からないかもね<br />可能不明白吧</p><p>ああつまらねぇ<br />嗚呼つまらねぇ<br />啊，真无趣啊</p><p>なんかいきかせるんだそのメモリー<br />何　回　聞かせるんだそのメモリー<br />这样的回忆已经听了多少遍啊</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>アタシもたいがい だけど<br />アタシも大　概　だけど<br />我或许也差不多...</p><p>どうだっていいぜもんだいはナシ<br />どうだっていいぜ問　題　はナシ<br />不！怎么都好，我没有问题！</p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 日文歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Latax】语法记录</title>
      <link href="/2021361885.html"/>
      <url>/2021361885.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.overleaf.com/learn/latex/Creating_a_document_in_LaTeX">Overleaf的LaTex教程</a></p><p><a href="https://latex.codecogs.com/eqneditor/editor.php">包含基本上所有Latex小语法的网站</a></p><p><a href="https://www.latexlive.com/">在线Latex公式编辑器（界面比第二个网站更好看）</a></p><h2 id="给字母加奇怪的东西">给字母加奇怪的东西</h2><h3 id="pmb字母加粗">\pmb{}，字母加粗</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\pmb&#123;x&#125;, \ \pmb&#123;X&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\pmb{x}, \ \pmb{X}\)</span></p><h3 id="hat头顶加小尖角">\hat{}，头顶加小尖角</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hat&#123;\gamma&#125;_&#123;j k&#125;=\frac&#123;\alpha_&#123;k&#125; \phi\left(y_&#123;j&#125; \mid \theta_&#123;k&#125;\right)&#125;&#123;\sum_&#123;k=1&#125;^&#123;R&#125; \alpha_&#123;k&#125; \phi\left(y_&#123;j&#125; \mid \theta_&#123;k&#125;\right)&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\hat{\gamma}_{j k}=\frac{\alpha_{k} \phi\left(y_{j} \mid \theta_{k}\right)}{\sum_{k=1}^{R} \alpha_{k} \phi\left(y_{j} \mid \theta_{k}\right)}\)</span></p><h2 id="各种括号和方框">各种括号和方框</h2><h3 id="begincases多种情况的表示">\begin{cases}，多种情况的表示</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\gamma_&#123;j k&#125;= \begin&#123;cases&#125;1, &amp; \text &#123; 第 &#125; j \text &#123; 个观测来自第 &#125; k \text &#123; 个分模型 &#125; \\ 0, &amp; \text &#123; 否则 &#125;\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\gamma_{j k}= \begin{cases}1, &amp; \text { 第 } j \text { 个观测来自第 } k \text { 个分模型 } \\ 0, &amp; \text { 否则 }\end{cases}\)</span></p><h3 id="beginarray方程组">\begin{array}，方程组</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left\&#123;\begin&#123;array&#125;&#123;l&#125;\mathrm&#123;e&#125;^&#123;-x_&#123;1&#125;&#125;+\mathrm&#123;e&#125;^&#123;-2 x_&#123;2&#125;&#125;+x_&#123;3&#125;-2 x_&#123;4&#125;+t_&#123;k&#125; x_&#123;5&#125;-5.3=0 \\ \mathrm&#123;e&#125;^&#123;-2 x_&#123;1&#125;&#125;+\mathrm&#123;e&#125;^&#123;-x_&#123;2&#125;&#125;-2 x_&#123;3&#125;+t_&#123;k&#125; x_&#123;4&#125;-x_&#123;5&#125;+25.6=0 \\ t_&#123;k&#125; x_&#123;1&#125;+3 x_&#123;2&#125;+\mathrm&#123;e&#125;^&#123;-x_&#123;3&#125;&#125;-3 x_&#123;5&#125;+37.8=0 \\ 2 x_&#123;1&#125;+t_&#123;k&#125; x_&#123;2&#125;+x_&#123;3&#125;-\mathrm&#123;e&#125;^&#123;-x_&#123;4&#125;&#125;+2 \mathrm&#123;e&#125;^&#123;-2 x_&#123;5&#125;&#125;-31.3=0 \\ x_&#123;1&#125;-2 x_&#123;2&#125;-3 t_&#123;k&#125; x_&#123;3&#125;+\mathrm&#123;e&#125;^&#123;-2 x_&#123;4&#125;&#125;+3 \mathrm&#123;e&#125;^&#123;-x_&#123;5&#125;&#125;+42.1=0\end&#123;array&#125;\right.</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\left\{\begin{array}{l}\mathrm{e}^{-x_{1}}+\mathrm{e}^{-2 x_{2}}+x_{3}-2 x_{4}+t_{k} x_{5}-5.3=0 \\ \mathrm{e}^{-2 x_{1}}+\mathrm{e}^{-x_{2}}-2 x_{3}+t_{k} x_{4}-x_{5}+25.6=0 \\ t_{k} x_{1}+3 x_{2}+\mathrm{e}^{-x_{3}}-3 x_{5}+37.8=0 \\ 2 x_{1}+t_{k} x_{2}+x_{3}-\mathrm{e}^{-x_{4}}+2 \mathrm{e}^{-2 x_{5}}-31.3=0 \\ x_{1}-2 x_{2}-3 t_{k} x_{3}+\mathrm{e}^{-2 x_{4}}+3 \mathrm{e}^{-x_{5}}+42.1=0\end{array}\right.\)</span></p><p>既可以用来表示矩阵，也可以用来表示方程……</p><h2 id="数学表达式">数学表达式</h2><h3 id="根式">根式</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sqrt[]&#123;&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\sqrt[n]{x+1}\)</span></p><h3 id="集合相关">集合相关</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$\exists$</span><br><span class="line">$\forall$</span><br><span class="line">$\neg$</span><br><span class="line">$\wedge$</span><br><span class="line">$\vee$ </span><br></pre></td></tr></table></figure><p><span class="math inline">\(\exists,\ \forall, \ \neg, \ \wedge,\  \vee\)</span></p><h2 id="latex中的数学字体">LaTex中的数学字体</h2><p>有些字体需要在序言中引入特定的包：<code>\usepackage&#123;amssymb&#125;</code></p><p>有些字体支持一部分字符：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">RQSZ \\</span><br><span class="line">\mathcal&#123;RQSZ&#125; \\</span><br><span class="line">\mathfrak&#123;RQSZ&#125; \\</span><br><span class="line">\mathbb&#123;RQSZ&#125;</span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\begin{align*} RQSZ \\ \mathcal{RQSZ} \\ \mathfrak{RQSZ} \\ \mathbb{RQSZ} \end{align*}\)</span></p><p>手写体，哥特黑体，黑板粗体。</p><p>也可以将整个数学表达式的字体更换为另外一种：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">3x^2 \in R \subset Q \\</span><br><span class="line">\mathrm&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathit&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathbf&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathsf&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathtt&#123;3x^2 \in R \subset Q&#125; </span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\begin{align*}3x^2 \in R \subset Q \\ \mathrm{3x^2 \in R \subset Q} \\ \mathit{3x^2 \in R \subset Q} \\ \mathbf{3x^2 \in R \subset Q} \\ \mathsf{3x^2 \in R \subset Q} \\ \mathtt{3x^2 \in R \subset Q} \end{align*}\)</span></p><p><code>\mathnormal&#123;3x^2 \in R \subset Q&#125;</code>理论上这也是一种字体，和默认字体一样的，但是hexo的渲染器会报错，就没有放上去了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
            <tag> 文档编辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【安利】好用软件及网站分享</title>
      <link href="/2675119176.html"/>
      <url>/2675119176.html</url>
      
        <content type="html"><![CDATA[<h2 id="优秀软件">1 优秀软件</h2><h3 id="文档编辑">1.1 文档编辑</h3><p>WPS，一直开会员，云文档功能yyds。</p><h3 id="笔记软件">1.2 笔记软件</h3><p>为知笔记。旧版和X版我都在用，笑死，已经变成为知笔记的形状了，一年60块买不了吃亏买不了上当。我现在写博客都是在为知笔记写完然后导出成Markdown。</p><h3 id="论文阅读和管理">1.3 论文阅读和管理</h3><p>单纯看PDF的话WPS也能满足需求，但WPS是不提供文献管理功能的，批注功能也弱了点。今天发现一个叫<strong>IvySci</strong>的软件，中文名<strong>青藤学术</strong>，竟然还是个国产软件……well，再用一段时间再来评价，目前用免费版，收费版也不贵，但收费之后的空间确实小了点，看得出小公司没那么有钱……目前最吸引我的功能是软件内用各种引擎查论文，以及一键把论文中的引用文献加入项目。改版之后翻译功能强大了太多了，强烈推荐！！！</p><p>论文管理也推荐EndNote，除了能方便的在word中插入文献，还可以为导入后的文献在SCI中搜索并下载论文本体，可以说非常方便了。</p><h3 id="对文献进行引文分析">1.4 对文献进行引文分析</h3><p>HistCist Pro。具体用法可以参考我《文献管理与信息分析》那篇博客。</p><h2 id="优秀网站">2 优秀网站</h2><h3 id="论文搜索">2.1 论文搜索</h3><p>之前一直用学校的网在SCI上查，最近觉得还是谷歌学术牛牛。但是懒得开科学上网的话，<a href="https://gfsoso.99lb.net/">谷粉学术</a>挺好用的，也可以去用<a href="https://ac.scmor.com/">镜像</a>。</p><p><a href="https://www.sci-hub.ren/">sci-hub</a>当然也是非常好的选择。</p><h3 id="电子书">2.2 电子书</h3><p><a href="https://zh.z-lib.org/">Z-图书馆</a>。免费下载大量电子书，配合Koodo简直无敌！！！</p><h3 id="论坛">2.3 论坛</h3><p>分享资源的论坛： <a href="https://21micro-grid.com/%E3%80%82">电力电子技术与新能源</a>。找《华为C++技术规范》的时候发现了这个论坛，C++和电力电子技术或许有些不搭，但这个网站上还有《华为-模拟电路讲义》，这么一来违和感就少了很多……？</p><h3 id="科研网站">2.4 科研网站</h3><p><a href="https://arxiv.org/">Arxiv</a>。已知论文编号，可以输入：https://arxiv.org/pdf/number.pdf。例如：https://arxiv.org/pdf/1702.04595.pdf。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
            <tag> 安利 </tag>
            
            <tag> 优秀网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习入门】1 强化学习概述</title>
      <link href="/4072327491.html"/>
      <url>/4072327491.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章为笔者学习网络上的强化学习教程之后的笔记，在原文和自己理解的基础上重新写作而成，基本可以认为是原文的精简版，后续可能会在阅读其他教材之后在对应章节添加例子等。<a href="https://github.com/datawhalechina/easy-rl">原教程地址</a></p></blockquote><h2 id="强化学习">1.1 强化学习</h2><p>强化学习解决的是一个智能体如何在一个复杂不确定的环境里极大化它能获得的奖励。</p><p>在环境 (environment) 中，智能体 (agent) 进行各种动作( action) 产生某种状态 (state)，据此环境给出奖励 (reward)。这里的奖励是延迟奖励，即行为的进行到奖励的求得之间往往又隔了一些动作。</p><p>强化学习的一些特征：有试错探索 (trial-and-error exploration)，探索环境来获取对环境的理解；从环境中得到延迟的奖励；每个动作在时间上是连续的；agent 的行为会影响之后的数据。</p><p>举一个雅达利 pong 游戏的例子：一块板子往上或者往下，把弹球弹到对面。整个游戏过程是预演 (rollout) 的，即从当前帧可以生成很多局游戏。agent 和环境交互会产生很多观测，每个观测是一个轨迹 (trajectory)。轨迹是当前帧以及他采取的策略，即状态和动作的一个序列：<span class="math inline">\(\tau =(s_0,a_0,s_1,a_1, \dots)\)</span>。</p><p>一场游戏叫做一个回合 (episode) 或者试验 (trial)。</p><p>最近把强化学习和深度学习结合起来，成为深度强化学习。</p><h2 id="序列决策过程">1.2 序列决策过程</h2><p>序列决策 (sequential decision making) 过程可以说是一般的单智能体 RL 的通用过程。</p><p>奖励是由环境给的一个标量的反馈信号 (scalar feedback signal)，这个信号显示了智能体在某一步采取某个策略的表现如何。强化学习训练的目的就是为了最大化智能体可以获得的奖励，智能体行动的目的就是为了极大化它的期望的累积奖励 (expected cumulative reward)。同时要进行近期奖励和远期奖励的一个平衡，最终一般希望获得更多的长期奖励。</p><p>历史是观测、行为、奖励的序列： <span class="math inline">\(H_t =\{O_1, R_1, A_1,\dots, A_{t-1},\dots\}\)</span></p><p>agent 在采取动作的时候依赖于它的历史，可以把整个游戏的状态看成这个历史的函数：<span class="math inline">\(S_t=f(H_t)\)</span>。</p><p>状态<span class="math inline">\(S\)</span>是对世界的完整描述，deep RL 中一般用实值的向量、矩阵或张量来表示状态和观测。</p><p>agent 的状态和环境的状态等价说明环境完全可观测。这种问题称为 MDP 问题。在这个问题中，<span class="math inline">\(O_t=S^e_t=S^a_t\)</span>。</p><p>否则就是部分可观测的。称为 POMDP，即部分可观测马尔科夫决策过程。POMDP 是一个马尔科夫决策过程的泛化，具有马尔科夫性质，但假设智能体无法感知环境的状态<span class="math inline">\(S\)</span>，只知道部分观测值<span class="math inline">\(O\)</span>。</p><p>用一个七元组描述马尔科夫过程：<span class="math inline">\((S, A, T, R, Ω, O, γ)\)</span>。<span class="math inline">\(S\)</span>是状态空间，隐变量；<span class="math inline">\(A\)</span>是动作空间，<span class="math inline">\(T\)</span>是状态转移概率，<span class="math inline">\(R\)</span>是奖励函数；<span class="math inline">\(Ω\)</span>是观测概率，<span class="math inline">\(O\)</span>为观测空间，<span class="math inline">\(\gamma\)</span>为折扣系数。</p><h2 id="动作空间">1.3 动作空间</h2><p>不同环境中可以进行的动作是不同的。在给定环境中，有效动作的集合被称为<strong>动作空间</strong>。<strong>离散动作空间</strong>中动作数量有限；<strong>连续动作空间</strong>中动作种类无限，此时动作是实值的向量。</p><h2 id="强化学习智能体的组成和类型">1.4 强化学习智能体的组成和类型</h2><p>策略函数 (policy function)：用这个函数来选取下一步的动作；</p><p>价值函数 (value function)：对当前状态估价；</p><p>模型 (model)：表示 agent 对这个环境的状态进行的理解，这一点决定训练如何进行。</p><h3 id="策略">1.4.1 策略</h3><p>策略一般有两种：<strong>随机性策略 (stochastic policy) </strong>和<strong>确定性策略 (deterministic policy)</strong>。</p><p>随机性策略中，每个行为的发生是有概率的，要进行采样然后再动作，也就是说概率再小的动作也可能被执行。而确定性策略则只采用最有可能的概率，即<span class="math inline">\(a^*=\arg \max_a \pi(a\mid s)\)</span>。随机性策略：输入一个状态s，输出是一个概率。进一步对概率进行采样，可以得到一个action。</p><p>对于 Atari 游戏，策略函数的输入就是游戏的一帧，他的输出决定往左或者往右。通常采用随机性策略，因为其动作具有多样性。</p><h3 id="价值函数">1.4.2 价值函数</h3><p>价值函数是对未来奖励的一个预测，用来评估状态的好坏。</p><p>价值函数里有一个折扣因子 (discount factor)。我们希望在尽可能短的时间里得到尽可能多的奖励。价值函数的定义其实是一个期望：</p><p><span class="math inline">\(v_{\pi}(s) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1} \mid S_{t}=s\right],\ \text{for all}\ s \in \mathcal{S}\)</span></p><p>上面的公式表明已知某一个策略函数的时候，到底可以得到多少奖励。</p><p>还有一种价值函数叫 Q 函数，包含两个变量状态和动作：</p><p><span class="math inline">\(q_{\pi}(s, a) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s, A_{t}=a\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1} \mid S_{t}=s, A_{t}=a\right]\)</span></p><p>Q 函数表明，奖励的期望取决于当前的状态和智能体的行为。</p><p>这两种价值函数在之后都会有详细解释和应用。</p><h3 id="模型">1.4.3 模型</h3><p>模型决定了下一个状态会是什么样的。它由两个部分组成： 概率，指状态之间如何转移；奖励函数，指在当前状态进行了某个行为后可以得到多大的奖励。</p><p>有了上述三个部分之后就得到了一个<strong>马尔科夫决策过程</strong>。</p><h3 id="强化学习智能体的类型">1.4.4 强化学习智能体的类型</h3><h4 id="基于价值的智能体与基于策略的智能体">1.4.4.1 基于价值的智能体与基于策略的智能体</h4><p>基于价值的智能体 (value-based agent)：显式学习价值函数，隐式学习策略。</p><p>基于策略的智能体 (policy-based agent)：直接学习策略，没有学习价值函数。</p><p>二者结合得到演员-评论员智能体 (actor-critic agent)，策略函数和价值函数都学习，然后通过两者交互得到一个最佳行为。</p><p>基于策略迭代和基于价值迭代的强化学习方法有什么区别？ 对一个状态转移概率已知的马尔科夫决策过程，可以用动态规划算法求解。决策方式来看，可以分为<strong>基于策略迭代的方法</strong>和<strong>基于价值迭代的方法</strong>。决策方式是静态的，不随状态变化而变化。</p><p>基于策略迭代的强化学习中，智能体会制定一套动作策略以确定给定状态下采取何种动作，并根据这个策略操作。有策略梯度算法等。基于价值迭代的方法则维护一个价值表格或函数。只能应用在不连续、离散的环境下。基于价值迭代的有 Q-learning，Sarsa等。演员-评论员算法同时使用策略和价值评估来做出决策，智能体根据策略做出动作，而价值函数会对做出的动作给出价值，这样可以在原有的策略梯度算法的基础上加速学习过程，取得更好的效果。</p><h4 id="有模型强化学习智能体与免模型强化学习智能体">1.4.4.2 有模型强化学习智能体与免模型强化学习智能体</h4><p>针对<strong>是否需要对真实环境建模</strong>，强化学习可以分为有模型学习和免模型学习。有模型学习是指根据环境中的经验，构建一个虚拟世界，同时在真实环境和虚拟世界中学习；免模型学习是指不对环境进行建模，直接与真实环境进行交互来学习到最优策略。</p><p>有模型 (model-based) 强化学习智能体通过学习状态的转移来采取动作。免模型 (model-free) 强化学习智能体没有直接估计这个状态的转移，也没有得到环境的具体转移变量，通过学习价值函数和策略函数进行决策。免模型的模型里面没有一个环境转移的模型。</p><p>免模型学习通常属于数据驱动型方法，需要大量的采样来估计状态、动作及奖励函数，从而优化动作策略。</p><h2 id="学习与规划">1.5 学习与规划</h2><p>学习 (learning) 和规划 (planning) 是序列决策的两个基本问题。</p><p>简单来说，强化学习面对环境的未知部分要进行学习，对于环境的已知部分要进行规划。</p><h2 id="探索和利用">1.6 探索和利用</h2><p>探索是指怎么探索环境，即找到能获得最大奖励的策略。利用是指不尝试新的东西，仅靠已知的信息就可以得到很大奖励的行为。</p><p>与监督学习不同，强化学习任务的最终奖赏是在多步动作之后才能观察到，这里不妨先考虑比较简单的情形：最大化单步奖赏，即<strong>仅考虑一步操作</strong>。需注意的是，即便在这样的简化情形下，<strong>强化学习仍与监督学习有显著不同</strong>，因为机器需通过尝试来发现各个动作产生的结果，而没有训练数据告诉机器应当做哪个动作。</p><p>单步强化学习对应了 K-臂赌博机 (K-armed bandit) 的模型。赌徒投入一个硬币后可选择按下一个摇臂，每个摇臂以一定的概率吐出金币，但这个概率赌徒不知道。赌徒的目标是通过一定的策略最大化自己的奖赏。 若想获知每个摇臂的期望奖赏，则可采用仅探索法，将所有机会平均分配给每个摇臂，然后计算期望。 如果只想执行奖赏最大的动作，则可采用仅利用法，按下目前最优的摇臂。若有多个最优则随机选一个。 显然，在探索和利用之间，必须要达成一个较好的折中。</p><h2 id="强化学习实验">1.7 强化学习实验</h2><p><a href="https://github.com/cuhkrlcourse/RLexample">cuhkrlcourse的RL代码</a>；</p><p>OpenAI 的 <a href="https://gym.openai.com/envs/#classic_control">Gym</a> 是一个很强的环境仿真库。离散控制场景（输出的动作是可数的，比如 Pong 游戏中输出的向上或向下动作）一般使用雅达利环境评估；连续控制场景（输出的动作是不可数的，比如机器人走路时不仅有方向，还要角度，角度就是不可数的，是一个连续的量）一般使用 mujoco 环境评估。Gym Retro 是对 Gym 环境的进一步扩展，包含了更多的一些游戏。</p><p>简书上的 <a href="https://www.jianshu.com/p/e7235f8af25e">Gym 环境总结</a>。</p><p><a href="https://gym.openai.com/docs/">Gym 的官方文档</a>。</p><h3 id="第一次使用-gym">1.7.1 第一次使用 Gym</h3><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gym  # 安装 Gym</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;Taxi-v3&quot;</span>)  <span class="comment"># 出租车接乘客的游戏</span></span><br><span class="line">observation = env.reset()</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    action = env.action_space.sample()  <span class="comment"># 随机动作</span></span><br><span class="line">    observation, reward, done, info = env.step(action)</span><br><span class="line">    <span class="built_in">print</span>(observation)</span><br></pre></td></tr></table></figure><h3 id="cartpole-例子">1.7.2 <a href="https://gym.openai.com/envs/CartPole-v1/">CartPole</a> 例子</h3><p>CartPole 要求通过控制一个平板让木棍立起来。输入是向左或向右的一个力，<span class="math inline">\(\pm1\)</span>。失败条件是木棍角度过大或平板离轨道中心太远。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym  <span class="comment"># 导入 Gym 的 Python 接口环境包</span></span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v0&#x27;</span>)  <span class="comment"># 构建实验环境</span></span><br><span class="line">env.reset()  <span class="comment"># 重置一个 episode</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    env.render()  <span class="comment"># 显示图形界面</span></span><br><span class="line">    action = env.action_space.sample()  <span class="comment"># 从动作空间中随机选取一个动作</span></span><br><span class="line">    env.step(action)  <span class="comment"># 用于提交动作，括号内是具体的动作</span></span><br><span class="line">env.close()  <span class="comment"># 关闭环境</span></span><br></pre></td></tr></table></figure><p>执行这段代码时，机器人会无视该立起来的杆子，驾驶着小车朝某个方向一通跑，直到不见踪影，这是因为动作是随机选取的。打印 env.action_space.sample() 的返回值，会发现值是 0 或 1，一左一右。env.step() 一方面是执行动作，另一方面还有四个返回值，分别是 observation、reward、done、info。</p><p>observation 是状态信息，指游戏中观测到的屏幕像素值或者盘面状态描述信息。reward 是奖励值，即 action 提交以后能够获得的奖励值。这个奖励值因游戏的不同而不同，但总体原则是对完成游戏有帮助的动作会获得比较高的奖励值。done 表示游戏是否已经完成。如果完成了，就需要重置游戏并开始一个新的回合。info 是一些比较原始的用于诊断和调试的信息，或许对训练有帮助。不过 OpenAI 团队在评价用户提交的机器人时不允许使用这些信息。</p><p>玩游戏的时候可以输出一下 observation 观察游戏的状态是怎么定义的。env.step() 完成了一个完整的<span class="math inline">\(S\rightarrow A\rightarrow R\rightarrow S^′\)</span>过程。我们只要不断观测这样的过程，并让机器在其中用相应的算法完成训练，就能得到一个高质量的强化学习模型。</p><p>想要查看当前 Gym 库已经注册了哪些环境，可以使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gym <span class="keyword">import</span> envs</span><br><span class="line">env_specs = envs.registry.<span class="built_in">all</span>()</span><br><span class="line">envs_ids = [env_spec.<span class="built_in">id</span> <span class="keyword">for</span> env_spec <span class="keyword">in</span> env_specs]</span><br><span class="line"><span class="built_in">print</span>(envs_ids)</span><br></pre></td></tr></table></figure><p>每个环境都定义了自己的观测空间和动作空间。环境 env 的观测空间用 env.observation_space 表示，动作空间用 env.action_space 表示。观测空间和动作空间既可以是离散空间，也可以是连续空间。在 Gym 库中，离散空间一般用 gym.spaces.Discrete 类表示，连续空间用 gym.spaces.Box 类表示。</p><h3 id="mountaincar-v0-例子">1.7.3 <a href="https://gym.openai.com/envs/MountainCar-v0/">MountainCar-v0</a> 例子</h3><p><strong>小车上山</strong>例子。小车要跑到右边的山顶上碰到旗子，但小车的马力不够强。唯一的办法是让小车在两个坡上来回移动，借助从左边山上冲下来的速度冲上右边的山顶。</p><h4 id="输出游戏的信息">1.7.3.1 输出游戏的信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">&#x27;MountainCar-v0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;观测空间 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.observation_space))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;动作空间 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.action_space))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;观测范围 = &#123;&#125; ~ &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.observation_space.low,</span><br><span class="line">env.observation_space.high))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;动作数 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.action_space.n))</span><br></pre></td></tr></table></figure><p>由输出可知，观测空间是形状为 (2,) 的浮点型 np.array，动作空间是取 0,1,2 的 int 型数值。</p><h4 id="实现一个智能体类">1.7.3.2 实现一个智能体类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BespokeAgent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decide</span>(<span class="params">self, observation</span>):</span> <span class="comment"># 决策</span></span><br><span class="line">        position, velocity = observation</span><br><span class="line">        lb = <span class="built_in">min</span>(-<span class="number">0.09</span> * (position + <span class="number">0.25</span>) ** <span class="number">2</span> + <span class="number">0.03</span>,</span><br><span class="line">                <span class="number">0.3</span> * (position + <span class="number">0.9</span>) ** <span class="number">4</span> - <span class="number">0.008</span>)</span><br><span class="line">        ub = -<span class="number">0.07</span> * (position + <span class="number">0.38</span>) ** <span class="number">2</span> + <span class="number">0.07</span></span><br><span class="line">        <span class="keyword">if</span> lb &lt; velocity &lt; ub:</span><br><span class="line">            action = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> action <span class="comment"># 返回动作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self, *args</span>):</span> <span class="comment"># 学习</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">agent = BespokeAgent(env)</span><br></pre></td></tr></table></figure><p>智能体的 decide() 方法实现了决策功能，而 learn() 方法实现了学习功能。BespokeAgent 类是一个比较简单的类，它只能根据给定的数学表达式进行决策，不能有效学习，只是用来演示。</p><h4 id="智能体与环境交互">1.7.3.3 智能体与环境交互</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_montecarlo</span>(<span class="params">env, agent, render=<span class="literal">False</span>, train=<span class="literal">False</span></span>):</span></span><br><span class="line">    episode_reward = <span class="number">0.</span> <span class="comment"># 记录回合总奖励，初始化为0</span></span><br><span class="line">    observation = env.reset() <span class="comment"># 重置游戏环境，开始新回合</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 不断循环，直到回合结束</span></span><br><span class="line">        <span class="keyword">if</span> render: <span class="comment"># 判断是否显示</span></span><br><span class="line">            env.render() <span class="comment"># 显示图形界面，图形界面可以用 env.close() 语句关闭</span></span><br><span class="line">        action = agent.decide(observation)</span><br><span class="line">        next_observation, reward, done, _ = env.step(action) <span class="comment"># 执行动作</span></span><br><span class="line"></span><br><span class="line">        episode_reward += reward  <span class="comment"># 收集回合奖励</span></span><br><span class="line">        <span class="keyword">if</span> train:  <span class="comment"># 判断是否训练智能体</span></span><br><span class="line">            agent.learn(observation, action, reward, done)  <span class="comment"># 学习</span></span><br><span class="line">        <span class="keyword">if</span> done:  <span class="comment"># 回合结束，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        observation = next_observation</span><br><span class="line">    <span class="keyword">return</span> episode_reward  <span class="comment"># 返回回合总奖励</span></span><br></pre></td></tr></table></figure><p>play_montecarlo 函数可以让智能体和环境交互一个回合。这个函数有 4 个参数。env 是环境类，agent 是智能体类，render 是 bool 类型变量，指示在运行过程中是否要图形化显示。</p><p>如果函数参数 render 为 True，那么在交互过程中会调用 env.render() 以显示图形化界面，而这个界面可以通过调用 env.close() 关闭。train 是 bool 类型的变量，指示在运行过程中是否训练智能体。在训练过程中应当设置为 True 以调用 agent.learn() 函数；在测试过程中应当设置为 False，使得智能体不变。这个函数有一个返回值 episode_reward，是 float 类型的数值，表示智能体与环境交互一个回合的回合总奖励。</p><h4 id="智能体与环境交互并显示">1.7.3.4 智能体与环境交互并显示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env.seed(<span class="number">0</span>) <span class="comment"># 设置随机数种子,只是为了让结果可以精确复现,一般情况下可删去</span></span><br><span class="line">episode_reward = play_montecarlo(env, agent, render=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回合奖励 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(episode_reward))</span><br><span class="line">env.close() <span class="comment"># 此语句可关闭图形界面</span></span><br></pre></td></tr></table></figure><p>为了系统评估智能体的性能，下列代码求出了连续交互 100 回合的平均回合奖励。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">episode_rewards = [play_montecarlo(env, agent) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;平均回合奖励 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(np.mean(episode_rewards)))</span><br></pre></td></tr></table></figure><p>小车上山环境有一个参考的回合奖励值 -110，如果连续 100 个回合的平均回合奖励大于 -110，则认为这个任务被解决了。espokeAgent 类对应的策略的平均回合奖励大概就在 -105 左右。</p><p>测试智能体在 Gym 库中某个任务的性能时学术界一般最关心 100 个回合的平均回合奖励，选这个数字完全是习惯使然。对于有些环境会指定一个参考的回合奖励值，当连续 100 个回合的奖励大于指定的值时，就认为这个任务被解决了。但并不是所有的任务都指定了这样的值。</p><p>总结一下 Gym 的用法：使用 <strong>env=gym.make(环境名)</strong> 取出环境，使用 <strong>env.reset()</strong> 初始化环境，使用 <strong>env.step(动作)</strong> 执行一步环境，使用 <strong>env.render()</strong> 显示环境，使用 <strong>env.close()</strong> 关闭环境。</p><h2 id="关键词">1.8 关键词</h2><p>强化学习 (reinforcement learning, RL)：智能体与复杂且不确定的环境进行交互时，尝试使所获得的奖励最大化的计算算法。</p><p>动作 (action)：环境接收到的智能体当前状态的输出。</p><p>状态 (state)：智能体从环境中获取到的状态。</p><p>奖励 (reward)：智能体从环境中获取的反馈信号，这个信号代表智能体在某一步采取某个策略以后是否得到奖励以及奖励的大小。</p><p>探索 (exploration)：在当前的情况下，继续尝试新的动作。智能体有可能会得到更高的奖励，也有可能一无所获。</p><p>规划 (planning)：在当前的情况下，使用已知的可以获得最大奖励的动作。</p><p>深度强化学习 (deep reinforcement learning)：不需要手工设计特征，仅需要输入状态让系统直接输出动作的一个端到端 (end-to-end) 的强化学习方法。通常使用神经网络来拟合价值函数 (value function) 或者策略网络 (policy network)。</p><p>全部可观测 (full observability)、完全可观测 (fully observed) 和部分可观测 (partially observed)：当智能体的状态与环境的状态等价时，称环境是全部可观测的；当智能体能够观察到环境的所有状态时，称环境是完全可观测的。智能体不能观察到环境的所有状态时，称环境是部分可观测的。</p><p>部分可观测马尔可夫决策过程 (partially observable Markov decision process, POMDP)：即马尔可夫决策过程的泛化。部分可观测马尔可夫决策过程依然具有马尔可夫性质，但是其假设智能体无法感知环境的状态，只能知道部分观测值。</p><p>动作空间 (action space)、离散动作空间 (discrete action space)、连续动作空间 (continuous action space)：在给定的环境中，有效动作的集合被称为动作空间，智能体的动作数量是有限的动作空间为离散动作空间，反之，则被称为连续动作空间。</p><p>基于策略的 (policy-based)：智能体会制定一套动作策略，即确定在给定状态下需要采取何种动作，并根据这个策略进行操作。强化学习算法直接对策略进行优化，使制定的策略能够获得最大的奖励。</p><p>基于价值的 (valued-based)：智能体不需要制定显式的策略，它维护一个价值表格或者价值函数，并通过这个价值表格或价值函数来选取价值最大的动作。</p><p>有模型结构 (model-based)：智能体通过学习状态的转移来采取措施。</p><p>免模型结构 (model-free)：智能体没有直接估计状态的转移，也没有得到环境的具体转移变量。它通过学习价值函数 (value function) 或者策略网络 (policy network) 进行决策。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HEXO搭建个人网站】2 网站迁移到新电脑</title>
      <link href="/200109796.html"/>
      <url>/200109796.html</url>
      
        <content type="html"><![CDATA[<h3 id="将网站迁移到新电脑">将网站迁移到新电脑</h3><p>安装nodejs和git for windows，npm中安装hexo：<code>npm install -g hexo-cli</code>。之后把博客文件夹从旧电脑复制过来即可。</p><p>为了上传，还要配置一下新电脑和github仓库之间的联系。这里还是放一个比较好的<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">教程</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 个人网站 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WPS】使用技巧</title>
      <link href="/3253309366.html"/>
      <url>/3253309366.html</url>
      
        <content type="html"><![CDATA[<h2 id="公式中插入超过33的矩阵">1 公式中插入超过<span class="math inline">\(3*3\)</span>的矩阵</h2><p>​ 恕我直言，WPS最新版这个公式属实邪门。用起来没有更方便，甚至都不能自己手动把界面下拉让用户能看到更多的选项…… ​ 今天遇到的问题是WPS自带的公式功能最大插入<span class="math inline">\(3*3\)</span>矩阵，但我需要用到<span class="math inline">\(1*7\)</span>的矩阵。方法是首先插入一个<span class="math inline">\(1*3\)</span>​​的矩阵，然后选中整个矩阵（不包括括号），然后右键——插入——在此前插入列（或者在此后插入列），这样就可以突破原本的<span class="math inline">\(3*3\)</span>的限制了……</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
            <tag> 文档编辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【日文歌词】游戏王《Overlap》歌词（中日语+假名对照版）</title>
      <link href="/abac2baf.html"/>
      <url>/abac2baf.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。</p></blockquote><p>かくせないほどまばゆいひかり　せいじゃくやぶりこのよによみがえる<br />隠　せないほど眩　　い光　　　静　寂　　破　りこの世に甦　　　る<br />难以隐藏的炫目光芒　　　　　　划破沉寂　　　　在这世上苏醒</p><p>はげしいくゆらぐかわいただいち　いのちをかけてひばなぶすけあう<br />はげしいく揺らぐ渇　いた大　地　命　　をかけて火花　ぶすけ合う<br />与剧烈震荡的干涸大地　　　　　　不惜生命般摩擦出火花</p><p>もういちどだけでいい　きせきおきてよ<br />もう一　度だけでいい　奇跡　起きてよ<br />再一次就好　　　　　　发生奇迹吧</p><p>かこになくしたきおくのページをとりもどすちからを<br />過去になくした記憶　のページを取り戻どすpower を<br />请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして<br />闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして<br />坚信能冲破黑暗的心　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす<br />瞬　　きできない　鋭　　い眼　光　を燃やす<br />眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ<br />光　　と影　の二　つの心　　　クリスタルに映　る未来　へ<br />光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES<br />今　動き　出す　紅　く漲　　るEYES<br />此刻开始行动　　那涨红的双眼</p><hr /><p>たがいのきずをなめあうひびに　おわりをつげて　しずかにたちあがる<br />互　いの傷　を舐め合う日々に　终わりを告　て　静　かに立ち上がる<br />对互相舔舐伤口的时光　　　　　宣告终结　　　　静静站起身来</p><p>ちいさなあかりともしたよるの　きみとかわしたやくそくまもりぬく<br />小　さな明かり灯した　夜　の　君　と交　した約　束　守　り抜く<br />那微灯映照之夜　　　　　　　　与你结下的约定　　　　我会坚守到底</p><p>かすむしんきろうがきみをみせるよ<br />霞　む蜃　気楼　が君　を见せるよ<br />模糊的幻象之中　　看见了你的身影</p><p>すすんださきになにがおきてもまけわしないかくごで<br />進　んだ先　に何　が掟　　も負けわしない覚　悟で<br />无论前路上发生什么　　　　　我都会有绝不认输的觉悟</p><p>きせきはおこるしんじるこころ　むかえにきたしょうりのめがみが<br />奇跡　は起こる信　じる心　　　迎　えに来た勝　　利の女神　が<br />坚信能引发奇迹的心　　　　　　胜利女神将迎接它的到来</p><p>すべてをたおすどんなかべにもひるまない<br />全　てを倒　すどんな壁　にも怯　まない<br />打倒一切敌人　不畏惧任何困难</p><p>まよいつづけるふたつのこころ　いろあせることないせかいへ<br />迷　い続　ける二　つの心　　　色　褪せることない世界　へ<br />仍在迷惘的两颗心　　　　　　　一同前往永不黯淡的世界</p><p>いまかがやくよ　かさなりあったEYES<br />今　輝　　くよ　重　なりあったEYES<br />此刻绽放光芒　　那重合的双眼</p><p>しずむたいようにつきがとけるよ<br />沈　む太　陽　に月　が溶けるよ<br />月亮融化在西沉的落日之中</p><p>かこになくしたきおくのページをとりもどすちからを<br />過去になくした記憶　のページを取り戻どすpower を<br />请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして<br />闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして<br />坚信能冲破黑暗的心　　　　　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす<br />瞬　　きできない　鋭　　い眼　光　を燃やす<br />眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ<br />光　　と影　の二　つの心　　　クリスタルに映　る未来　へ<br />光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES<br />今　動き　出す　紅　く漲　　るEYES<br />此刻开始行动　　那涨红的双眼</p><p>かさなりあうEYES<br />重　なり合うEYES<br />那重合的双眼</p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 日文歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】基础知识点总结</title>
      <link href="/79803d5e.html"/>
      <url>/79803d5e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容均来源于网络，如尚硅谷的免费视频课程、菜鸟教程和优质博客等；本文仅供学习交流使用。</p></blockquote><h2 id="初识java">初识Java</h2><p>Java发行版有多个后缀名，通常Java SE 开发桌面级应用；Java EE 开发web应用；Java ME运行在移动端；</p><p>Java的应用：企业级应用；Android平台开发；大数据平台开发；移动领域应用；</p><p>Java的特点： 一：面向对象。类，对象；封装，继承，多态； 二：健壮性；三：跨平台性，通过JVM虚拟机实现；</p><p>两个核心机制：虚拟机和垃圾回收机制；</p><p>JDK：Java开发工具包，其中包含了JRE。其中有编译工具javac.exe和打包工具jar.exe。 JRE：Java运行环境，包括虚拟机和Java程序所需核心类库等。想运行一个开发好的Java程序，只安装JRE即可。</p><p>JDK的目录：bin，基本程序；db，数据库；include，头文件；lib，jar包；src，常用的类库和源码；</p><p>程序员编写.java 源文件，用javac.exe编译为.class 字节码文件，再用Java.exe运行；</p><p>编译运行java源文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac helloworld.java  (加后缀)</span><br><span class="line">java helloworld  （不加后缀）</span><br></pre></td></tr></table></figure><p>Java严格区分大小写，但是Windows路径不区分大小写；</p><p>注释分为单行注释、多行注释和文档注释；文档注释可被编译器编译，生成网页形式的说明文档；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">javadoc -d myHello -author -version HelloJava.java</span><br></pre></td></tr></table></figure><p>一个源文件中可以写多个类，但最多只能有一个类声明为public，并且这个类得和.java文件同名。 编译时每个类单独生成一个class文件。</p><h2 id="不知道学了多少遍的基础知识"><del>不知道学了多少遍的</del>基础知识</h2><h4 id="变量相关">变量相关</h4><p>Java中有关键字和保留字。保留字现在还不是关键字但以后可能会是。 自己起的变量名叫<strong>标识符</strong>，注意不能用数字开头；</p><p>命名规范：包名全小写；类名接口名所有单词首字母大写；变量和方法名第一个单词首字母小写，后面开始大写；常量名全大写，单词之间用_连接；变量必须定义在作用域（{}）中；</p><p>声明long型变量以l或者L结尾； char中只能有一个字符，可以是转义字符； Unicode底层字符，可以是如同'123'的字符；保存文件的时候用ANSI编码时，cmd可以输出中文；</p><h4 id="类型之间的关系">类型之间的关系</h4><p>byte、char、short同级，运算之后必须赋值给int类型的变量；强制类型转换时截断或者变成最小值； byte b+1编译不通过，因为默认常数是int型，小数是double型； string可以和boolean类型做运算，结果为后面连接一个true或者false；</p><p>进行赋值时，八进制用0开头，二进制0b开头，十六进制0x开头；</p><h4 id="运算符">运算符</h4><p>运算符分为算术、赋值、比较、逻辑、位运算、三元运算符； 取余运算的结果符号与被模数的符号相同。</p><p>自增1不会改变本身数据的类型（针对int，byte等类型）；Java支持连续赋值； +=不会改变变量本身的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 += <span class="number">2</span>;  <span class="comment">// 可通过编译；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n);  <span class="comment">// 32</span></span><br></pre></td></tr></table></figure><p>比较运算符结果都是Boolean型； instanceof()：检查是否是类的对象；</p><p>&amp;&amp; 短路与；|| 短路或；^ 逻辑异或。短路运算符按顺序运行，如果左侧的表达式已知其值是true或者false，则右侧的表达式不会进行计算； 逻辑运算符只能适用于布尔类型变量；</p><p>位运算：直接对整数的二进制进行运算。&gt;&gt;&gt; 无符号右移（不管被移动数字是正还是负，最高位都用0补齐）；~取反运算；</p><p>使用位运算符交换两个变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure><p>单目运算符、三元运算符、赋值运算符都是从右向左计算；这导致a?b:c?d:e 等价于 a?b:(c?d:e) 而不是 (a?b:c)?d:e</p><h4 id="java程序在控制台进行交互">Java程序在控制台进行交互</h4><p>从键盘获取不同类型变量：使用Scanner类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> num = scan.nextInt();</span><br><span class="line">string: scan.next();</span><br><span class="line">scan.nextDouble();</span><br><span class="line">scan.nextBoolean();</span><br></pre></td></tr></table></figure><p>char型没有单独的输入方式，可以用读取字符串的方式读入，再从中取出某一位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(i);</span><br><span class="line"></span><br><span class="line">String s = readKeyBoard(i);  <span class="comment">// 从键盘读入一个长度i的字符串</span></span><br><span class="line">s.tpUpperCase();  <span class="comment">// 变成大写</span></span><br><span class="line">s.charAt(i);  <span class="comment">// 可以取出某个位置的字符</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span>)(Math.random()*<span class="number">90</span>+<span class="number">10</span>);  <span class="comment">// random产生0到1的随机数</span></span><br></pre></td></tr></table></figure><p>switch后面的表达式类型可以是：byte，short，char，int，枚举类型，string</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x，y[];  <span class="comment">// x是一维数组，y是二维数组；</span></span><br><span class="line"><span class="comment">// 此时x代表一个对象（Java和C不同）</span></span><br><span class="line">y[<span class="number">0</span>] = x; <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">array2 = array1;  <span class="comment">// 即可完成数组的复制，注意这个时候array2和array1指向同一个位置，改array2，array1也会改变</span></span><br><span class="line"><span class="comment">// 正确的数组复制需要new一个数组，逐个赋值</span></span><br></pre></td></tr></table></figure><p>Java的string可以很长。</p><h4 id="数组">数组</h4><p>数组的元素可以是基本或者引用数据类型；数组长度定好之后不能修改！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] ids;</span><br><span class="line">ids = <span class="keyword">new</span> in[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>数组元素是引用数据类型则默认值是null；</p><p>arrays工具类的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(int[] a, int[] b);  //判断两个数组是否相等</span><br><span class="line">String toString(int[] a);  //输出数组信息</span><br><span class="line">void fill(int[] a, int val);  //指定值填充到数组中</span><br><span class="line">void sort(int[] a);  //排序</span><br><span class="line">int binarySearch(int[] a, int key);  //对排序后的数组进行二分法检索指定的值</span><br></pre></td></tr></table></figure><p>数组如果没有赋值会报空指针错误，null；</p><h4 id="新建变量的存储位置">新建变量的存储位置</h4><p>栈中：存放局部变量；堆中：new出来的对象和数组； string：常量池中；static类型的变量：保存在静态域中；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] arr2 = new String[3][2];</span><br><span class="line">String[][] arr3 = new String[3][];</span><br></pre></td></tr></table></figure><h2 id="java面向对象">Java面向对象</h2><p>Java类及类的成员包含的“内容”：属性，方法，构造器； 其中有些特殊的成员：代码块，内部类 面向对象的三大特性：封装，继承，多态。有些人还命名的其他特性如抽象性。</p><h4 id="类和对象">类和对象</h4><p>类的成员：属性（成员变量），行为（方法函数）。</p><p>属性直接定义在类的{}里，局部变量在方法等的内部； 局部变量不能加修饰符（除了final）。非static属性是类的每个对象都有一套。</p><p><del>小tips：alt+左箭头可以快速到函数定义位置或返回</del></p><p>如果要使用对象的方法，哪怕是在对象内部使用也要new一个对象；</p><p>四舍五入取整：Math.round(double d)；非对象语言和Java交互的时候依然表现为对象；</p><p>引用数据类型在使用的时候其变量名都是代表地址值；</p><p>匿名对象的使用（每次都重新创建一个对象）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new phone().sendEmail();</span><br><span class="line">mall.show(mew phone()); </span><br></pre></td></tr></table></figure><p>函数的值传递机制： 参数是基本数据类型，实参赋给形参的是他储存的真实数据值； 参数是引用数据类型，形参得到的是变量所保存的数据的地址值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(char[] x); //直接输出了char数组</span><br></pre></td></tr></table></figure><h4 id="重载">重载</h4><p>重载两同一不同：同一个类，相同方法名；参数列表不同：参数个数或者类型不同； 返回值相同或者不同都可以构成重载；</p><p>可变个数形参的方法：public void show(String ... strs)；即“数据类型 ... 数据名”的形式；参数数量可以是0个。</p><p>需要注意可变个数形参的方法与把数组作为参数的方法不构成重载； 可变个数形参必须放在最后；重载的函数中最多声明一个可变个数形参；</p><h4 id="类的封装和隐藏">类的封装和隐藏</h4><p>把类的属性声明成private，则类外不能直接调用属性；只能通过方法如setlegs，getlegs. 封装性的体现需要权限修饰符来配合：private，缺省，protected，public（从小到大）。 属性体现封装性，类也可以体现封装性；</p><table><thead><tr class="header"><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr class="odd"><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr class="even"><td>default</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr class="odd"><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr class="even"><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>有四种权限修饰符可以修饰类和类的内部结构。class的权限只可以用public和default； 不同的包可以定义重名类。</p><p>构造器：功能是创建对象，实际使用中和类同名。不显式定义则默认提供一个空参的构造器。构造器严格来说不是方法，可以重载。</p><p>属性赋值的先后顺序：默认，显式初始化，构造器中赋值，调用属性进行赋值。</p><p>Javabean：特殊的java类。类是公共的，有一个无参的公共的构造器，有属性，有对应的get，set方法；可重用组件。</p><p>默认构造器的权限和其所在的类相同。</p><p>在开发过程中，为了清晰的显示类和类之间的关系，可以使用UML类图。</p><h4 id="this和import的使用">this和import的使用</h4><p>方法内部用，则表示对该方法对象的引用；构造器内部使用，表示构造器正在初始化的对象；</p><p>this表示当前对象，可以修饰方法，属性；</p><p>类的方法中可以使用this.属性或this.方法，构造器中也可以this修饰方法和属性；</p><p>this调用构造器：this(args)，主要是为了减少构造器中的冗余代码；自始至终对象只有一个；this(args)必须声明在当前构造器首行，构造器内部最多只能调用一个其他构造器；</p><p><del>ALT+SHITF+S 调出代码生成器</del></p><p>package：更好的管理类，声明类或者接口属于的包，放在首行；</p><p>MVC设计模式：M模型处理数据，V视图显示数据，C控制处理业务逻辑；</p><p>import：在源文件中使用import导入指定包下的类和接口；声明在包和类的声明之间；import xxx.*导入其下所有内容，但是不包含其中的子包；</p><p>import static：导入类或接口中的静态结构，同时import static的结尾一定是.*</p><p><del>持续更新ing</del></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HEXO搭建个人网站】1 基础知识</title>
      <link href="/b077d8cb.html"/>
      <url>/b077d8cb.html</url>
      
        <content type="html"><![CDATA[<h3 id="环境搭建">环境搭建</h3><p>首先安装node.js，直接官网下载安装。接着安装git for windows，直接官网安装（访问官网及后续安装搞个梯子会方便很多）。安装之后用下述语句查看版本以确认安装成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>新建一个文件夹用于存放博客相关的环境和内容配置，例如"blog"。在该文件夹中右击，选择"Git bash here"。安装HEXO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级，可不进行</span><br><span class="line">hexo init #初始化博客</span><br></pre></td></tr></table></figure><p>HEXO的常用指令如下（这些指令均要在上面创建的blog文件夹路径下运行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章</span><br><span class="line">hexo g == hexo generate # 生成</span><br><span class="line">hexo s == hexo server # 启动服务预览（安装hexo之后直接就可以进行）</span><br><span class="line">hexo d == hexo deploy # 部署到GitHub（需要预先与GitHub进行连接）</span><br><span class="line"># 上面的几条语句，使用的时候输入&quot;==&quot;前面的部分就可以了。</span><br><span class="line"></span><br><span class="line">hexo server # Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s # 静态模式</span><br><span class="line">hexo server -p 5000 # 更改端口</span><br><span class="line">hexo server -i 192.168.1.1 # 自定义 IP</span><br><span class="line">hexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure><p>这样就可以在本地预览网站效果。为了能在其他设备上访问自己的网站，我选择GitHub托管自己的数据。</p><p>具体的操作是在GitHub上建立仓库，然后配置权限让自己可以把blog的内容直接部署到GitHub上。上传成功之后就可以用仓库的名称来访问博客，如我的是"shymuel.github.io"。但github的后缀容易被墙，我的解决方法是自己购买一个域名。国内域名需要实名审核但比较保险，大家可以自行选择合适的域名商。</p><h3 id="volantis主题使用">Volantis主题使用</h3><p>HEXO使用量最大的主题大概就是<a href="http://theme-next.iissnan.com/getting-started.html">NexT</a>了，它的功能十分强大，看起来也比较简洁。</p><p>我为了看起来更加的二次元而选择了<a href="https://volantis.js.org/v5/getting-started/">Volantis</a>主题，主要是为了使用它的定时换背景功能（因为我有太多壁纸想放上去了）。图片目前我还是放在本地，采用相对路径。后面抽空研究一下如何使用CDN实现图片读取。</p><p>Volantis自带文章目录功能，可根据md文件中的标题在网页一侧生成目录。</p><p>配置背景图、头像之类的需要在blog文件夹下新建名为"_config.volantis.yml"的文件进行配置。建议按照<a href="https://volantis.js.org/v5/theme-settings/">主题文档</a>进行。</p><p>对于字数统计和阅读时长显示，先要安装wordcount插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount </span><br></pre></td></tr></table></figure><p>之后可以通过主题配置文件里的 word_count 关键字来选择是否开启此功能，默认false。在配置文件的enable后面加上true。</p><h3 id="twikoo评论插件">Twikoo评论插件</h3><p>根据<a href="https://twikoo.js.org/quick-start.html">官方文档</a>进行配置。我选择的是Vercel部署方式。原开发者做了非常非常详细的<a href="https://www.bilibili.com/video/BV1Fh411e7ZH">视频教程</a>。我把_config.volantis.yml中关于评论的设置改成了如下的样子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">twikoo:</span><br><span class="line">    js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本</span><br><span class="line">    path: # 全局评论地址</span><br><span class="line">    # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项</span><br><span class="line">    envId: https://twikoo-dusky.vercel.app/ # vercel id</span><br><span class="line">    appId: # your appId</span><br><span class="line">    appKey: # your appKey</span><br><span class="line">    meta: [nick,mail,link] # valine comment header info</span><br><span class="line">    requiredFields: [nick,mail]</span><br><span class="line">    enableQQ: true # Unstable avatar link</span><br><span class="line">    recordIP: false # Record commenter IP</span><br><span class="line">    avatar: img/avatar.jpg # gravatar style https://valine.js.org/avatar</span><br><span class="line">    pageSize: 10 # comment list page size</span><br><span class="line">    lang: zh-cn</span><br><span class="line">    highlight: true</span><br><span class="line">    mathJax: false</span><br><span class="line"></span><br></pre></td></tr></table></figure> 部署之后还可以根据自己的需求，下载密钥设置管理员密码来对评论系统进行管理和定制。</p><h3 id="暗黑模式">暗黑模式</h3><p>按照_config.volantis.yml中的描述，修改navbar目录，在menu子目录中添加： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- name: 暗黑模式 # 可自定义</span><br><span class="line">      icon: fas fa-moon # 可自定义</span><br><span class="line">      toggle: darkmode</span><br></pre></td></tr></table></figure></p><h3 id="自动生成文章的唯一永久链接">自动生成文章的唯一永久链接</h3><p>使用abbrlink生成。首先下载abbrlink。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>之后修改根目录站点配置文件config.yml，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://自己的网址名/</span><br><span class="line">permalink: :abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc32   #算法： crc16(default) and crc32</span><br></pre></td></tr></table></figure><p>之后hexo三连即可。</p><h3 id="插入latex公式">插入LateX公式</h3><p>更换渲染工具为 hexo-renderer-pandoc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装 hexo-math 插件以支持 latex 公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>volantis主题的话，在_config.volantis.yml中把mathjax后面改成true即可。注意要clean之后重新生成，latax公式才能正常显示。</p><p>记得要在有公式的博客开头加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 个人网站 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/b585e161.html"/>
      <url>/b585e161.html</url>
      
        <content type="html"><![CDATA[<p>最后还是回来写代码了……感觉传统工科的老师都在搞机器学习，那我也没有办法，只能重新回来刷题。</p><p>这个博客上的内容可能会写的支离破碎一些，毕竟现在都在做各种项目，也不可能把全部的代码放上来，大概只是记录一下自己能做到什么功能吧，核心代码也会放一些。</p><h1 id="section">2024.1.20</h1><p>太久没有发博客了，新的一年，争取月更！</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
