<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WPS使用技巧记录</title>
      <link href="/3253309366.html"/>
      <url>/3253309366.html</url>
      
        <content type="html"><![CDATA[<h3 id="公式中插入超过33的矩阵">公式中插入超过<span class="math inline">\(3*3\)</span>的矩阵</h3><p>​ 恕我直言，WPS最新版这个公式属实邪门。用起来没有更方便，甚至都不能自己手动把界面下拉让用户能看到更多的选项…… ​ 今天遇到的问题是WPS自带的公式功能最大插入<span class="math inline">\(3*3\)</span>矩阵，但我需要用到<span class="math inline">\(1*7\)</span>的矩阵。方法是首先插入一个<span class="math inline">\(1*3\)</span>​​的矩阵，然后选中整个矩阵（不包括括号），然后右键——插入——在此前插入列（或者在此后插入列），这样就可以突破原本的<span class="math inline">\(3*3\)</span>的限制了……</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏王-Overlap歌词（中日语+假名对照版）</title>
      <link href="/abac2baf.html"/>
      <url>/abac2baf.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。</p></blockquote><p>かくせないほどまばゆいひかり　せいじゃくやぶりこのよによみがえる 隠　せないほど眩　　い光　　　静　寂　　破　りこの世に甦　　　る 难以隐藏的炫目光芒　　　　　　划破沉寂　　　　在这世上苏醒</p><p>はげしいくゆらぐかわいただいち　いのちをかけてひばなぶすけあう はげしいく揺らぐ渇　いた大　地　命　　をかけて火花　ぶすけ合う　 与剧烈震荡的干涸大地　　　　　　不惜生命般摩擦出火花</p><p>もういちどだけでいい　きせきおきてよ もう一　度だけでいい　奇跡　起きてよ 再一次就好　　　　　　发生奇迹吧</p><p>かこになくしたきおくのページをとりもどすちからを 過去になくした記憶　のページを取り戻どすpower を 请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして　 闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして 坚信能冲破黑暗的心　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす 瞬　　きできない　鋭　　い眼　光　を燃やす 眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ 光　　と影　の二　つの心　　　クリスタルに映　る未来　へ 光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES 今　動き　出す　紅　く漲　　るEYES 此刻开始行动　　那涨红的双眼</p><hr /><p>たがいのきずをなめあうひびに　おわりをつげて　しずかにたちあがる 互　いの傷　を舐め合う日々に　终わりを告　て　静　かに立ち上がる 对互相舔舐伤口的时光　　　　　宣告终结　　　　静静站起身来</p><p>ちいさなあかりともしたよるの　きみとかわしたやくそくまもりぬく 小　さな明かり灯した　夜　の　君　と交　した約　束　守　り抜く 那微灯映照之夜　　　　　　　　与你结下的约定　　　　我会坚守到底</p><p>かすむしんきろうがきみをみせるよ 霞　む蜃　気楼　が君　を见せるよ 模糊的幻象之中　　看见了你的身影</p><p>すすんださきになにがおきてもまけわしないかくごで 進　んだ先　に何　が掟　　も負けわしない覚　悟で 无论前路上发生什么　　　　　我都会有绝不认输的觉悟</p><p>きせきはおこるしんじるこころ　むかえにきたしょうりのめがみが 奇跡　は起こる信　じる心　　　迎　えに来た勝　　利の女神　が 坚信能引发奇迹的心　　　　　　胜利女神将迎接它的到来</p><p>すべてをたおすどんなかべにもひるまない　 全　てを倒　すどんな壁　にも怯　まない 打倒一切敌人　不畏惧任何困难</p><p>まよいつづけるふたつのこころ　いろあせることないせかいへ 迷　い続　ける二　つの心　　　色　褪せることない世界　へ 仍在迷惘的两颗心　　　　　　　一同前往永不黯淡的世界</p><p>いまかがやくよ　かさなりあったEYES 今　輝　　くよ　重　なりあったEYES 此刻绽放光芒　　那重合的双眼</p><p>しずむたいようにつきがとけるよ 沈　む太　陽　に月　が溶けるよ 月亮融化在西沉的落日之中</p><p>かこになくしたきおくのページをとりもどすちからを 過去になくした記憶　のページを取り戻どすpower を 请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして　 闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして 坚信能冲破黑暗的心　　　　　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす 瞬　　きできない　鋭　　い眼　光　を燃やす 眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ 光　　と影　の二　つの心　　　クリスタルに映　る未来　へ 光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES 今　動き　出す　紅　く漲　　るEYES 此刻开始行动　　那涨红的双眼</p><p>かさなりあうEYES 重　なり合うEYES 那重合的双眼</p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 日文歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识点总结</title>
      <link href="/79803d5e.html"/>
      <url>/79803d5e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容均来源于网络，如尚硅谷的免费视频课程、菜鸟教程和优质博客等；本文仅供学习交流使用。</p></blockquote><h2 id="初识java">初识Java</h2><p>Java发行版有多个后缀名，通常Java SE 开发桌面级应用；Java EE 开发web应用；Java ME运行在移动端；</p><p>Java的应用：企业级应用；Android平台开发；大数据平台开发；移动领域应用；</p><p>Java的特点： 一：面向对象。类，对象；封装，继承，多态； 二：健壮性；三：跨平台性，通过JVM虚拟机实现；</p><p>两个核心机制：虚拟机和垃圾回收机制；</p><p>JDK：Java开发工具包，其中包含了JRE。其中有编译工具javac.exe和打包工具jar.exe。 JRE：Java运行环境，包括虚拟机和Java程序所需核心类库等。想运行一个开发好的Java程序，只安装JRE即可。</p><p>JDK的目录：bin，基本程序；db，数据库；include，头文件；lib，jar包；src，常用的类库和源码；</p><p>程序员编写.java 源文件，用javac.exe编译为.class 字节码文件，再用Java.exe运行；</p><p>编译运行java源文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac helloworld.java  (加后缀)</span><br><span class="line">java helloworld  （不加后缀）</span><br></pre></td></tr></table></figure><p>Java严格区分大小写，但是Windows路径不区分大小写；</p><p>注释分为单行注释、多行注释和文档注释；文档注释可被编译器编译，生成网页形式的说明文档；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">javadoc -d myHello -author -version HelloJava.java</span><br></pre></td></tr></table></figure><p>一个源文件中可以写多个类，但最多只能有一个类声明为public，并且这个类得和.java文件同名。 编译时每个类单独生成一个class文件。</p><h2 id="不知道学了多少遍的基础知识"><del>不知道学了多少遍的</del>基础知识</h2><h4 id="变量相关">变量相关</h4><p>Java中有关键字和保留字。保留字现在还不是关键字但以后可能会是。 自己起的变量名叫<strong>标识符</strong>，注意不能用数字开头；</p><p>命名规范：包名全小写；类名接口名所有单词首字母大写；变量和方法名第一个单词首字母小写，后面开始大写；常量名全大写，单词之间用_连接；变量必须定义在作用域（{}）中；</p><p>声明long型变量以l或者L结尾； char中只能有一个字符，可以是转义字符； Unicode底层字符，可以是如同''的字符；保存文件的时候用ANSI编码时，cmd可以输出中文；</p><h4 id="类型之间的关系">类型之间的关系</h4><p>byte、char、short同级，运算之后必须赋值给int类型的变量；强制类型转换时截断或者变成最小值； byte b+1编译不通过，因为默认常数是int型，小数是double型； string可以和boolean类型做运算，结果为后面连接一个true或者false；</p><p>进行赋值时，八进制用0开头，二进制0b开头，十六进制0x开头；</p><h4 id="运算符">运算符</h4><p>运算符分为算术、赋值、比较、逻辑、位运算、三元运算符； 取余运算的结果符号与被模数的符号相同。</p><p>自增1不会改变本身数据的类型（针对int，byte等类型）；Java支持连续赋值； +=不会改变变量本身的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 += <span class="number">2</span>;  <span class="comment">// 可通过编译；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n);  <span class="comment">// 32</span></span><br></pre></td></tr></table></figure><p>比较运算符结果都是Boolean型； instanceof()：检查是否是类的对象；</p><p>&amp;&amp; 短路与；|| 短路或；^ 逻辑异或。短路运算符按顺序运行，如果左侧的表达式已知其值是true或者false，则右侧的表达式不会进行计算； 逻辑运算符只能适用于布尔类型变量；</p><p>位运算：直接对整数的二进制进行运算。&gt;&gt;&gt; 无符号右移（不管被移动数字是正还是负，最高位都用0补齐）；~取反运算；</p><p>使用位运算符交换两个变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure><p>单目运算符、三元运算符、赋值运算符都是从右向左计算；这导致a?b:c?d:e 等价于 a?b:(c?d:e) 而不是 (a?b:c)?d:e</p><h4 id="java程序在控制台进行交互">Java程序在控制台进行交互</h4><p>从键盘获取不同类型变量：使用Scanner类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> num = scan.nextInt();</span><br><span class="line">string: scan.next();</span><br><span class="line">scan.nextDouble();</span><br><span class="line">scan.nextBoolean();</span><br></pre></td></tr></table></figure><p>char型没有单独的输入方式，可以用读取字符串的方式读入，再从中取出某一位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(i);</span><br><span class="line"></span><br><span class="line">String s = readKeyBoard(i);  <span class="comment">// 从键盘读入一个长度i的字符串</span></span><br><span class="line">s.tpUpperCase();  <span class="comment">// 变成大写</span></span><br><span class="line">s.charAt(i);  <span class="comment">// 可以取出某个位置的字符</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span>)(Math.random()*<span class="number">90</span>+<span class="number">10</span>);  <span class="comment">// random产生0到1的随机数</span></span><br></pre></td></tr></table></figure><p>switch后面的表达式类型可以是：byte，short，char，int，枚举类型，string</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x，y[];  <span class="comment">// x是一维数组，y是二维数组；</span></span><br><span class="line"><span class="comment">// 此时x代表一个对象（Java和C不同）</span></span><br><span class="line">y[<span class="number">0</span>] = x; <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">array2 = array1;  <span class="comment">// 即可完成数组的复制，注意这个时候array2和array1指向同一个位置，改array2，array1也会改变</span></span><br><span class="line"><span class="comment">// 正确的数组复制需要new一个数组，逐个赋值</span></span><br></pre></td></tr></table></figure><p>Java的string可以很长。</p><h4 id="数组">数组</h4><p>数组的元素可以是基本或者引用数据类型；数组长度定好之后不能修改！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] ids;</span><br><span class="line">ids = <span class="keyword">new</span> in[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>数组元素是引用数据类型则默认值是null；</p><p>arrays工具类的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(int[] a, int[] b);  //判断两个数组是否相等</span><br><span class="line">String toString(int[] a);  //输出数组信息</span><br><span class="line">void fill(int[] a, int val);  //指定值填充到数组中</span><br><span class="line">void sort(int[] a);  //排序</span><br><span class="line">int binarySearch(int[] a, int key);  //对排序后的数组进行二分法检索指定的值</span><br></pre></td></tr></table></figure><p>数组如果没有赋值会报空指针错误，null；</p><h4 id="新建变量的存储位置">新建变量的存储位置</h4><p>栈中：存放局部变量；堆中：new出来的对象和数组； string：常量池中；static类型的变量：保存在静态域中；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] arr2 = new String[3][2];</span><br><span class="line">String[][] arr3 = new String[3][];</span><br></pre></td></tr></table></figure><h2 id="java面向对象">Java面向对象</h2><p>Java类及类的成员包含的“内容”：属性，方法，构造器； 其中有些特殊的成员：代码块，内部类 面向对象的三大特性：封装，继承，多态。有些人还命名的其他特性如抽象性。</p><h4 id="类和对象">类和对象</h4><p>类的成员：属性（成员变量），行为（方法函数）。</p><p>属性直接定义在类的{}里，局部变量在方法等的内部； 局部变量不能加修饰符（除了final）。非static属性是类的每个对象都有一套。</p><p><del>小tips：alt+左箭头可以快速到函数定义位置或返回</del></p><p>如果要使用对象的方法，哪怕是在对象内部使用也要new一个对象；</p><p>四舍五入取整：Math.round(double d)；非对象语言和Java交互的时候依然表现为对象；</p><p>引用数据类型在使用的时候其变量名都是代表地址值；</p><p>匿名对象的使用（每次都重新创建一个对象）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new phone().sendEmail();</span><br><span class="line">mall.show(mew phone()); </span><br></pre></td></tr></table></figure><p>函数的值传递机制： 参数是基本数据类型，实参赋给形参的是他储存的真实数据值； 参数是引用数据类型，形参得到的是变量所保存的数据的地址值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(char[] x); //直接输出了char数组</span><br></pre></td></tr></table></figure><h4 id="重载">重载</h4><p>重载两同一不同：同一个类，相同方法名；参数列表不同：参数个数或者类型不同； 返回值相同或者不同都可以构成重载；</p><p>可变个数形参的方法：public void show(String ... strs)；即“数据类型 ... 数据名”的形式；参数数量可以是0个。</p><p>需要注意可变个数形参的方法与把数组作为参数的方法不构成重载； 可变个数形参必须放在最后；重载的函数中最多声明一个可变个数形参；</p><h4 id="类的封装和隐藏">类的封装和隐藏</h4><p>把类的属性声明成private，则类外不能直接调用属性；只能通过方法如setlegs，getlegs. 封装性的体现需要权限修饰符来配合：private，缺省，protected，public（从小到大）。 属性体现封装性，类也可以体现封装性；</p><table><thead><tr class="header"><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr class="odd"><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr class="even"><td>default</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr class="odd"><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr class="even"><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>有四种权限修饰符可以修饰类和类的内部结构。class的权限只可以用public和default； 不同的包可以定义重名类。</p><p>构造器：功能是创建对象，实际使用中和类同名。不显式定义则默认提供一个空参的构造器。构造器严格来说不是方法，可以重载。</p><p>属性赋值的先后顺序：默认，显式初始化，构造器中赋值，调用属性进行赋值。</p><p>Javabean：特殊的java类。类是公共的，有一个无参的公共的构造器，有属性，有对应的get，set方法；可重用组件。</p><p>默认构造器的权限和其所在的类相同。</p><p>在开发过程中，为了清晰的显示类和类之间的关系，可以使用UML类图。</p><h4 id="this和import的使用">this和import的使用</h4><p>方法内部用，则表示对该方法对象的引用；构造器内部使用，表示构造器正在初始化的对象；</p><p>this表示当前对象，可以修饰方法，属性；</p><p>类的方法中可以使用this.属性或this.方法，构造器中也可以this修饰方法和属性；</p><p>this调用构造器：this(args)，主要是为了减少构造器中的冗余代码；自始至终对象只有一个；this(args)必须声明在当前构造器首行，构造器内部最多只能调用一个其他构造器；</p><p><del>ALT+SHITF+S 调出代码生成器</del></p><p>package：更好的管理类，声明类或者接口属于的包，放在首行；</p><p>MVC设计模式：M模型处理数据，V视图显示数据，C控制处理业务逻辑；</p><p>import：在源文件中使用import导入指定包下的类和接口；声明在包和类的声明之间；import xxx.*导入其下所有内容，但是不包含其中的子包；</p><p>import static：导入类或接口中的静态结构，同时import static的结尾一定是.*</p><p><del>持续更新ing</del></p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO和GitHub建站（一）</title>
      <link href="/b077d8cb.html"/>
      <url>/b077d8cb.html</url>
      
        <content type="html"><![CDATA[<h3 id="环境搭建">环境搭建</h3><p>首先安装node.js，直接官网下载安装。接着安装git for windows，直接官网安装（访问官网及后续安装搞个梯子会方便很多）。安装之后用下述语句查看版本以确认安装成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>新建一个文件夹用于存放博客相关的环境和内容配置，例如"blog"。在该文件夹中右击，选择"Git bash here"。安装HEXO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级，可不进行</span><br><span class="line">hexo init #初始化博客</span><br></pre></td></tr></table></figure><p>HEXO的常用指令如下（这些指令均要在上面创建的blog文件夹路径下运行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章</span><br><span class="line">hexo g == hexo generate # 生成</span><br><span class="line">hexo s == hexo server # 启动服务预览（安装hexo之后直接就可以进行）</span><br><span class="line">hexo d == hexo deploy # 部署到GitHub（需要预先与GitHub进行连接）</span><br><span class="line"># 上面的几条语句，使用的时候输入&quot;==&quot;前面的部分就可以了。</span><br><span class="line"></span><br><span class="line">hexo server # Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s # 静态模式</span><br><span class="line">hexo server -p 5000 # 更改端口</span><br><span class="line">hexo server -i 192.168.1.1 # 自定义 IP</span><br><span class="line">hexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure><p>这样就可以在本地预览网站效果。为了能在其他设备上访问自己的网站，我选择GitHub托管自己的数据。</p><p>具体的操作是在GitHub上建立仓库，然后配置权限让自己可以把blog的内容直接部署到GitHub上。上传成功之后就可以用仓库的名称来访问博客，如我的是"shymuel.github.io"。但github的后缀容易被墙，我的解决方法是自己购买一个域名。国内域名需要实名审核但比较保险，大家可以自行选择合适的域名商。</p><h3 id="volantis主题使用">Volantis主题使用</h3><p>HEXO使用量最大的主题大概就是<a href="http://theme-next.iissnan.com/getting-started.html">NexT</a>了，它的功能十分强大，看起来也比较简洁。</p><p>我为了看起来更加的二次元而选择了<a href="https://volantis.js.org/v5/getting-started/">Volantis</a>主题，主要是为了使用它的定时换背景功能（因为我有太多壁纸想放上去了）。图片目前我还是放在本地，采用相对路径。后面抽空研究一下如何使用CDN实现图片读取。</p><p>Volantis自带文章目录功能，可根据md文件中的标题在网页一侧生成目录。</p><p>配置背景图、头像之类的需要在blog文件夹下新建名为"_config.volantis.yml"的文件进行配置。建议按照<a href="https://volantis.js.org/v5/theme-settings/">主题文档</a>进行。</p><p>对于字数统计和阅读时长显示，先要安装wordcount插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount </span><br></pre></td></tr></table></figure><p>之后可以通过主题配置文件里的 word_count 关键字来选择是否开启此功能，默认false。在配置文件的enable后面加上true。</p><h3 id="twikoo评论插件">Twikoo评论插件</h3><p>根据<a href="https://twikoo.js.org/quick-start.html">官方文档</a>进行配置。我选择的是Vercel部署方式。原开发者做了非常非常详细的<a href="https://www.bilibili.com/video/BV1Fh411e7ZH">视频教程</a>。我把_config.volantis.yml中关于评论的设置改成了如下的样子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">twikoo:</span><br><span class="line">    js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本</span><br><span class="line">    path: # 全局评论地址</span><br><span class="line">    # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项</span><br><span class="line">    envId: https://twikoo-dusky.vercel.app/ # vercel id</span><br><span class="line">    appId: # your appId</span><br><span class="line">    appKey: # your appKey</span><br><span class="line">    meta: [nick,mail,link] # valine comment header info</span><br><span class="line">    requiredFields: [nick,mail]</span><br><span class="line">    enableQQ: true # Unstable avatar link</span><br><span class="line">    recordIP: false # Record commenter IP</span><br><span class="line">    avatar: img/avatar.jpg # gravatar style https://valine.js.org/avatar</span><br><span class="line">    pageSize: 10 # comment list page size</span><br><span class="line">    lang: zh-cn</span><br><span class="line">    highlight: true</span><br><span class="line">    mathJax: false</span><br><span class="line"></span><br></pre></td></tr></table></figure> 部署之后还可以根据自己的需求，下载密钥设置管理员密码来对评论系统进行管理和定制。</p><h3 id="暗黑模式">暗黑模式</h3><p>按照_config.volantis.yml中的描述，修改navbar目录，在menu子目录中添加： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- name: 暗黑模式 # 可自定义</span><br><span class="line">      icon: fas fa-moon # 可自定义</span><br><span class="line">      toggle: darkmode</span><br></pre></td></tr></table></figure></p><h3 id="自动生成文章的唯一永久链接">自动生成文章的唯一永久链接</h3><p>使用abbrlink生成。首先下载abbrlink。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>之后修改根目录站点配置文件config.yml，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://自己的网址名/</span><br><span class="line">permalink: :abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc32   #算法： crc16(default) and crc32</span><br></pre></td></tr></table></figure><p>之后hexo三连即可。</p><h3 id="插入latex公式">插入LateX公式</h3><p>更换渲染工具为 hexo-renderer-pandoc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装 hexo-math 插件以支持 latex 公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>volantis主题的话，在_config.volantis.yml中把mathjax后面改成true即可。注意要clean之后重新生成，latax公式才能正常显示。</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 个人网站 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/b585e161.html"/>
      <url>/b585e161.html</url>
      
        <content type="html"><![CDATA[<p>最后还是回来写代码了……感觉传统工科的老师都在搞机器学习，那我也没有办法，只能重新回来刷题。</p><p>这个博客上的内容可能会写的支离破碎一些，毕竟现在都在做各种项目，也不可能把全部的代码放上来，大概只是记录一下自己能做到什么功能吧，核心代码也会放一些。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
