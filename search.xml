<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Python】面向对象</title>
      <link href="/3267076484.html"/>
      <url>/3267076484.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象相关概念">0 面向对象相关概念</h1><ul><li><strong>面向对象(Object Oriented)</strong>：软件开发方法，一种编程范式。</li><li><strong>类(Class)</strong>：具有相同的属性和方法的对象的集合，它的定义中包含该集合中每个<strong>对象</strong>所共有的属性和方法。对象是指类的实例。</li><li><strong>类变量</strong>：类变量定义在类中且在函数体之外，通常不作为<strong>实例变量</strong>使用。该变量的值由该类的所有对象共享。</li><li><strong>数据成员</strong>：类变量或者实例变量，用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写</strong>：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的<strong>覆盖(override)</strong>，也称为方法的<strong>重写</strong>。</li><li><strong>局部变量</strong>：定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量</strong>：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</li><li><strong>继承</strong>：即一个派生类(derived class)继承基类(base class)的变量和方法，Python也允许把一个派生类的对象作为一个基类对象对待。</li><li><strong>实例化</strong>：创建一个类的实例，即创建类的一个具体对象。</li><li><strong>方法</strong>：类中定义的函数。</li><li><strong>对象</strong>：通过类定义的数据结构实例。对象包括数据成员（类变量和实例变量）和方法。</li></ul><h1 id="类的基础">1 类的基础</h1><h2 id="定义类">1.1 定义类</h2><p>Python中使用<code>class</code>语句来定义一个新类，<code>class</code>之后为类的名称并以冒号结尾:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>   <span class="comment"># 类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment"># 类体</span></span><br></pre></td></tr></table></figure><p>类的帮助信息可以通过<code>ClassName.__doc__</code>查看，<code>class_suite</code>由类成员，方法，数据属性组成。</p><p>一个简单的Python类的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, salary</span>):</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary)</span><br></pre></td></tr></table></figure><ul><li><code>empCount</code>是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类中使用<code>Employee.empCount</code>访问。</li><li>第一种方法<code>__init__()</code>方法是一种特殊的方法，被称为类的<strong>构造函数</strong>或<strong>初始化方法</strong>，每次创建该类的一个实例时就会调用该方法。</li><li>方法中的变量<code>self</code>代表类的实例，<code>self</code>在定义类的方法时是必须有的，但是在调用时不必传入相应的参数。</li></ul><p><code>self</code>详解：<code>self</code>代表类的实例而非类。类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>，按照惯例它的名称是<code>self</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test object at 0x0000013CE6C87610&gt;</span><br><span class="line">&lt;class &#x27;__main__.Test&#x27;&gt;</span><br></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，<code>self</code>代表的是类的实例，代表当前对象的地址，而<code>self.__class__</code>则指向类。<code>self</code>不是Python的关键字，把它换成其他名称也是可以正常执行的。<code>__main__.Test</code>是类的全名。</p><h2 id="类的实例对象">1.2 类的实例对象</h2><p>其他编程语言中一般用关键字<code>new</code>实例化一个对象，但是Python中并没有这个关键字，类的实例化类似函数调用方式。</p><p>以下使用类的名称<code>Employee</code>来实例化，并通过<code>__init__</code>方法接收参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;创建 Employee 类的第一个对象&quot;&quot;&quot;</span></span><br><span class="line">emp1 = Employee(<span class="string">&quot;Zara&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;创建 Employee 类的第二个对象&quot;&quot;&quot;</span></span><br><span class="line">emp2 = Employee(<span class="string">&quot;Manni&quot;</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h3 id="访问类的属性">1.2.1 访问类的属性</h3><p>使用点号"."来访问对象的属性（变量或方法）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.displayEmployee()</span><br><span class="line">emp2.displayEmployee()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br></pre></td></tr></table></figure><p>完整实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, salary</span>):</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary)</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;创建 Employee 类的第一个对象&quot;</span></span><br><span class="line">emp1 = Employee(<span class="string">&quot;Zara&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">&quot;创建 Employee 类的第二个对象&quot;</span></span><br><span class="line">emp2 = Employee(<span class="string">&quot;Manni&quot;</span>, <span class="number">5000</span>)</span><br><span class="line">emp1.displayEmployee()</span><br><span class="line">emp2.displayEmployee()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name :  Zara , Salary:  2000</span><br><span class="line">Name :  Manni , Salary:  5000</span><br><span class="line">Total Employee 2</span><br></pre></td></tr></table></figure><p>添加，删除，修改类的属性，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.age = <span class="number">7</span>  <span class="comment"># 添加一个 &#x27;age&#x27; 属性</span></span><br><span class="line">emp1.age = <span class="number">8</span>  <span class="comment"># 修改 &#x27;age&#x27; 属性</span></span><br><span class="line"><span class="keyword">del</span> emp1.age  <span class="comment"># 删除 &#x27;age&#x27; 属性</span></span><br></pre></td></tr></table></figure><p>Python有个非常有趣的特性，即支持<strong>给已创建的对象增加属性</strong>！这在Java中是做不到的，C++大概也不能。</p><p>从面向对象的角度来说，不推荐直接用"."来访问属性，推荐使用<code>set()</code>和<code>get()</code>方法来进行属性值的设定和获取，这两类方法称为setter、getter方法。Python提供了以下函数来访问属性：</p><ul><li><code>getattr(obj, name[, default])</code>：访问对象的属性；</li><li><code>hasattr(obj,name)</code>：检查是否存在一个属性；</li><li><code>setattr(obj,name,value)</code>：设置一个属性。如果属性不存在，会创建一个新属性；</li><li><code>delattr(obj, name)</code>：删除属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 返回 &#x27;age&#x27; 属性的值</span></span><br><span class="line"><span class="built_in">hasattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 如果存在 &#x27;age&#x27; 属性返回 True。</span></span><br><span class="line"><span class="built_in">setattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>, <span class="number">8</span>) <span class="comment"># 添加属性 &#x27;age&#x27; 值为 8</span></span><br><span class="line"><span class="built_in">delattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 删除属性 &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="python内置类属性">1.2.2 Python内置类属性</h3><ul><li><code>__dict__</code>：类的属性，是一个由类的数据属性组成的字典；</li><li><code>__doc__</code>：类的文档字符串；</li><li><code>__name__</code>：类名；</li><li><code>__module__</code>：类定义所在的模块，类的全名是<code>__main__.className</code>，如果类位于一个导入模块mymod中，那么<code>className.__module__</code>等于mymod；</li><li><code>__bases__</code>：类的所有父类，是一个由所有父类组成的元组。</li></ul><p>Python内置类属性调用实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, salary</span>):</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__doc__:&quot;</span>, Employee.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__name__:&quot;</span>, Employee.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__module__:&quot;</span>, Employee.__module__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__bases__:&quot;</span>, Employee.__bases__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Employee.__dict__:&quot;</span>, Employee.__dict__)</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Employee.__doc__: 所有员工的基类</span><br><span class="line">Employee.__name__: Employee</span><br><span class="line">Employee.__module__: __main__</span><br><span class="line">Employee.__bases__: (&lt;class &#x27;object&#x27;&gt;,)</span><br><span class="line">Employee.__dict__: &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: &#x27;所有员工的基类&#x27;, &#x27;empCount&#x27;: 0, &#x27;__init__&#x27;: &lt;function Employee.__init__ at 0x00000250D7A3C1F0&gt;, &#x27;displayCount&#x27;: &lt;function Employee.displayCount at 0x00000250D7A3C160&gt;, &#x27;displayEmployee&#x27;: &lt;function Employee.displayEmployee at 0x00000250D7A3C280&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Employee&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Employee&#x27; objects&gt;&#125;</span><br></pre></td></tr></table></figure><h3 id="python对象销毁垃圾回收">1.2.3 Python对象销毁（垃圾回收）</h3><p>Python使用了<strong>引用计数</strong>这一简单技术来跟踪和回收垃圾。</p><p>在Python内部用内部跟踪变量记录着所有使用中的对象各有多少引用，称为<strong>引用计数器</strong>。</p><p>对象被创建时就创建了一个引用计数。当不再需要某对象，即该对象的引用计数变为0时它被垃圾回收。但是回收不是“立即”的，由解释器在适当的时机将垃圾对象占用的内存空间回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">40</span>      <span class="comment"># 创建对象  &lt;40&gt;</span></span><br><span class="line">b = a       <span class="comment"># 增加引用， &lt;40&gt; 的计数</span></span><br><span class="line">c = [b]     <span class="comment"># 增加引用.  &lt;40&gt; 的计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a       <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">b = <span class="number">100</span>     <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">c[<span class="number">0</span>] = -<span class="number">1</span>   <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br></pre></td></tr></table></figure><p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理<strong>循环引用</strong>的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下仅使用引用计数是不够的。Python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充，垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。在这种情况下解释器会暂停下来，试图清理所有未被引用的循环。</p><p>为了研究垃圾回收机制，使用析构函数<code>__del__</code>。<code>__del__</code>在对象销毁的时候被调用，当对象不再被使用时，<code>__del__</code>方法运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"> self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">      self.x = x</span><br><span class="line">      self.y = y</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">      class_name = self.__class__.__name__</span><br><span class="line">      <span class="built_in">print</span>(class_name, <span class="string">&quot;销毁&quot;</span>)</span><br><span class="line"> </span><br><span class="line">pt1 = Point()</span><br><span class="line">pt2 = pt1</span><br><span class="line">pt3 = pt1</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(pt1), <span class="built_in">id</span>(pt2), <span class="built_in">id</span>(pt3)) <span class="comment"># 打印对象的id</span></span><br><span class="line"><span class="keyword">del</span> pt1</span><br><span class="line"><span class="keyword">del</span> pt2</span><br><span class="line"><span class="keyword">del</span> pt3</span><br></pre></td></tr></table></figure><p>以上实例运行结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2012588891008 2012588891008 2012588891008</span><br><span class="line">Point 销毁</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：通常需要在单独的文件中定义一个类，</p><h2 id="类的继承">1.3 类的继承</h2><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。</p><p>通过继承创建的新类称为<strong>子类</strong>或<strong>派生类</strong>，被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。</p><p>继承语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名(<span class="params">基类名</span>)</span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure><p>在Python中继承的一些特点：</p><ol type="1"><li>如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： <a href="https://www.runoob.com/w3cnote/python-extends-init.html">python 子类继承父类构造函数说明</a>。</li><li>在调用基类的方法时，需要加上基类的类名前缀，且需要带上<code>self</code>参数变量。区别在于类中调用普通函数时<strong>并不需要</strong>带上<code>self</code>参数</li><li>Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。即先在本类中查找调用的方法，找不到才去基类中找。</li></ol><p>如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" ，继承的积累在括号中列出：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class SubClassName(ParentClass1, ParentClass2, ...):</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>派生类的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   parentAttr = <span class="number">100</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;调用父类构造函数&quot;</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">parentMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">setAttr</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">      Parent.parentAttr = attr</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">getAttr</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;父类属性 :&quot;</span>, Parent.parentAttr)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;调用子类构造方法&quot;</span>)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">childMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 实例化子类</span></span><br><span class="line">c.childMethod()      <span class="comment"># 调用子类的方法</span></span><br><span class="line">c.parentMethod()     <span class="comment"># 调用父类方法</span></span><br><span class="line">c.setAttr(<span class="number">200</span>)       <span class="comment"># 再次调用父类的方法 - 设置属性值</span></span><br><span class="line">c.getAttr()          <span class="comment"># 再次调用父类的方法 - 获取属性值</span></span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用子类构造方法</span><br><span class="line">调用子类方法</span><br><span class="line">调用父类方法</span><br><span class="line">父类属性 : 200</span><br></pre></td></tr></table></figure><p>继承多个类的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>        <span class="comment"># 定义类 A</span></span><br><span class="line">.....</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>         <span class="comment"># 定义类 B</span></span><br><span class="line">.....</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span>   <span class="comment"># 继承类 A 和 B</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>判断某个类是不是子类可以使用<code>issubclass()</code>或者<code>isinstance()</code>方法：</p><ul><li><code>issubclass(Class1, Class2)</code>：布尔函数，<code>Class1</code>是<code>Class2</code>的子类或者子孙类则返回true。</li><li><code>isinstance(obj, Class)</code>：布尔函数，如果<code>obj</code>是<code>Class</code>类的实例对象或者是<code>Class</code>子类的一个实例对象则返回true。</li></ul><h1 id="类方法的重写">2 类方法的重写</h1><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写（又叫重载）你父类的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用父类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用子类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br></pre></td></tr></table></figure><p>执行以上代码输出结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用子类方法</span><br></pre></td></tr></table></figure><h2 id="基础重载方法">2.1 基础重载方法</h2><table><thead><tr class="header"><th>序号</th><th>方法, 描述 &amp; 简单的调用</th></tr></thead><tbody><tr class="odd"><td>1</td><td><code>__init__(self, args...)</code>：构造函数。<br>简单的调用方法：<code>obj = className(args)</code></td></tr><tr class="even"><td>2</td><td><code>__del__(self)</code>：析构方法, 删除一个对象。<br>简单的调用方法：<code>del obj</code></td></tr><tr class="odd"><td>3</td><td><code>__repr__(self)</code>：转化为供解释器读取的形式。<br>简单的调用方法：<code>repr(obj)</code></td></tr><tr class="even"><td>4</td><td><code>__str__(self)</code>：用于将值转化为适于人阅读的形式。<br>简单的调用方法：<code>str(obj)</code></td></tr><tr class="odd"><td>5</td><td><code>__cmp__ ( self, x )</code>：对象比较。<br>简单的调用方法：<code>cmp(obj, x)</code></td></tr></tbody></table><h2 id="运算符重载">2.2 运算符重载</h2><p>Python同样支持运算符重载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span>  <span class="comment"># __str__在print被调用，目的是输出类的内容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>, -<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line"><span class="built_in">print</span>(v1 + v2)</span><br><span class="line"><span class="built_in">print</span>(v1.__str__())</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下所示:</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector (2, 10)</span><br><span class="line">Vector (7, 8)</span><br><span class="line">Vector (2, 10)</span><br></pre></td></tr></table></figure><h1 id="类的属性与方法">3 类的属性与方法</h1><h2 id="类的私有属性">3.1 类的私有属性</h2><p><code>__private_attrs</code>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时写作<code>self.__private_attrs</code>。</p><h2 id="类的方法">3.2 类的方法</h2><p>在类的内部，使用<code>def</code>关键字可以为类定义一个方法。与一般函数定义不同，类方法必须包含参数<code>self</code>作为第一个参数。</p><h2 id="类的私有方法">3.3 类的私有方法</h2><p><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用时写作<code>self.__private_methods</code>。</p><p>私有属性的实例（私有方法类似）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(self.__secretCount)</span><br><span class="line"> </span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="built_in">print</span>(counter.publicCount)</span><br><span class="line"><span class="built_in">print</span>(counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure><p>Python 通过改变名称来包含类名:</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\jh108\PycharmProjects\PythonLearningCodes\OOP.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    print(counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: &#x27;JustCounter&#x27; object has no attribute &#x27;__secretCount&#x27;</span><br></pre></td></tr></table></figure><p>Python不允许实例化的类访问私有数据，但你可以使用<code>object._className__attrName</code>（对象名._类名__私有属性名）访问属性，参考以下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span>:</span></span><br><span class="line">    __site = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">runoob = Runoob()</span><br><span class="line"><span class="built_in">print</span>(runoob._Runoob__site)</span><br></pre></td></tr></table></figure><p>执行以上代码，执行结果如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure><h2 id="单下划线双下划线头尾双下划线说明">3.4 单下划线、双下划线、头尾双下划线说明</h2><ul><li><code>__foo__</code>: 两边都有双下划线的是特殊方法，一般是系统定义名字，类似<code>__init__()</code>之类的。</li><li><code>_foo</code>: 以单下划线开头的是<code>protected</code>类型的变量，即保护类型。只能允许其本身与子类进行访问，不能用于<code>from module import *</code>。</li><li><code>__foo</code>: 双下划线的表示的是私有类型(private)的变量，只能允许这个类本身进行访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《うっせぇわ》歌词（中日语+假名对照版）</title>
      <link href="/899839865.html"/>
      <url>/899839865.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。</p></blockquote><p>ただしさとは、おろかさとは<br />正　しさとは、愚　かさとは<br />什么叫正确？什么叫愚蠢？</p><p>それがなにかみせつけてやる<br />それが何　か見せつけてやる<br />现在就让你们见识一下吧！</p><p>ちっちゃなころからゆうとうせい<br />ちっちゃな頃　から優　等　生<br />从小便是优等生</p><p>きづいたらおとなになっていた<br />気づいたら大　人になっていた<br />回过神来便已成为了大人</p><p>ナイフのようなしこうかいろ<br />ナイフの様　な思考　回　路<br />充满了刀锋般的思考方式</p><p>もちあわせるわけもなく<br />持ち合わせる訳　もなく<br />但也没必要和你一起比较吧</p><p>でもあそびたりない、なにかたりない<br />でも遊　び足りない、何　か足りない<br />但是玩不够啊，还不够快乐啊</p><p>こまっちまうこれはだれかのせい<br />困　っちまうこれは誰　かのせい<br />左右为难又是谁的错啊</p><p>あてもなくただこんらんするエイデイ<br />あてもなくただ混　乱　するエイデイ<br />也不过只是没有目的的日程渐渐变得混乱</p><p>それもそっか<br />那也是当然嘛</p><p>さいしんのりゅうこうはとうぜのはあく<br />最　新　の流　　行　は当　然　の把握<br />最流行的东西，第一时间掌握</p><p>きゅうざいのどうこうはつうきんじチェック<br />経　　済　の動　向　は通　勤　時チェック<br />经济的流向上班前查看</p><p>じゅんじょうなせいしんでにゅうしゃしワーク<br />純　　情　　な精　神　で入　　社　しワーク<br />抱有热情的进公司工作</p><p>しゃかいじんじゃとうぜんのルールです<br />社　会　人　じゃ当　然　のルールです<br />这可是社会人的规则啊</p><p>はぁ？うっせぇうっせぇうっせぇわ<br />哈？啰嗦！烦人！吵死了！</p><p>あなたがおもうよりけんこうです<br />あなたが思　うより健　康　です<br />我可比你想的要健康得多</p><p>いっさいがっさいぼんような<br />一　切　合　切　凡　庸　な<br />一切一切都平凡的你</p><p>あなたじゃわからないかもね<br />あなたじゃ分からないかもね<br />你可能不明白吧</p><p>ああよくにあう<br />嗚呼よく似合う<br />啊，和你可真是般配啊</p><p>そのかもなくふかもないメロディー<br />その可もなく不可もないメロディー<br />这没有存在必要的旋律</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>あたまのできがちがうのでもんだいはナシ<br />頭　　の出来が違　うので問　題　はナシ<br />我们头脑构造不一样，所以没什么问题！</p><p>つってもわたしもはんにんげん<br />つっても私　　模範　人　間<br />就算这样我也可是人之模范啊</p><p>なぐったりするのはノーセンキュー<br />殴　ったりするのはノーセンキュー<br />教训你一顿这种事也是不用谢我</p><p>だったらことばのじゅうこうを<br />だったら言　葉の銃　　口　を<br />既然这样就将枪口（话语）</p><p>そのあたまにつきつけてうてば<br />その頭　　に突きつけて撃てば<br />对准脑门一通扫射吧！</p><p>マジヤバない？とまれやしない<br />マジヤバない？止まれやしない<br />这样下去很糟糕吧？不试试放弃吗？</p><p>ふへいふまんだれてなれのはて<br />不平　不満　誰　て成れの果て<br />怨天尤人可不会有好下场的</p><p>サディスティックにへんぼうするせいしん<br />サディスティックに変　貌　する精　神<br />变得施虐者一般的思想</p><p>クソだりぃな<br />真是渣滓</p><p>さけがあいたグラスあればすぐにつぎなさい<br />酒　が空いたグラスあれば直ぐに注ぎなさい<br />酒杯空了就立马装满</p><p>みんながつまみやすいようにくしがいしなさい<br />皆　　がつまみ易い　ように串　外　しなさい<br />为了大家吃东西更方便给我把菜从串上取下来</p><p>かいけいやちゅうもんはせんじんをきる<br />会　計　や注　　文　は先　陣　を切る<br />结账和点菜搞快点</p><p>ふぶんりつさいていげんのマナーです<br />不文　律　最　低　限　のマナーです<br />这是最低限度的不成文规定吧</p><p>はぁ？うっせぇうっせぇうっせぇわ<br />哈？啰嗦！烦人！吵死了！</p><p>くせぇくちふさげやげんかいです<br />くせぇ口　塞　げや限　界　です<br />也该闭上你这张臭嘴了吧我受够了</p><p>ぜったいぜったいげんだいのだいべんしゃはわたしやろがい<br />絶　対　絶　対　現　代　の代　弁　者　は私　　やろがい<br />现代人的榜样绝对就是我了吧</p><p>もうみあきたわ<br />もう見飽きたわ<br />已经见多了啊</p><p>にばんせんじいいかえのパロディ<br />二番　煎　じ言い換えのパロディ<br />换汤不换药只是换了个说法的模仿</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！吵死了！烦死了</p><p>まるまるとにくついたそのがんめんにバツ<br />丸　々　と肉　付いたその顔　面　にバツ<br />恨不得赏你这肥猪一拳</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>わたしがぞくにいうてんさいです<br />私　　が俗　に言う天　才　です<br />我可是你们所说的天才！</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>あなたがおもうよりけんこうです<br />あなたが思　うより健　康　です<br />我可比你想的要健康得多！</p><p>いっさいがっさいぼんような<br />一　切　合　切　凡　庸　な<br />一切一切都平凡的你</p><p>あなたじゃわからないかもね<br />あなたじゃ分からないかもね<br />可能不明白吧</p><p>ああつまらねぇ<br />嗚呼つまらねぇ<br />啊，真无趣啊</p><p>なんかいきかせるんだそのメモリー<br />何　回　聞かせるんだそのメモリー<br />这样的回忆已经听了多少遍啊</p><p>うっせぇうっせぇうっせぇわ<br />啰嗦！烦人！吵死了！</p><p>アタシもたいがい だけど<br />アタシも大　概　だけど<br />我或许也差不多...</p><p>どうだっていいぜもんだいはナシ<br />どうだっていいぜ問　題　はナシ<br />不！怎么都好，我没有问题！</p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 日文歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex语法记录</title>
      <link href="/2021361885.html"/>
      <url>/2021361885.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.overleaf.com/learn/latex/Creating_a_document_in_LaTeX">Overleaf的LaTex教程</a></p><p><a href="https://latex.codecogs.com/eqneditor/editor.php">包含基本上所有Latex小语法的网站</a></p><p><a href="https://www.latexlive.com/">在线Latex公式编辑器（界面比第二个网站更好看）</a></p><h2 id="给字母加奇怪的东西">给字母加奇怪的东西</h2><h3 id="pmb字母加粗">\pmb{}，字母加粗</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\pmb&#123;x&#125;, \ \pmb&#123;X&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\pmb{x}, \ \pmb{X}\)</span></p><h3 id="hat头顶加小尖角">\hat{}，头顶加小尖角</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hat&#123;\gamma&#125;_&#123;j k&#125;=\frac&#123;\alpha_&#123;k&#125; \phi\left(y_&#123;j&#125; \mid \theta_&#123;k&#125;\right)&#125;&#123;\sum_&#123;k=1&#125;^&#123;R&#125; \alpha_&#123;k&#125; \phi\left(y_&#123;j&#125; \mid \theta_&#123;k&#125;\right)&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\hat{\gamma}_{j k}=\frac{\alpha_{k} \phi\left(y_{j} \mid \theta_{k}\right)}{\sum_{k=1}^{R} \alpha_{k} \phi\left(y_{j} \mid \theta_{k}\right)}\)</span></p><h2 id="各种括号和方框">各种括号和方框</h2><h3 id="begincases多种情况的表示">\begin{cases}，多种情况的表示</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\gamma_&#123;j k&#125;= \begin&#123;cases&#125;1, &amp; \text &#123; 第 &#125; j \text &#123; 个观测来自第 &#125; k \text &#123; 个分模型 &#125; \\ 0, &amp; \text &#123; 否则 &#125;\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\gamma_{j k}= \begin{cases}1, &amp; \text { 第 } j \text { 个观测来自第 } k \text { 个分模型 } \\ 0, &amp; \text { 否则 }\end{cases}\)</span></p><h3 id="beginarray方程组">\begin{array}，方程组</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left\&#123;\begin&#123;array&#125;&#123;l&#125;\mathrm&#123;e&#125;^&#123;-x_&#123;1&#125;&#125;+\mathrm&#123;e&#125;^&#123;-2 x_&#123;2&#125;&#125;+x_&#123;3&#125;-2 x_&#123;4&#125;+t_&#123;k&#125; x_&#123;5&#125;-5.3=0 \\ \mathrm&#123;e&#125;^&#123;-2 x_&#123;1&#125;&#125;+\mathrm&#123;e&#125;^&#123;-x_&#123;2&#125;&#125;-2 x_&#123;3&#125;+t_&#123;k&#125; x_&#123;4&#125;-x_&#123;5&#125;+25.6=0 \\ t_&#123;k&#125; x_&#123;1&#125;+3 x_&#123;2&#125;+\mathrm&#123;e&#125;^&#123;-x_&#123;3&#125;&#125;-3 x_&#123;5&#125;+37.8=0 \\ 2 x_&#123;1&#125;+t_&#123;k&#125; x_&#123;2&#125;+x_&#123;3&#125;-\mathrm&#123;e&#125;^&#123;-x_&#123;4&#125;&#125;+2 \mathrm&#123;e&#125;^&#123;-2 x_&#123;5&#125;&#125;-31.3=0 \\ x_&#123;1&#125;-2 x_&#123;2&#125;-3 t_&#123;k&#125; x_&#123;3&#125;+\mathrm&#123;e&#125;^&#123;-2 x_&#123;4&#125;&#125;+3 \mathrm&#123;e&#125;^&#123;-x_&#123;5&#125;&#125;+42.1=0\end&#123;array&#125;\right.</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\left\{\begin{array}{l}\mathrm{e}^{-x_{1}}+\mathrm{e}^{-2 x_{2}}+x_{3}-2 x_{4}+t_{k} x_{5}-5.3=0 \\ \mathrm{e}^{-2 x_{1}}+\mathrm{e}^{-x_{2}}-2 x_{3}+t_{k} x_{4}-x_{5}+25.6=0 \\ t_{k} x_{1}+3 x_{2}+\mathrm{e}^{-x_{3}}-3 x_{5}+37.8=0 \\ 2 x_{1}+t_{k} x_{2}+x_{3}-\mathrm{e}^{-x_{4}}+2 \mathrm{e}^{-2 x_{5}}-31.3=0 \\ x_{1}-2 x_{2}-3 t_{k} x_{3}+\mathrm{e}^{-2 x_{4}}+3 \mathrm{e}^{-x_{5}}+42.1=0\end{array}\right.\)</span></p><p>既可以用来表示矩阵，也可以用来表示方程……</p><h2 id="数学表达式">数学表达式</h2><h3 id="根式">根式</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sqrt[]&#123;&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\sqrt[n]{x+1}\)</span></p><h3 id="集合相关">集合相关</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$\exists$</span><br><span class="line">$\forall$</span><br><span class="line">$\neg$</span><br><span class="line">$\wedge$</span><br><span class="line">$\vee$ </span><br></pre></td></tr></table></figure><p><span class="math inline">\(\exists,\ \forall, \ \neg, \ \wedge,\  \vee\)</span></p><h2 id="latex中的数学字体">LaTex中的数学字体</h2><p>有些字体需要在序言中引入特定的包：<code>\usepackage&#123;amssymb&#125;</code></p><p>有些字体支持一部分字符：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">RQSZ \\</span><br><span class="line">\mathcal&#123;RQSZ&#125; \\</span><br><span class="line">\mathfrak&#123;RQSZ&#125; \\</span><br><span class="line">\mathbb&#123;RQSZ&#125;</span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\begin{align*} RQSZ \\ \mathcal{RQSZ} \\ \mathfrak{RQSZ} \\ \mathbb{RQSZ} \end{align*}\)</span></p><p>手写体，哥特黑体，黑板粗体。</p><p>也可以将整个数学表达式的字体更换为另外一种：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">3x^2 \in R \subset Q \\</span><br><span class="line">\mathrm&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathit&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathbf&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathsf&#123;3x^2 \in R \subset Q&#125; \\</span><br><span class="line">\mathtt&#123;3x^2 \in R \subset Q&#125; </span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\begin{align*}3x^2 \in R \subset Q \\ \mathrm{3x^2 \in R \subset Q} \\ \mathit{3x^2 \in R \subset Q} \\ \mathbf{3x^2 \in R \subset Q} \\ \mathsf{3x^2 \in R \subset Q} \\ \mathtt{3x^2 \in R \subset Q} \end{align*}\)</span></p><p><code>\mathnormal&#123;3x^2 \in R \subset Q&#125;</code>理论上这也是一种字体，和默认字体一样的，但是hexo的渲染器会报错，就没有放上去了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文编辑 </tag>
            
            <tag> 学习和工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用软件及网站分享</title>
      <link href="/2675119176.html"/>
      <url>/2675119176.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档编辑">文档编辑</h2><p>WPS，一直开会员，云文档功能yyds。</p><h2 id="笔记软件">笔记软件</h2><p>为知笔记。旧版和X版我都在用，笑死，已经变成为知笔记的形状了，一年60块买不了吃亏买不了上当。我现在写博客都是在为知笔记写完然后导出成Markdown。</p><h2 id="论文阅读">论文阅读</h2><p>单纯看PDF的话WPS也能满足需求，但WPS是不提供文献管理功能的，批注功能也弱了点。今天发现一个叫IvySci的软件，中文名青藤学术，竟然还是个国产软件……well，再用一段时间再来评价，目前用免费版，收费版也不贵，但收费之后的空间确实小了点，看得出小公司没那么有钱……目前最吸引我的功能是软件内用各种引擎查论文，以及一键把论文中的引用文献加入项目。但它现在有个问题是</p><h2 id="论文搜索">论文搜索</h2><p>之前一直用学校的网在SCI上查，最近觉得还是谷歌学术牛牛。但是懒得开科学上网的话，<a href="https://gfsoso.99lb.net/">谷粉学术</a>挺好用的，也可以去用<a href="https://ac.scmor.com/">镜像</a>。</p><h2 id="公式生成">公式生成</h2><p>Mathpix Snipping Tool，截图生成公式，中文也能识别。我自己用的时候哪怕是扫描版的书，基本上也能把公式识别出来。</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
            <tag> 学习和工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习笔记（1） 强化学习概述</title>
      <link href="/4072327491.html"/>
      <url>/4072327491.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章为笔者学习网络上的强化学习教程之后的笔记，在原文和自己理解的基础上重新写作而成，基本可以认为是原文的精简版，后续可能会在阅读其他教材之后在对应章节添加例子等。<a href="https://github.com/datawhalechina/easy-rl">原教程地址</a></p></blockquote><h1 id="强化学习">1.1 强化学习</h1><p>强化学习解决的是一个智能体如何在一个复杂不确定的环境里极大化它能获得的奖励。</p><p>在环境 (environment) 中，智能体 (agent) 进行各种动作( action) 产生某种状态 (state)，据此环境给出奖励 (reward)。这里的奖励是延迟奖励，即行为的进行到奖励的求得之间往往又隔了一些动作。</p><p>强化学习的一些特征：有试错探索 (trial-and-error exploration)，探索环境来获取对环境的理解；从环境中得到延迟的奖励；每个动作在时间上是连续的；agent 的行为会影响之后的数据。</p><p>举一个雅达利 pong 游戏的例子：一块板子往上或者往下，把弹球弹到对面。整个游戏过程是预演 (rollout) 的，即从当前帧可以生成很多局游戏。agent 和环境交互会产生很多观测，每个观测是一个轨迹 (trajectory)。轨迹是当前帧以及他采取的策略，即状态和动作的一个序列：<span class="math inline">\(\tau =(s_0,a_0,s_1,a_1, \dots)\)</span>。</p><p>一场游戏叫做一个回合 (episode) 或者试验 (trial)。</p><p>最近把强化学习和深度学习结合起来，成为深度强化学习。</p><h1 id="序列决策过程">1.2 序列决策过程</h1><p>序列决策 (sequential decision making) 过程可以说是一般的单智能体 RL 的通用过程。</p><p>奖励是由环境给的一个标量的反馈信号 (scalar feedback signal)，这个信号显示了智能体在某一步采取某个策略的表现如何。强化学习训练的目的就是为了最大化智能体可以获得的奖励，智能体行动的目的就是为了极大化它的期望的累积奖励 (expected cumulative reward)。同时要进行近期奖励和远期奖励的一个平衡，最终一般希望获得更多的长期奖励。</p><p>历史是观测、行为、奖励的序列： <span class="math inline">\(H_t =\{O_1, R_1, A_1,\dots, A_{t-1},\dots\}\)</span></p><p>agent 在采取动作的时候依赖于它的历史，可以把整个游戏的状态看成这个历史的函数：<span class="math inline">\(S_t=f(H_t)\)</span>。</p><p>状态<span class="math inline">\(S\)</span>是对世界的完整描述，deep RL 中一般用实值的向量、矩阵或张量来表示状态和观测。</p><p>agent 的状态和环境的状态等价说明环境完全可观测。这种问题称为 MDP 问题。在这个问题中，<span class="math inline">\(O_t=S^e_t=S^a_t\)</span>。</p><p>否则就是部分可观测的。称为 POMDP，即部分可观测马尔科夫决策过程。POMDP 是一个马尔科夫决策过程的泛化，具有马尔科夫性质，但假设智能体无法感知环境的状态<span class="math inline">\(S\)</span>，只知道部分观测值<span class="math inline">\(O\)</span>。</p><p>用一个七元组描述马尔科夫过程：<span class="math inline">\((S, A, T, R, Ω, O, γ)\)</span>。<span class="math inline">\(S\)</span>是状态空间，隐变量；<span class="math inline">\(A\)</span>是动作空间，<span class="math inline">\(T\)</span>是状态转移概率，<span class="math inline">\(R\)</span>是奖励函数；<span class="math inline">\(Ω\)</span>是观测概率，<span class="math inline">\(O\)</span>为观测空间，<span class="math inline">\(\gamma\)</span>为折扣系数。</p><h1 id="动作空间">1.3 动作空间</h1><p>不同环境中可以进行的动作是不同的。在给定环境中，有效动作的集合被称为<strong>动作空间</strong>。<strong>离散动作空间</strong>中动作数量有限；<strong>连续动作空间</strong>中动作种类无限，此时动作是实值的向量。</p><h1 id="强化学习智能体的组成和类型">1.4 强化学习智能体的组成和类型</h1><p>策略函数 (policy function)：用这个函数来选取下一步的动作；</p><p>价值函数 (value function)：对当前状态估价；</p><p>模型 (model)：表示 agent 对这个环境的状态进行的理解，这一点决定训练如何进行。</p><h2 id="策略">1.4.1 策略</h2><p>策略一般有两种：<strong>随机性策略 (stochastic policy) </strong>和<strong>确定性策略 (deterministic policy)</strong>。</p><p>随机性策略中，每个行为的发生是有概率的，要进行采样然后再动作，也就是说概率再小的动作也可能被执行。而确定性策略则只采用最有可能的概率，即<span class="math inline">\(a^*=\arg \max_a \pi(a\mid s)\)</span>。随机性策略：输入一个状态s，输出是一个概率。进一步对概率进行采样，可以得到一个action。</p><p>对于 Atari 游戏，策略函数的输入就是游戏的一帧，他的输出决定往左或者往右。通常采用随机性策略，因为其动作具有多样性。</p><h2 id="价值函数">1.4.2 价值函数</h2><p>价值函数是对未来奖励的一个预测，用来评估状态的好坏。</p><p>价值函数里有一个折扣因子 (discount factor)。我们希望在尽可能短的时间里得到尽可能多的奖励。价值函数的定义其实是一个期望：</p><p><span class="math inline">\(v_{\pi}(s) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1} \mid S_{t}=s\right],\ \text{for all}\ s \in \mathcal{S}\)</span></p><p>上面的公式表明已知某一个策略函数的时候，到底可以得到多少奖励。</p><p>还有一种价值函数叫 Q 函数，包含两个变量状态和动作：</p><p><span class="math inline">\(q_{\pi}(s, a) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid S_{t}=s, A_{t}=a\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1} \mid S_{t}=s, A_{t}=a\right]\)</span></p><p>Q 函数表明，奖励的期望取决于当前的状态和智能体的行为。</p><p>这两种价值函数在之后都会有详细解释和应用。</p><h2 id="模型">1.4.3 模型</h2><p>模型决定了下一个状态会是什么样的。它由两个部分组成： 概率，指状态之间如何转移；奖励函数，指在当前状态进行了某个行为后可以得到多大的奖励。</p><p>有了上述三个部分之后就得到了一个<strong>马尔科夫决策过程</strong>。</p><h2 id="强化学习智能体的类型">1.4.4 强化学习智能体的类型</h2><h3 id="基于价值的智能体与基于策略的智能体">1.4.4.1 基于价值的智能体与基于策略的智能体</h3><p>基于价值的智能体 (value-based agent)：显式学习价值函数，隐式学习策略。</p><p>基于策略的智能体 (policy-based agent)：直接学习策略，没有学习价值函数。</p><p>二者结合得到演员-评论员智能体 (actor-critic agent)，策略函数和价值函数都学习，然后通过两者交互得到一个最佳行为。</p><p>基于策略迭代和基于价值迭代的强化学习方法有什么区别？ 对一个状态转移概率已知的马尔科夫决策过程，可以用动态规划算法求解。决策方式来看，可以分为<strong>基于策略迭代的方法</strong>和<strong>基于价值迭代的方法</strong>。决策方式是静态的，不随状态变化而变化。</p><p>基于策略迭代的强化学习中，智能体会制定一套动作策略以确定给定状态下采取何种动作，并根据这个策略操作。有策略梯度算法等。基于价值迭代的方法则维护一个价值表格或函数。只能应用在不连续、离散的环境下。基于价值迭代的有 Q-learning，Sarsa等。演员-评论员算法同时使用策略和价值评估来做出决策，智能体根据策略做出动作，而价值函数会对做出的动作给出价值，这样可以在原有的策略梯度算法的基础上加速学习过程，取得更好的效果。</p><h3 id="有模型强化学习智能体与免模型强化学习智能体">1.4.4.2 有模型强化学习智能体与免模型强化学习智能体</h3><p>针对<strong>是否需要对真实环境建模</strong>，强化学习可以分为有模型学习和免模型学习。有模型学习是指根据环境中的经验，构建一个虚拟世界，同时在真实环境和虚拟世界中学习；免模型学习是指不对环境进行建模，直接与真实环境进行交互来学习到最优策略。</p><p>有模型 (model-based) 强化学习智能体通过学习状态的转移来采取动作。免模型 (model-free) 强化学习智能体没有直接估计这个状态的转移，也没有得到环境的具体转移变量，通过学习价值函数和策略函数进行决策。免模型的模型里面没有一个环境转移的模型。</p><p>免模型学习通常属于数据驱动型方法，需要大量的采样来估计状态、动作及奖励函数，从而优化动作策略。</p><h1 id="学习与规划">1.5 学习与规划</h1><p>学习 (learning) 和规划 (planning) 是序列决策的两个基本问题。</p><p>简单来说，强化学习面对环境的未知部分要进行学习，对于环境的已知部分要进行规划。</p><h1 id="探索和利用">1.6 探索和利用</h1><p>探索是指怎么探索环境，即找到能获得最大奖励的策略。利用是指不尝试新的东西，仅靠已知的信息就可以得到很大奖励的行为。</p><p>与监督学习不同，强化学习任务的最终奖赏是在多步动作之后才能观察到，这里不妨先考虑比较简单的情形：最大化单步奖赏，即<strong>仅考虑一步操作</strong>。需注意的是，即便在这样的简化情形下，<strong>强化学习仍与监督学习有显著不同</strong>，因为机器需通过尝试来发现各个动作产生的结果，而没有训练数据告诉机器应当做哪个动作。</p><p>单步强化学习对应了 K-臂赌博机 (K-armed bandit) 的模型。赌徒投入一个硬币后可选择按下一个摇臂，每个摇臂以一定的概率吐出金币，但这个概率赌徒不知道。赌徒的目标是通过一定的策略最大化自己的奖赏。 若想获知每个摇臂的期望奖赏，则可采用仅探索法，将所有机会平均分配给每个摇臂，然后计算期望。 如果只想执行奖赏最大的动作，则可采用仅利用法，按下目前最优的摇臂。若有多个最优则随机选一个。 显然，在探索和利用之间，必须要达成一个较好的折中。</p><h1 id="强化学习实验">1.7 强化学习实验</h1><p><a href="https://github.com/cuhkrlcourse/RLexample">cuhkrlcourse的RL代码</a>；</p><p>OpenAI 的 <a href="https://gym.openai.com/envs/#classic_control">Gym</a> 是一个很强的环境仿真库。离散控制场景（输出的动作是可数的，比如 Pong 游戏中输出的向上或向下动作）一般使用雅达利环境评估；连续控制场景（输出的动作是不可数的，比如机器人走路时不仅有方向，还要角度，角度就是不可数的，是一个连续的量）一般使用 mujoco 环境评估。Gym Retro 是对 Gym 环境的进一步扩展，包含了更多的一些游戏。</p><p>简书上的 <a href="https://www.jianshu.com/p/e7235f8af25e">Gym 环境总结</a>。</p><p><a href="https://gym.openai.com/docs/">Gym 的官方文档</a>。</p><h2 id="第一次使用-gym">1.7.1 第一次使用 Gym</h2><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gym  # 安装 Gym</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;Taxi-v3&quot;</span>)  <span class="comment"># 出租车接乘客的游戏</span></span><br><span class="line">observation = env.reset()</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    action = env.action_space.sample()  <span class="comment"># 随机动作</span></span><br><span class="line">    observation, reward, done, info = env.step(action)</span><br><span class="line">    <span class="built_in">print</span>(observation)</span><br></pre></td></tr></table></figure><h2 id="cartpole-例子">1.7.2 <a href="https://gym.openai.com/envs/CartPole-v1/">CartPole</a> 例子</h2><p>CartPole 要求通过控制一个平板让木棍立起来。输入是向左或向右的一个力，<span class="math inline">\(\pm1\)</span>。失败条件是木棍角度过大或平板离轨道中心太远。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym  <span class="comment"># 导入 Gym 的 Python 接口环境包</span></span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v0&#x27;</span>)  <span class="comment"># 构建实验环境</span></span><br><span class="line">env.reset()  <span class="comment"># 重置一个 episode</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    env.render()  <span class="comment"># 显示图形界面</span></span><br><span class="line">    action = env.action_space.sample()  <span class="comment"># 从动作空间中随机选取一个动作</span></span><br><span class="line">    env.step(action)  <span class="comment"># 用于提交动作，括号内是具体的动作</span></span><br><span class="line">env.close()  <span class="comment"># 关闭环境</span></span><br></pre></td></tr></table></figure><p>执行这段代码时，机器人会无视该立起来的杆子，驾驶着小车朝某个方向一通跑，直到不见踪影，这是因为动作是随机选取的。打印 env.action_space.sample() 的返回值，会发现值是 0 或 1，一左一右。env.step() 一方面是执行动作，另一方面还有四个返回值，分别是 observation、reward、done、info。</p><p>observation 是状态信息，指游戏中观测到的屏幕像素值或者盘面状态描述信息。reward 是奖励值，即 action 提交以后能够获得的奖励值。这个奖励值因游戏的不同而不同，但总体原则是对完成游戏有帮助的动作会获得比较高的奖励值。done 表示游戏是否已经完成。如果完成了，就需要重置游戏并开始一个新的回合。info 是一些比较原始的用于诊断和调试的信息，或许对训练有帮助。不过 OpenAI 团队在评价用户提交的机器人时不允许使用这些信息。</p><p>玩游戏的时候可以输出一下 observation 观察游戏的状态是怎么定义的。env.step() 完成了一个完整的<span class="math inline">\(S\rightarrow A\rightarrow R\rightarrow S^′\)</span>过程。我们只要不断观测这样的过程，并让机器在其中用相应的算法完成训练，就能得到一个高质量的强化学习模型。</p><p>想要查看当前 Gym 库已经注册了哪些环境，可以使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gym <span class="keyword">import</span> envs</span><br><span class="line">env_specs = envs.registry.<span class="built_in">all</span>()</span><br><span class="line">envs_ids = [env_spec.<span class="built_in">id</span> <span class="keyword">for</span> env_spec <span class="keyword">in</span> env_specs]</span><br><span class="line"><span class="built_in">print</span>(envs_ids)</span><br></pre></td></tr></table></figure><p>每个环境都定义了自己的观测空间和动作空间。环境 env 的观测空间用 env.observation_space 表示，动作空间用 env.action_space 表示。观测空间和动作空间既可以是离散空间，也可以是连续空间。在 Gym 库中，离散空间一般用 gym.spaces.Discrete 类表示，连续空间用 gym.spaces.Box 类表示。</p><h2 id="mountaincar-v0-例子">1.7.3 <a href="https://gym.openai.com/envs/MountainCar-v0/">MountainCar-v0</a> 例子</h2><p><strong>小车上山</strong>例子。小车要跑到右边的山顶上碰到旗子，但小车的马力不够强。唯一的办法是让小车在两个坡上来回移动，借助从左边山上冲下来的速度冲上右边的山顶。</p><h3 id="输出游戏的信息">1.7.3.1 输出游戏的信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">&#x27;MountainCar-v0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;观测空间 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.observation_space))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;动作空间 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.action_space))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;观测范围 = &#123;&#125; ~ &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.observation_space.low,</span><br><span class="line">env.observation_space.high))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;动作数 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(env.action_space.n))</span><br></pre></td></tr></table></figure><p>由输出可知，观测空间是形状为 (2,) 的浮点型 np.array，动作空间是取 0,1,2 的 int 型数值。</p><h3 id="实现一个智能体类">1.7.3.2 实现一个智能体类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BespokeAgent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, env</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decide</span>(<span class="params">self, observation</span>):</span> <span class="comment"># 决策</span></span><br><span class="line">        position, velocity = observation</span><br><span class="line">        lb = <span class="built_in">min</span>(-<span class="number">0.09</span> * (position + <span class="number">0.25</span>) ** <span class="number">2</span> + <span class="number">0.03</span>,</span><br><span class="line">                <span class="number">0.3</span> * (position + <span class="number">0.9</span>) ** <span class="number">4</span> - <span class="number">0.008</span>)</span><br><span class="line">        ub = -<span class="number">0.07</span> * (position + <span class="number">0.38</span>) ** <span class="number">2</span> + <span class="number">0.07</span></span><br><span class="line">        <span class="keyword">if</span> lb &lt; velocity &lt; ub:</span><br><span class="line">            action = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> action <span class="comment"># 返回动作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self, *args</span>):</span> <span class="comment"># 学习</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">agent = BespokeAgent(env)</span><br></pre></td></tr></table></figure><p>智能体的 decide() 方法实现了决策功能，而 learn() 方法实现了学习功能。BespokeAgent 类是一个比较简单的类，它只能根据给定的数学表达式进行决策，不能有效学习，只是用来演示。</p><h3 id="智能体与环境交互">1.7.3.3 智能体与环境交互</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_montecarlo</span>(<span class="params">env, agent, render=<span class="literal">False</span>, train=<span class="literal">False</span></span>):</span></span><br><span class="line">    episode_reward = <span class="number">0.</span> <span class="comment"># 记录回合总奖励，初始化为0</span></span><br><span class="line">    observation = env.reset() <span class="comment"># 重置游戏环境，开始新回合</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 不断循环，直到回合结束</span></span><br><span class="line">        <span class="keyword">if</span> render: <span class="comment"># 判断是否显示</span></span><br><span class="line">            env.render() <span class="comment"># 显示图形界面，图形界面可以用 env.close() 语句关闭</span></span><br><span class="line">        action = agent.decide(observation)</span><br><span class="line">        next_observation, reward, done, _ = env.step(action) <span class="comment"># 执行动作</span></span><br><span class="line"></span><br><span class="line">        episode_reward += reward  <span class="comment"># 收集回合奖励</span></span><br><span class="line">        <span class="keyword">if</span> train:  <span class="comment"># 判断是否训练智能体</span></span><br><span class="line">            agent.learn(observation, action, reward, done)  <span class="comment"># 学习</span></span><br><span class="line">        <span class="keyword">if</span> done:  <span class="comment"># 回合结束，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        observation = next_observation</span><br><span class="line">    <span class="keyword">return</span> episode_reward  <span class="comment"># 返回回合总奖励</span></span><br></pre></td></tr></table></figure><p>play_montecarlo 函数可以让智能体和环境交互一个回合。这个函数有 4 个参数。env 是环境类，agent 是智能体类，render 是 bool 类型变量，指示在运行过程中是否要图形化显示。</p><p>如果函数参数 render 为 True，那么在交互过程中会调用 env.render() 以显示图形化界面，而这个界面可以通过调用 env.close() 关闭。train 是 bool 类型的变量，指示在运行过程中是否训练智能体。在训练过程中应当设置为 True 以调用 agent.learn() 函数；在测试过程中应当设置为 False，使得智能体不变。这个函数有一个返回值 episode_reward，是 float 类型的数值，表示智能体与环境交互一个回合的回合总奖励。</p><h3 id="智能体与环境交互并显示">1.7.3.4 智能体与环境交互并显示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env.seed(<span class="number">0</span>) <span class="comment"># 设置随机数种子,只是为了让结果可以精确复现,一般情况下可删去</span></span><br><span class="line">episode_reward = play_montecarlo(env, agent, render=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回合奖励 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(episode_reward))</span><br><span class="line">env.close() <span class="comment"># 此语句可关闭图形界面</span></span><br></pre></td></tr></table></figure><p>为了系统评估智能体的性能，下列代码求出了连续交互 100 回合的平均回合奖励。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">episode_rewards = [play_montecarlo(env, agent) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;平均回合奖励 = &#123;&#125;&#x27;</span>. <span class="built_in">format</span>(np.mean(episode_rewards)))</span><br></pre></td></tr></table></figure><p>小车上山环境有一个参考的回合奖励值 -110，如果连续 100 个回合的平均回合奖励大于 -110，则认为这个任务被解决了。espokeAgent 类对应的策略的平均回合奖励大概就在 -105 左右。</p><p>测试智能体在 Gym 库中某个任务的性能时学术界一般最关心 100 个回合的平均回合奖励，选这个数字完全是习惯使然。对于有些环境会指定一个参考的回合奖励值，当连续 100 个回合的奖励大于指定的值时，就认为这个任务被解决了。但并不是所有的任务都指定了这样的值。</p><p>总结一下 Gym 的用法：使用 <strong>env=gym.make(环境名)</strong> 取出环境，使用 <strong>env.reset()</strong> 初始化环境，使用 <strong>env.step(动作)</strong> 执行一步环境，使用 <strong>env.render()</strong> 显示环境，使用 <strong>env.close()</strong> 关闭环境。</p><h2 id="关键词">1.8 关键词</h2><p>强化学习 (reinforcement learning, RL)：智能体与复杂且不确定的环境进行交互时，尝试使所获得的奖励最大化的计算算法。</p><p>动作 (action)：环境接收到的智能体当前状态的输出。</p><p>状态 (state)：智能体从环境中获取到的状态。</p><p>奖励 (reward)：智能体从环境中获取的反馈信号，这个信号代表智能体在某一步采取某个策略以后是否得到奖励以及奖励的大小。</p><p>探索 (exploration)：在当前的情况下，继续尝试新的动作。智能体有可能会得到更高的奖励，也有可能一无所获。</p><p>规划 (planning)：在当前的情况下，使用已知的可以获得最大奖励的动作。</p><p>深度强化学习 (deep reinforcement learning)：不需要手工设计特征，仅需要输入状态让系统直接输出动作的一个端到端 (end-to-end) 的强化学习方法。通常使用神经网络来拟合价值函数 (value function) 或者策略网络 (policy network)。</p><p>全部可观测 (full observability)、完全可观测 (fully observed) 和部分可观测 (partially observed)：当智能体的状态与环境的状态等价时，称环境是全部可观测的；当智能体能够观察到环境的所有状态时，称环境是完全可观测的。智能体不能观察到环境的所有状态时，称环境是部分可观测的。</p><p>部分可观测马尔可夫决策过程 (partially observable Markov decision process, POMDP)：即马尔可夫决策过程的泛化。部分可观测马尔可夫决策过程依然具有马尔可夫性质，但是其假设智能体无法感知环境的状态，只能知道部分观测值。</p><p>动作空间 (action space)、离散动作空间 (discrete action space)、连续动作空间 (continuous action space)：在给定的环境中，有效动作的集合被称为动作空间，智能体的动作数量是有限的动作空间为离散动作空间，反之，则被称为连续动作空间。</p><p>基于策略的 (policy-based)：智能体会制定一套动作策略，即确定在给定状态下需要采取何种动作，并根据这个策略进行操作。强化学习算法直接对策略进行优化，使制定的策略能够获得最大的奖励。</p><p>基于价值的 (valued-based)：智能体不需要制定显式的策略，它维护一个价值表格或者价值函数，并通过这个价值表格或价值函数来选取价值最大的动作。</p><p>有模型结构 (model-based)：智能体通过学习状态的转移来采取措施。</p><p>免模型结构 (model-free)：智能体没有直接估计状态的转移，也没有得到环境的具体转移变量。它通过学习价值函数 (value function) 或者策略网络 (policy network) 进行决策。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO建站（二）</title>
      <link href="/200109796.html"/>
      <url>/200109796.html</url>
      
        <content type="html"><![CDATA[<h3 id="将网站迁移到新电脑">将网站迁移到新电脑</h3><p>安装nodejs和git for windows，npm中安装hexo：<code>npm install -g hexo-cli</code>。之后把博客文件夹从旧电脑复制过来即可。</p><p>为了上传，还要配置一下新电脑和github仓库之间的联系。这里还是放一个比较好的<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">教程</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 个人网站 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPS使用技巧记录</title>
      <link href="/3253309366.html"/>
      <url>/3253309366.html</url>
      
        <content type="html"><![CDATA[<h3 id="公式中插入超过33的矩阵">公式中插入超过<span class="math inline">\(3*3\)</span>的矩阵</h3><p>​ 恕我直言，WPS最新版这个公式属实邪门。用起来没有更方便，甚至都不能自己手动把界面下拉让用户能看到更多的选项…… ​ 今天遇到的问题是WPS自带的公式功能最大插入<span class="math inline">\(3*3\)</span>矩阵，但我需要用到<span class="math inline">\(1*7\)</span>的矩阵。方法是首先插入一个<span class="math inline">\(1*3\)</span>​​的矩阵，然后选中整个矩阵（不包括括号），然后右键——插入——在此前插入列（或者在此后插入列），这样就可以突破原本的<span class="math inline">\(3*3\)</span>的限制了……</p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏王《Overlap》歌词（中日语+假名对照版）</title>
      <link href="/abac2baf.html"/>
      <url>/abac2baf.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本歌日语歌词和中文翻译来源于网易云音乐，假名为博主听译，仅供个人学习与交流之用。</p></blockquote><p>かくせないほどまばゆいひかり　せいじゃくやぶりこのよによみがえる<br />隠　せないほど眩　　い光　　　静　寂　　破　りこの世に甦　　　る<br />难以隐藏的炫目光芒　　　　　　划破沉寂　　　　在这世上苏醒</p><p>はげしいくゆらぐかわいただいち　いのちをかけてひばなぶすけあう<br />はげしいく揺らぐ渇　いた大　地　命　　をかけて火花　ぶすけ合う<br />与剧烈震荡的干涸大地　　　　　　不惜生命般摩擦出火花</p><p>もういちどだけでいい　きせきおきてよ<br />もう一　度だけでいい　奇跡　起きてよ<br />再一次就好　　　　　　发生奇迹吧</p><p>かこになくしたきおくのページをとりもどすちからを<br />過去になくした記憶　のページを取り戻どすpower を<br />请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして<br />闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして<br />坚信能冲破黑暗的心　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす<br />瞬　　きできない　鋭　　い眼　光　を燃やす<br />眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ<br />光　　と影　の二　つの心　　　クリスタルに映　る未来　へ<br />光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES<br />今　動き　出す　紅　く漲　　るEYES<br />此刻开始行动　　那涨红的双眼</p><hr /><p>たがいのきずをなめあうひびに　おわりをつげて　しずかにたちあがる<br />互　いの傷　を舐め合う日々に　终わりを告　て　静　かに立ち上がる<br />对互相舔舐伤口的时光　　　　　宣告终结　　　　静静站起身来</p><p>ちいさなあかりともしたよるの　きみとかわしたやくそくまもりぬく<br />小　さな明かり灯した　夜　の　君　と交　した約　束　守　り抜く<br />那微灯映照之夜　　　　　　　　与你结下的约定　　　　我会坚守到底</p><p>かすむしんきろうがきみをみせるよ<br />霞　む蜃　気楼　が君　を见せるよ<br />模糊的幻象之中　　看见了你的身影</p><p>すすんださきになにがおきてもまけわしないかくごで<br />進　んだ先　に何　が掟　　も負けわしない覚　悟で<br />无论前路上发生什么　　　　　我都会有绝不认输的觉悟</p><p>きせきはおこるしんじるこころ　むかえにきたしょうりのめがみが<br />奇跡　は起こる信　じる心　　　迎　えに来た勝　　利の女神　が<br />坚信能引发奇迹的心　　　　　　胜利女神将迎接它的到来</p><p>すべてをたおすどんなかべにもひるまない<br />全　てを倒　すどんな壁　にも怯　まない<br />打倒一切敌人　不畏惧任何困难</p><p>まよいつづけるふたつのこころ　いろあせることないせかいへ<br />迷　い続　ける二　つの心　　　色　褪せることない世界　へ<br />仍在迷惘的两颗心　　　　　　　一同前往永不黯淡的世界</p><p>いまかがやくよ　かさなりあったEYES<br />今　輝　　くよ　重　なりあったEYES<br />此刻绽放光芒　　那重合的双眼</p><p>しずむたいようにつきがとけるよ<br />沈　む太　陽　に月　が溶けるよ<br />月亮融化在西沉的落日之中</p><p>かこになくしたきおくのページをとりもどすちからを<br />過去になくした記憶　のページを取り戻どすpower を<br />请给我能夺回过往失去的记忆书页的力量</p><p>やみをつらぬくしんじるこころたましいねむるばしょさがして<br />闇　を贯　ぬく信　じる心　　魂　　　眠る　場所　探がして<br />坚信能冲破黑暗的心　　　　　　　　　寻找灵魂长眠之处</p><p>まばたきできない　するどいがんこうをもやす<br />瞬　　きできない　鋭　　い眼　光　を燃やす<br />眼中燃起让人难以眨眼的锐利光芒</p><p>ひかりとかげのふたつのこころ　くりすたるにうつるみらいへ<br />光　　と影　の二　つの心　　　クリスタルに映　る未来　へ<br />光与暗的两颗心　　　　　　　　一同前往水晶中映照的未来</p><p>いまうごきだす　あかくみなぎるEYES<br />今　動き　出す　紅　く漲　　るEYES<br />此刻开始行动　　那涨红的双眼</p><p>かさなりあうEYES<br />重　なり合うEYES<br />那重合的双眼</p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 日文歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识点总结</title>
      <link href="/79803d5e.html"/>
      <url>/79803d5e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容均来源于网络，如尚硅谷的免费视频课程、菜鸟教程和优质博客等；本文仅供学习交流使用。</p></blockquote><h2 id="初识java">初识Java</h2><p>Java发行版有多个后缀名，通常Java SE 开发桌面级应用；Java EE 开发web应用；Java ME运行在移动端；</p><p>Java的应用：企业级应用；Android平台开发；大数据平台开发；移动领域应用；</p><p>Java的特点： 一：面向对象。类，对象；封装，继承，多态； 二：健壮性；三：跨平台性，通过JVM虚拟机实现；</p><p>两个核心机制：虚拟机和垃圾回收机制；</p><p>JDK：Java开发工具包，其中包含了JRE。其中有编译工具javac.exe和打包工具jar.exe。 JRE：Java运行环境，包括虚拟机和Java程序所需核心类库等。想运行一个开发好的Java程序，只安装JRE即可。</p><p>JDK的目录：bin，基本程序；db，数据库；include，头文件；lib，jar包；src，常用的类库和源码；</p><p>程序员编写.java 源文件，用javac.exe编译为.class 字节码文件，再用Java.exe运行；</p><p>编译运行java源文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac helloworld.java  (加后缀)</span><br><span class="line">java helloworld  （不加后缀）</span><br></pre></td></tr></table></figure><p>Java严格区分大小写，但是Windows路径不区分大小写；</p><p>注释分为单行注释、多行注释和文档注释；文档注释可被编译器编译，生成网页形式的说明文档；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">javadoc -d myHello -author -version HelloJava.java</span><br></pre></td></tr></table></figure><p>一个源文件中可以写多个类，但最多只能有一个类声明为public，并且这个类得和.java文件同名。 编译时每个类单独生成一个class文件。</p><h2 id="不知道学了多少遍的基础知识"><del>不知道学了多少遍的</del>基础知识</h2><h4 id="变量相关">变量相关</h4><p>Java中有关键字和保留字。保留字现在还不是关键字但以后可能会是。 自己起的变量名叫<strong>标识符</strong>，注意不能用数字开头；</p><p>命名规范：包名全小写；类名接口名所有单词首字母大写；变量和方法名第一个单词首字母小写，后面开始大写；常量名全大写，单词之间用_连接；变量必须定义在作用域（{}）中；</p><p>声明long型变量以l或者L结尾； char中只能有一个字符，可以是转义字符； Unicode底层字符，可以是如同'123'的字符；保存文件的时候用ANSI编码时，cmd可以输出中文；</p><h4 id="类型之间的关系">类型之间的关系</h4><p>byte、char、short同级，运算之后必须赋值给int类型的变量；强制类型转换时截断或者变成最小值； byte b+1编译不通过，因为默认常数是int型，小数是double型； string可以和boolean类型做运算，结果为后面连接一个true或者false；</p><p>进行赋值时，八进制用0开头，二进制0b开头，十六进制0x开头；</p><h4 id="运算符">运算符</h4><p>运算符分为算术、赋值、比较、逻辑、位运算、三元运算符； 取余运算的结果符号与被模数的符号相同。</p><p>自增1不会改变本身数据的类型（针对int，byte等类型）；Java支持连续赋值； +=不会改变变量本身的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 += <span class="number">2</span>;  <span class="comment">// 可通过编译；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n);  <span class="comment">// 32</span></span><br></pre></td></tr></table></figure><p>比较运算符结果都是Boolean型； instanceof()：检查是否是类的对象；</p><p>&amp;&amp; 短路与；|| 短路或；^ 逻辑异或。短路运算符按顺序运行，如果左侧的表达式已知其值是true或者false，则右侧的表达式不会进行计算； 逻辑运算符只能适用于布尔类型变量；</p><p>位运算：直接对整数的二进制进行运算。&gt;&gt;&gt; 无符号右移（不管被移动数字是正还是负，最高位都用0补齐）；~取反运算；</p><p>使用位运算符交换两个变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure><p>单目运算符、三元运算符、赋值运算符都是从右向左计算；这导致a?b:c?d:e 等价于 a?b:(c?d:e) 而不是 (a?b:c)?d:e</p><h4 id="java程序在控制台进行交互">Java程序在控制台进行交互</h4><p>从键盘获取不同类型变量：使用Scanner类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> num = scan.nextInt();</span><br><span class="line">string: scan.next();</span><br><span class="line">scan.nextDouble();</span><br><span class="line">scan.nextBoolean();</span><br></pre></td></tr></table></figure><p>char型没有单独的输入方式，可以用读取字符串的方式读入，再从中取出某一位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(i);</span><br><span class="line"></span><br><span class="line">String s = readKeyBoard(i);  <span class="comment">// 从键盘读入一个长度i的字符串</span></span><br><span class="line">s.tpUpperCase();  <span class="comment">// 变成大写</span></span><br><span class="line">s.charAt(i);  <span class="comment">// 可以取出某个位置的字符</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span>)(Math.random()*<span class="number">90</span>+<span class="number">10</span>);  <span class="comment">// random产生0到1的随机数</span></span><br></pre></td></tr></table></figure><p>switch后面的表达式类型可以是：byte，short，char，int，枚举类型，string</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x，y[];  <span class="comment">// x是一维数组，y是二维数组；</span></span><br><span class="line"><span class="comment">// 此时x代表一个对象（Java和C不同）</span></span><br><span class="line">y[<span class="number">0</span>] = x; <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">array2 = array1;  <span class="comment">// 即可完成数组的复制，注意这个时候array2和array1指向同一个位置，改array2，array1也会改变</span></span><br><span class="line"><span class="comment">// 正确的数组复制需要new一个数组，逐个赋值</span></span><br></pre></td></tr></table></figure><p>Java的string可以很长。</p><h4 id="数组">数组</h4><p>数组的元素可以是基本或者引用数据类型；数组长度定好之后不能修改！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] ids;</span><br><span class="line">ids = <span class="keyword">new</span> in[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>数组元素是引用数据类型则默认值是null；</p><p>arrays工具类的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(int[] a, int[] b);  //判断两个数组是否相等</span><br><span class="line">String toString(int[] a);  //输出数组信息</span><br><span class="line">void fill(int[] a, int val);  //指定值填充到数组中</span><br><span class="line">void sort(int[] a);  //排序</span><br><span class="line">int binarySearch(int[] a, int key);  //对排序后的数组进行二分法检索指定的值</span><br></pre></td></tr></table></figure><p>数组如果没有赋值会报空指针错误，null；</p><h4 id="新建变量的存储位置">新建变量的存储位置</h4><p>栈中：存放局部变量；堆中：new出来的对象和数组； string：常量池中；static类型的变量：保存在静态域中；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] arr2 = new String[3][2];</span><br><span class="line">String[][] arr3 = new String[3][];</span><br></pre></td></tr></table></figure><h2 id="java面向对象">Java面向对象</h2><p>Java类及类的成员包含的“内容”：属性，方法，构造器； 其中有些特殊的成员：代码块，内部类 面向对象的三大特性：封装，继承，多态。有些人还命名的其他特性如抽象性。</p><h4 id="类和对象">类和对象</h4><p>类的成员：属性（成员变量），行为（方法函数）。</p><p>属性直接定义在类的{}里，局部变量在方法等的内部； 局部变量不能加修饰符（除了final）。非static属性是类的每个对象都有一套。</p><p><del>小tips：alt+左箭头可以快速到函数定义位置或返回</del></p><p>如果要使用对象的方法，哪怕是在对象内部使用也要new一个对象；</p><p>四舍五入取整：Math.round(double d)；非对象语言和Java交互的时候依然表现为对象；</p><p>引用数据类型在使用的时候其变量名都是代表地址值；</p><p>匿名对象的使用（每次都重新创建一个对象）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new phone().sendEmail();</span><br><span class="line">mall.show(mew phone()); </span><br></pre></td></tr></table></figure><p>函数的值传递机制： 参数是基本数据类型，实参赋给形参的是他储存的真实数据值； 参数是引用数据类型，形参得到的是变量所保存的数据的地址值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(char[] x); //直接输出了char数组</span><br></pre></td></tr></table></figure><h4 id="重载">重载</h4><p>重载两同一不同：同一个类，相同方法名；参数列表不同：参数个数或者类型不同； 返回值相同或者不同都可以构成重载；</p><p>可变个数形参的方法：public void show(String ... strs)；即“数据类型 ... 数据名”的形式；参数数量可以是0个。</p><p>需要注意可变个数形参的方法与把数组作为参数的方法不构成重载； 可变个数形参必须放在最后；重载的函数中最多声明一个可变个数形参；</p><h4 id="类的封装和隐藏">类的封装和隐藏</h4><p>把类的属性声明成private，则类外不能直接调用属性；只能通过方法如setlegs，getlegs. 封装性的体现需要权限修饰符来配合：private，缺省，protected，public（从小到大）。 属性体现封装性，类也可以体现封装性；</p><table><thead><tr class="header"><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr class="odd"><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr class="even"><td>default</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr class="odd"><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr class="even"><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>有四种权限修饰符可以修饰类和类的内部结构。class的权限只可以用public和default； 不同的包可以定义重名类。</p><p>构造器：功能是创建对象，实际使用中和类同名。不显式定义则默认提供一个空参的构造器。构造器严格来说不是方法，可以重载。</p><p>属性赋值的先后顺序：默认，显式初始化，构造器中赋值，调用属性进行赋值。</p><p>Javabean：特殊的java类。类是公共的，有一个无参的公共的构造器，有属性，有对应的get，set方法；可重用组件。</p><p>默认构造器的权限和其所在的类相同。</p><p>在开发过程中，为了清晰的显示类和类之间的关系，可以使用UML类图。</p><h4 id="this和import的使用">this和import的使用</h4><p>方法内部用，则表示对该方法对象的引用；构造器内部使用，表示构造器正在初始化的对象；</p><p>this表示当前对象，可以修饰方法，属性；</p><p>类的方法中可以使用this.属性或this.方法，构造器中也可以this修饰方法和属性；</p><p>this调用构造器：this(args)，主要是为了减少构造器中的冗余代码；自始至终对象只有一个；this(args)必须声明在当前构造器首行，构造器内部最多只能调用一个其他构造器；</p><p><del>ALT+SHITF+S 调出代码生成器</del></p><p>package：更好的管理类，声明类或者接口属于的包，放在首行；</p><p>MVC设计模式：M模型处理数据，V视图显示数据，C控制处理业务逻辑；</p><p>import：在源文件中使用import导入指定包下的类和接口；声明在包和类的声明之间；import xxx.*导入其下所有内容，但是不包含其中的子包；</p><p>import static：导入类或接口中的静态结构，同时import static的结尾一定是.*</p><p><del>持续更新ing</del></p>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO和GitHub建站（一）</title>
      <link href="/b077d8cb.html"/>
      <url>/b077d8cb.html</url>
      
        <content type="html"><![CDATA[<h3 id="环境搭建">环境搭建</h3><p>首先安装node.js，直接官网下载安装。接着安装git for windows，直接官网安装（访问官网及后续安装搞个梯子会方便很多）。安装之后用下述语句查看版本以确认安装成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>新建一个文件夹用于存放博客相关的环境和内容配置，例如"blog"。在该文件夹中右击，选择"Git bash here"。安装HEXO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级，可不进行</span><br><span class="line">hexo init #初始化博客</span><br></pre></td></tr></table></figure><p>HEXO的常用指令如下（这些指令均要在上面创建的blog文件夹路径下运行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章</span><br><span class="line">hexo g == hexo generate # 生成</span><br><span class="line">hexo s == hexo server # 启动服务预览（安装hexo之后直接就可以进行）</span><br><span class="line">hexo d == hexo deploy # 部署到GitHub（需要预先与GitHub进行连接）</span><br><span class="line"># 上面的几条语句，使用的时候输入&quot;==&quot;前面的部分就可以了。</span><br><span class="line"></span><br><span class="line">hexo server # Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s # 静态模式</span><br><span class="line">hexo server -p 5000 # 更改端口</span><br><span class="line">hexo server -i 192.168.1.1 # 自定义 IP</span><br><span class="line">hexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure><p>这样就可以在本地预览网站效果。为了能在其他设备上访问自己的网站，我选择GitHub托管自己的数据。</p><p>具体的操作是在GitHub上建立仓库，然后配置权限让自己可以把blog的内容直接部署到GitHub上。上传成功之后就可以用仓库的名称来访问博客，如我的是"shymuel.github.io"。但github的后缀容易被墙，我的解决方法是自己购买一个域名。国内域名需要实名审核但比较保险，大家可以自行选择合适的域名商。</p><h3 id="volantis主题使用">Volantis主题使用</h3><p>HEXO使用量最大的主题大概就是<a href="http://theme-next.iissnan.com/getting-started.html">NexT</a>了，它的功能十分强大，看起来也比较简洁。</p><p>我为了看起来更加的二次元而选择了<a href="https://volantis.js.org/v5/getting-started/">Volantis</a>主题，主要是为了使用它的定时换背景功能（因为我有太多壁纸想放上去了）。图片目前我还是放在本地，采用相对路径。后面抽空研究一下如何使用CDN实现图片读取。</p><p>Volantis自带文章目录功能，可根据md文件中的标题在网页一侧生成目录。</p><p>配置背景图、头像之类的需要在blog文件夹下新建名为"_config.volantis.yml"的文件进行配置。建议按照<a href="https://volantis.js.org/v5/theme-settings/">主题文档</a>进行。</p><p>对于字数统计和阅读时长显示，先要安装wordcount插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount </span><br></pre></td></tr></table></figure><p>之后可以通过主题配置文件里的 word_count 关键字来选择是否开启此功能，默认false。在配置文件的enable后面加上true。</p><h3 id="twikoo评论插件">Twikoo评论插件</h3><p>根据<a href="https://twikoo.js.org/quick-start.html">官方文档</a>进行配置。我选择的是Vercel部署方式。原开发者做了非常非常详细的<a href="https://www.bilibili.com/video/BV1Fh411e7ZH">视频教程</a>。我把_config.volantis.yml中关于评论的设置改成了如下的样子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">twikoo:</span><br><span class="line">    js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本</span><br><span class="line">    path: # 全局评论地址</span><br><span class="line">    # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项</span><br><span class="line">    envId: https://twikoo-dusky.vercel.app/ # vercel id</span><br><span class="line">    appId: # your appId</span><br><span class="line">    appKey: # your appKey</span><br><span class="line">    meta: [nick,mail,link] # valine comment header info</span><br><span class="line">    requiredFields: [nick,mail]</span><br><span class="line">    enableQQ: true # Unstable avatar link</span><br><span class="line">    recordIP: false # Record commenter IP</span><br><span class="line">    avatar: img/avatar.jpg # gravatar style https://valine.js.org/avatar</span><br><span class="line">    pageSize: 10 # comment list page size</span><br><span class="line">    lang: zh-cn</span><br><span class="line">    highlight: true</span><br><span class="line">    mathJax: false</span><br><span class="line"></span><br></pre></td></tr></table></figure> 部署之后还可以根据自己的需求，下载密钥设置管理员密码来对评论系统进行管理和定制。</p><h3 id="暗黑模式">暗黑模式</h3><p>按照_config.volantis.yml中的描述，修改navbar目录，在menu子目录中添加： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- name: 暗黑模式 # 可自定义</span><br><span class="line">      icon: fas fa-moon # 可自定义</span><br><span class="line">      toggle: darkmode</span><br></pre></td></tr></table></figure></p><h3 id="自动生成文章的唯一永久链接">自动生成文章的唯一永久链接</h3><p>使用abbrlink生成。首先下载abbrlink。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>之后修改根目录站点配置文件config.yml，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://自己的网址名/</span><br><span class="line">permalink: :abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc32   #算法： crc16(default) and crc32</span><br></pre></td></tr></table></figure><p>之后hexo三连即可。</p><h3 id="插入latex公式">插入LateX公式</h3><p>更换渲染工具为 hexo-renderer-pandoc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装 hexo-math 插件以支持 latex 公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>volantis主题的话，在_config.volantis.yml中把mathjax后面改成true即可。注意要clean之后重新生成，latax公式才能正常显示。</p><p>记得要在有公式的博客开头加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件与编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 个人网站 </tag>
            
            <tag> 软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/b585e161.html"/>
      <url>/b585e161.html</url>
      
        <content type="html"><![CDATA[<p>最后还是回来写代码了……感觉传统工科的老师都在搞机器学习，那我也没有办法，只能重新回来刷题。</p><p>这个博客上的内容可能会写的支离破碎一些，毕竟现在都在做各种项目，也不可能把全部的代码放上来，大概只是记录一下自己能做到什么功能吧，核心代码也会放一些。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
